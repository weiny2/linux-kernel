/* stap probe of umad layer
 * invoke with class value you want to trace
 * ie for PM MAD's
 * stap umad-trace.stp <class> <method>
 *    <class> and/or <method> can be 0xFF which means "all"
 */

probe begin { printf ("probing...\n"); }


probe begin { printf ("class %d : method %d\n", $1, $2); }

probe module("ib_umad").function("ib_umad_reg_agent2")
{
	printf ("\n\n\n *** ib_umad_reg_agent2 ***\n");
	printf ("    ureq %s\n",
		@cast($arg, "struct ib_user_mad_reg_req2")$);

}
probe module("ib_mad").function("ib_register_mad_agent")
{
	printf (" *** ib_register_mad_agent ***\n");
	printf ("    req %s\n", $mad_reg_req$);
}
probe module("ib_mad").function("ib_register_mad_agent").return
{
	printf ("     ib_register_mad_agent.return %s\n", $$return);
}

probe module("ib_umad").function("ib_umad_write")
{
	class = @cast(@cast($buf, "struct ib_user_mad")->data,
			"struct ib_mad_hdr")->mgmt_class;

	method = @cast(@cast($buf, "struct ib_user_mad")->data,
				"struct ib_mad_hdr")->method;

	if ($2 == 0xff || method == $2) {
		// Check the class
		if ($1 == 0xff || class == $1)
		{
			printf("\n\n\n  *** ib_umad_write ***\n");

			printf("ib_user_mad count %d %s\n", $count, @cast($buf, "struct ib_user_mad")->hdr$);
			printf ("Umad header:");
			printf (" agent_id : %d; ",
				@cast($buf, "struct ib_user_mad")->hdr->id);
			printf ("\n");
			printf ("   MAD header:");
			printf (" base version: 0x%x; ",
				@cast(@cast($buf, "struct ib_user_mad")->data,
					"struct ib_mad_hdr")->base_version);
			printf (" class : 0x%x; ", class);
			printf (" method : 0x%x; ",
				@cast(@cast($buf, "struct ib_user_mad")->data,
					"struct ib_mad_hdr")->method);
			printf (" attribute : 0x%x; ",
				@cast(@cast($buf, "struct ib_user_mad")->data,
					"struct ib_mad_hdr")->attr_id);
			printf (" attr mod : 0x%x; ",
				@cast(@cast($buf, "struct ib_user_mad")->data,
					"struct ib_mad_hdr")->attr_mod);
			printf (" class version: 0x%x; ",
				@cast(@cast($buf, "struct ib_user_mad")->data,
					"struct ib_mad_hdr")->class_version);
			printf (" status: 0x%x; ",
				@cast(@cast($buf, "struct ib_user_mad")->data,
					"struct ib_mad_hdr")->status);
			printf (" => 0x%x",
				@cast($buf, "struct ib_user_mad")->hdr->lid);
			printf ("\n");

			if (class != 0x01 && class != 0x81) {
				printf ("   RMPP:");
				printf (" rmpp_version: 0x%x; ",
					@cast(&@cast($buf, "struct ib_user_mad")->data,
						"struct ib_rmpp_base")->rmpp_hdr->rmpp_version);
				printf (" rmpp_type: 0x%x; ",
					@cast(&@cast($buf, "struct ib_user_mad")->data,
						"struct ib_rmpp_base")->rmpp_hdr->rmpp_type);
				printf (" rmpp_rtime_flags: 0x%x; ",
					@cast(&@cast($buf, "struct ib_user_mad")->data,
						"struct ib_rmpp_base")->rmpp_hdr->rmpp_rtime_flags);
				printf (" rmpp_status: 0x%x; ",
					@cast(&@cast($buf, "struct ib_user_mad")->data,
						"struct ib_rmpp_base")->rmpp_hdr->rmpp_status);
				printf (" rmpp.seg_num: 0x%x; ",
					@cast(&@cast($buf, "struct ib_user_mad")->data,
						"struct ib_rmpp_base")->rmpp_hdr->seg_num);
				printf (" rmpp.paylen_newwin: 0x%x; ",
					@cast(&@cast($buf, "struct ib_user_mad")->data,
						"struct ib_rmpp_base")->rmpp_hdr->paylen_newwin);
				printf ("\n");
			}
		}
	}
}

probe module("ib_mad").function("ib_post_send_mad") {
	class = @cast($send_buf->mad, "struct ib_mad_hdr")->mgmt_class;

	method = @cast($send_buf->mad, "struct ib_mad_hdr")->method;

	if ($2 == 0xff || method == $2) {
		if ($1 == 0xff || class == $1)
		{
			printf("   *** ib_post_send_mad ***: agent %p; (%s)\n",
				$send_buf->mad_agent, $send_buf->mad_agent$);
			if (class == 0x01 || class == 0x81) {
				printf ("   SMP:");
				printf (" hop_ptr: 0x%x; ", @cast($send_buf->mad, "struct stl_smp")->hop_ptr);
				printf (" hop_cnt: 0x%x; ", @cast($send_buf->mad, "struct stl_smp")->hop_cnt);
				printf (" m_key: 0x%lx; ", @cast($send_buf->mad, "struct stl_smp")->mkey);
				printf ("\n");

				printf ("   IB SMP DR:");
				printf (" dr_slid: 0x%x; ", @cast($send_buf->mad, "struct ib_smp")->dr_slid);
				printf (" dr_dlid: 0x%x; ", @cast($send_buf->mad, "struct ib_smp")->dr_dlid);
				printf (" initial_path:");
				for (i = 0; i < 10; i++) {
					printf ("%d ", @cast($send_buf->mad, "struct ib_smp")->initial_path[i]);
				}
				printf (" ... return_path:");
				for (i = 0; i < 10; i++) {
					printf ("%d ", @cast($send_buf->mad, "struct ib_smp")->return_path[i]);
				}
				printf ("... \n");

				printf ("\n");
				printf ("   STL SMP DR:");
				printf (" dr_slid: 0x%x; ", @cast($send_buf->mad, "struct stl_smp")->route->dr->dr_slid);
				printf (" dr_dlid: 0x%x; ", @cast($send_buf->mad, "struct stl_smp")->route->dr->dr_dlid);
				printf (" initial_path:");
				for (i = 0; i < 10; i++) {
					printf ("%d ", @cast($send_buf->mad, "struct stl_smp")->route->dr->initial_path[i]);
				}
				printf (" ... return_path:");
				for (i = 0; i < 10; i++) {
					printf ("%d ", @cast($send_buf->mad, "struct stl_smp")->route->dr->return_path[i]);
				}
				printf ("... \n");
			}
			printf ("   send_buf->mad->mad_hdr : %s\n",
					@cast($send_buf->mad, "struct ib_rmpp_base")->mad_hdr$);
			if (class != 0x01 && class != 0x81) {
				printf ("   RMPP:");
				printf (" rmpp_version: 0x%x; ",
					@cast($send_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->rmpp_version);
				printf (" rmpp_type: 0x%x; ",
					@cast($send_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->rmpp_type);
				printf (" rmpp_rtime_flags: 0x%x; ",
					@cast($send_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->rmpp_rtime_flags);
				printf (" rmpp_status: 0x%x; ",
					@cast($send_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->rmpp_status);
				printf (" rmpp.seg_num: 0x%x; ",
					@cast($send_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->seg_num);
				printf (" rmpp.paylen_newwin: 0x%x; ",
					@cast($send_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->paylen_newwin);
				printf ("\n");
			}
		}
	}
}

probe module("ib_umad").function("recv_handler") {
	class = $mad_recv_wc->recv_buf->mad->mad_hdr->mgmt_class;
	if ($1 == 0xff || class == $1)
	{
		printf("\n\n\n  *** recv_handler *** (agent %p)\n", $agent);
		printf ("   mad_recv_wc->wc : %s\n", $mad_recv_wc->wc$);
		printf ("   mad_recv_wc->mad_len : %d\n", $mad_recv_wc->mad_len);
		printf ("   mad_recv_wc->recv_buf->mad->mad_hdr : %s\n",
				$mad_recv_wc->recv_buf->mad->mad_hdr$);

		if (class != 0x01 && class != 0x81) {
			printf ("   RMPP:");
			printf (" rmpp_version: 0x%x; ",
				@cast($mad_recv_wc->recv_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->rmpp_version);
			printf (" rmpp_type: 0x%x; ",
				@cast($mad_recv_wc->recv_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->rmpp_type);
			printf (" rmpp_rtime_flags: 0x%x; ",
				@cast($mad_recv_wc->recv_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->rmpp_rtime_flags);
			printf (" rmpp_status: 0x%x; ",
				@cast($mad_recv_wc->recv_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->rmpp_status);
			printf (" rmpp.seg_num: 0x%x; ",
				@cast($mad_recv_wc->recv_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->seg_num);
			printf (" rmpp.paylen_newwin: 0x%x; ",
				@cast($mad_recv_wc->recv_buf->mad, "struct ib_rmpp_base")->rmpp_hdr->paylen_newwin);
			printf ("\n");
		}
	}
}

/*
 * Other functions which have been useful to trace
probe module("ib_mad").function("handle_outgoing_dr_smp").return {
	printf("ib_mad:handle_outgoing_dr_smp %s\n", $$return);
}
probe module("ib_mad").function("ib_send_mad") {
	printf ("ib_send_mad: %s\n", $$parms);
	printf ("             %s\n", $mad_send_wr$);
}

probe module("ib_umad").function("ib_umad_read") {
	printf ("ib_umad_read: %s\n", $$parms);
}
probe module("ib_umad").function("ib_umad_read").return {
	printf ("   ib_umad_read.return %s\n", $$return);
}
probe module("ib_umad").function("ib_umad_write").return {
	printf ("   ib_umad_write: %s\n", $$return);
}
*/

/*
 * Process mad call in the driver...  Change module/function as you see fit
probe module("ib_wfr_lite").function("wfr_process_mad") {

	method = @cast($in_mad, "struct ib_mad_hdr")->method;

	if ($2 == 0xff || method == $2) {

		printf ("   wfr_process_mad %s\n", $$parms);
		printf ("            %s\n", @cast($in_mad, "struct ib_smp")$);
	}
}
*/

