/* SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0 */
/*
 * Copyright (C) 2015-2019 Intel Corp. All rights reserved
 */
#ifndef __RPMB_H__
#define __RPMB_H__

#include <linux/types.h>
#include <linux/device.h>
#include <linux/kref.h>

/**
 * struct rpmb_frame_jdec - rpmb frame as defined by JDEC specs
 *
 * @stuff        : stuff bytes
 * @key_mac      : The authentication key or the message authentication
 *                 code (MAC) depending on the request/response type.
 *                 The MAC will be delivered in the last (or the only)
 *                 block of data.
 * @data         : Data to be written or read by signed access.
 * @nonce        : Random number generated by the host for the requests
 *                 and copied to the response by the RPMB engine.
 * @write_counter: Counter value for the total amount of the successful
 *                 authenticated data write requests made by the host.
 * @addr         : Address of the data to be programmed to or read
 *                 from the RPMB. Address is the serial number of
 *                 the accessed block (half sector 256B).
 * @block_count  : Number of blocks (half sectors, 256B) requested to be
 *                 read/programmed.
 * @result       : Includes information about the status of the write counter
 *                 (valid, expired) and result of the access made to the RPMB.
 * @req_resp     : Defines the type of request and response to/from the memory.
 */
struct rpmb_frame_jdec {
	u8     stuff[196];
	u8     key_mac[32];
	u8     data[256];
	u8     nonce[16];
	__be32 write_counter;
	__be16 addr;
	__be16 block_count;
	__be16 result;
	__be16 req_resp;
} __packed;

#define RPMB_PROGRAM_KEY       0x0001    /* Program RPMB Authentication Key */
#define RPMB_GET_WRITE_COUNTER 0x0002    /* Read RPMB write counter */
#define RPMB_WRITE_DATA        0x0003    /* Write data to RPMB partition */
#define RPMB_READ_DATA         0x0004    /* Read data from RPMB partition */
#define RPMB_RESULT_READ       0x0005    /* Read result request  (Internal) */

#define RPMB_REQ2RESP(_OP) ((_OP) << 8)
#define RPMB_RESP2REQ(_OP) ((_OP) >> 8)

/**
 * enum rpmb_op_result - rpmb operation results
 *
 * @RPMB_ERR_OK      : operation successful
 * @RPMB_ERR_GENERAL : general failure
 * @RPMB_ERR_AUTH    : mac doesn't match or ac calculation failure
 * @RPMB_ERR_COUNTER : counter doesn't match or counter increment failure
 * @RPMB_ERR_ADDRESS : address out of range or wrong address alignment
 * @RPMB_ERR_WRITE   : data, counter, or result write failure
 * @RPMB_ERR_READ    : data, counter, or result read failure
 * @RPMB_ERR_NO_KEY  : authentication key not yet programmed
 *
 * @RPMB_ERR_COUNTER_EXPIRED:  counter expired
 */
enum rpmb_op_result {
	RPMB_ERR_OK      = 0x0000,
	RPMB_ERR_GENERAL = 0x0001,
	RPMB_ERR_AUTH    = 0x0002,
	RPMB_ERR_COUNTER = 0x0003,
	RPMB_ERR_ADDRESS = 0x0004,
	RPMB_ERR_WRITE   = 0x0005,
	RPMB_ERR_READ    = 0x0006,
	RPMB_ERR_NO_KEY  = 0x0007,

	RPMB_ERR_COUNTER_EXPIRED = 0x0080
};

/**
 * enum rpmb_type - type of underlying storage technology
 *
 * @RPMB_TYPE_ANY   : any type, used for search only
 * @RPMB_TYPE_EMMC  : eMMC (JESD84-B50.1)
 * @RPMB_TYPE_UFS   : UFS (JESD220)
 * @RPMB_TYPE_NVME  : NVM Express Revision 1.3a
 * @RPMB_TYPE_SIM   : Simulation device.
 * @RPMB_TYPE_MAX   : upper sentinel
 */
enum rpmb_type {
	RPMB_TYPE_ANY = 0,
	RPMB_TYPE_EMMC,
	RPMB_TYPE_UFS,
	RPMB_TYPE_NVME,

	RPMB_TYPE_SIM = 0x0100,
	RPMB_TYPE_MAX = RPMB_TYPE_SIM | RPMB_TYPE_NVME,
};

#define RPMB_TYPE_HW(_type) ((_type) & 0xFF)

extern struct class rpmb_class;

#define RPMB_F_WRITE     BIT(0)
#define RPMB_F_REL_WRITE BIT(1)

/**
 * struct rpmb_cmd: rpmb access command
 *
 * @flags:   command flags
 *      0 - read command
 *      1 - write command RPMB_F_WRITE
 *      2 - reliable write RPMB_F_REL_WRITE
 * @nframes: number of rpmb frames in the command
 * @frames:  list of rpmb frames
 */
struct rpmb_cmd {
	u32 flags;
	u32 nframes;
	void *frames;
};

enum rpmb_auth_method {
	RPMB_HMAC_ALGO_SHA_256 = 0,
};

/**
 * struct rpmb_ops - RPMB ops to be implemented by underlying block device
 *
 * @cmd_seq        : send RPMB command sequence to the RPBM partition
 *                   backed by the storage device to specific
 *                   region(UFS)/target(NVMe)
 * @get_capacity   : rpmb size in 128K units in for region/target.
 * @type           : block device type eMMC, UFS, NVMe.
 * @block_size     : block size in half sectors (1 == 256B)
 * @wr_cnt_max     : maximal number of blocks that can be
 *                   written in one access.
 * @rd_cnt_max     : maximal number of blocks that can be
 *                   read in one access.
 * @auth_method    : rpmb_auth_method
 * @dev_id         : unique device identifier
 * @dev_id_len     : unique device identifier length
 */
struct rpmb_ops {
	int (*cmd_seq)(struct device *dev, u8 target,
		       struct rpmb_cmd *cmds, u32 ncmds);
	int (*get_capacity)(struct device *dev, u8 target);
	u32 type;
	u16 block_size;
	u16 wr_cnt_max;
	u16 rd_cnt_max;
	u16 auth_method;
	const u8 *dev_id;
	size_t dev_id_len;
};

/**
 * struct rpmb_dev - device which can support RPMB partition
 *
 * @lock       : the device lock
 * @dev        : device
 * @id         : device id
 * @target     : RPMB target/region within the physical device
 * @ops        : operation exported by block layer
 */
struct rpmb_dev {
	struct mutex lock; /* device serialization lock */
	struct device dev;
	int id;
	u8 target;
	const struct rpmb_ops *ops;
};

#define to_rpmb_dev(x) container_of((x), struct rpmb_dev, dev)

#if IS_ENABLED(CONFIG_RPMB)
struct rpmb_dev *rpmb_dev_get(struct rpmb_dev *rdev);
void rpmb_dev_put(struct rpmb_dev *rdev);
struct rpmb_dev *rpmb_dev_find_by_device(struct device *parent, u8 target);
struct rpmb_dev *rpmb_dev_get_by_type(u32 type);
struct rpmb_dev *rpmb_dev_register(struct device *dev, u8 target,
				   const struct rpmb_ops *ops);
void *rpmb_dev_get_drvdata(const struct rpmb_dev *rdev);
void rpmb_dev_set_drvdata(struct rpmb_dev *rdev, void *data);
int rpmb_dev_unregister(struct rpmb_dev *rdev);
int rpmb_dev_unregister_by_device(struct device *dev, u8 target);
int rpmb_cmd_seq(struct rpmb_dev *rdev, struct rpmb_cmd *cmds, u32 ncmds);
int rpmb_get_capacity(struct rpmb_dev *rdev);

#else
static inline struct rpmb_dev *rpmb_dev_get(struct rpmb_dev *rdev)
{
	return NULL;
}

static inline void rpmb_dev_put(struct rpmb_dev *rdev) { }

static inline struct rpmb_dev *rpmb_dev_find_by_device(struct device *parent,
						       u8 target)
{
	return NULL;
}

static inline
struct rpmb_dev *rpmb_dev_get_by_type(enum rpmb_type type)
{
	return NULL;
}

static inline void *rpmb_dev_get_drvdata(const struct rpmb_dev *rdev)
{
	return NULL;
}

static inline void rpmb_dev_set_drvdata(struct rpmb_dev *rdev, void *data)
{
}

static inline struct rpmb_dev *
rpmb_dev_register(struct device *dev, u8 target, const struct rpmb_ops *ops)
{
	return NULL;
}

static inline int rpmb_dev_unregister(struct rpmb_dev *dev)
{
	return 0;
}

static inline int rpmb_dev_unregister_by_device(struct device *dev, u8 target)
{
	return 0;
}

static inline int rpmb_cmd_seq(struct rpmb_dev *rdev,
			       struct rpmb_cmd *cmds, u32 ncmds)
{
	return 0;
}

static inline int rpmb_get_capacity(struct rpmb_dev *rdev)
{
	return 0;
}

#endif /* CONFIG_RPMB */

#endif /* __RPMB_H__ */
