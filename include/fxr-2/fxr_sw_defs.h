/*
* -------------------------------------------------------------------
* --                      Intel Proprietary
* --              Copyright (C) 2014 Intel Corporation
* --                    All Rights Reserved
* -------------------------------------------------------------------
* --           Auto-generated by /p/slx/pvesv/wfr_autogen/utils/scripts/i_csrs/i_csrs.pl 
* --  i_csrs.pl Version 1.5 last modified on Tuesday 7/29/14 09:09:34
* --   /p/slx/pvesv/wfr_autogen/utils/scripts/i_csrs/i_csrs.pl -C -S fxr_sw -o /p/slx/pvesv/fxr_autogen/fxr /p/slx/pvesv/fxr_autogen/Fox_River/xml/020_TOC.xml /p/slx/pvesv/fxr_autogen/Fox_River/xml/110_Link_Fabric_Sublayer.xml /p/slx/pvesv/fxr_autogen/Fox_River/xml/131_Portals_Transport_Layer.xml /p/slx/pvesv/fxr_autogen/Fox_River/xml/200_Software_Interfaces.xml /p/slx/pvesv/fxr_autogen/Fox_River/xml/140_OutstandingRequest_and_Reliability.xml  
* --------------------------------------------------------------------
*/

#ifndef DEF_FXR_SW_SW_DEF
#define DEF_FXR_SW_SW_DEF

#define PTL_EVENT_COMM_DISABLE			0x00000001
#define PTL_EVENT_SUCCESS_DISABLE		0x00000002
#define PTL_EVENT_OVER_DISABLE			0x00000004
#define PTL_EVENT_LINK_DISABLE			0x00000008
#define PTL_EVENT_FLOWCTRL_DISABLE		0x00000010
#define PTL_EVENT_UNLINK_DISABLE		0x00000020
#define PTL_IOVEC				0x00000040
#define PTL_EVENT_CT_BYTES			0x00000080
#define PTL_EVENT_CT_OVERFLOW			0x00000100
#define PTL_EVENT_CT_COMM			0x00000200
#define PTL_USE_ONCE				0x00000400
#define PTL_ACK_DISABLE				0x00000800
#define PTL_UNEXPECTED_HDR_DISABLE		0x00001000
#define PTL_NO_ATOMIC				0x00002000
#define PTL_ME_MANAGE_LOCAL			0x00004000
#define PTL_ME_NO_TRUNCATE			0x00008000
#define PTL_OP_PUT				0x00010000
#define PTL_OP_GET				0x00020000
#define PTL_ME_MAY_ALIGN			0x00040000
#define PTL_IS_ACCESSIBLE			0x00080000
#define PTL_MD_EVENT_SUCCESS_DISABLE		0x01
#define PTL_MD_EVENT_CT_SEND			0x02
#define PTL_MD_EVENT_CT_REPLY			0x04
#define PTL_MD_EVENT_CT_ACK			0x08
#define PTL_MD_EVENT_CT_BYTES			0x10
#define PTL_MD_EVENT_SEND_DISABLE		0x20
#define PTL_MD_RESERVED_IOV			0x00000040
#define PTL_MD_RESERVED1			0x80
#define PTL_MD_VOLATILE				0x100
#define PTL_MD_UNORDERED			0x200
#define FXR_NUM_NIS				4
#define FXR_NUM_PTES				256
#define FXR_NUM_EVENT_HANDLES			2048
#define FXR_MAX_ENTRIES				65535
#define FXR_PTE_SIZE				32
#define FXR_CT_SIZE				32
#define FXR_EQD_SIZE				16
#define FXR_ENTRY_SIZE				128
#define FXR_PTE_OFFSET				0x00000
#define FXR_PTE_ARRAY_SIZE			32768
#define FXR_CT_OFFSET				0x00000 + 32768
#define FXR_CT_ARRAY_SIZE			262144
#define FXR_EQD_OFFSET				0x00000 + 32768 + 262144
#define FXR_EQD_ARRAY_SIZE			131072
#define FXR_EQ_HEAD_OFFSET			0x00000 + 32768 + 262144 + 131072
#define FXR_EQ_HEAD_ARRAY_SIZE			32768
#define FXR_TRIG_OP_OFFSET			0x00000 + 32768 + 262144 + 131072 + 32768

/*
*  Enumerations from tables
*/
/* Enumeration from Table titled: L2 Fabric Packet Type Encoding (Enum - l2_t) - 2 bits
*                        In File: 110_Link_Fabric_Sublayer.xml
*/
#if defined(__STDC__)

enum l2 {
          HDR_8B = 0,           /* 8B L2 header. See #%%#Section 8.2.2.1 */
         HDR_10B = 1,           /* 10B L2 header. See #%%#Section 8.2.2.2 */
         HDR_16B = 2,           /* 16B L2 header. See #%%#Section 8.2.2.3 */
         HDR_EXT = 3            /* 9B L2 header or Future L2 headers. See L2Ext below. */
};

#else

#define   HDR_8B   0            /* 8B L2 header. See #%%#Section 8.2.2.1 */
#define  HDR_10B   1            /* 10B L2 header. See #%%#Section 8.2.2.2 */
#define  HDR_16B   2            /* 16B L2 header. See #%%#Section 8.2.2.3 */
#define  HDR_EXT   3             /* 9B L2 header or Future L2 headers. See L2Ext below. */

#endif


/* Enumeration from Table titled: L2 Extension Encoding (Enum - l2ext_t) - 4 bits
*                        In File: 110_Link_Fabric_Sublayer.xml
*/
#if defined(__STDC__)

enum l2ext {
                  HDR_9B = 0,           /* 9B L2 header. See #%%#Section 8.2.2.4 */
            HDR_FUTURE_0 = 1,           /* Future L2 Expansion. See #%%#Section 8.2.2.5 */
            HDR_FUTURE_1 = 1,           
            HDR_FUTURE_2 = 2,           
            HDR_FUTURE_3 = 3,           
            HDR_FUTURE_4 = 4,           
            HDR_FUTURE_5 = 5,           
            HDR_FUTURE_6 = 6,           
            HDR_FUTURE_7 = 7,           
            HDR_FUTURE_8 = 8,           
            HDR_FUTURE_9 = 9,           
           HDR_FUTURE_10 = 10,          
           HDR_FUTURE_11 = 11,          
           HDR_FUTURE_12 = 12,          
           HDR_FUTURE_13 = 13,          
           HDR_FUTURE_14 = 14           
};

#else

#define           HDR_9B   0            /* 9B L2 header. See #%%#Section 8.2.2.4 */
#define     HDR_FUTURE_0   1            /* Future L2 Expansion. See #%%#Section 8.2.2.5 */
#define     HDR_FUTURE_1   1            
#define     HDR_FUTURE_2   2            
#define     HDR_FUTURE_3   3            
#define     HDR_FUTURE_4   4            
#define     HDR_FUTURE_5   5            
#define     HDR_FUTURE_6   6            
#define     HDR_FUTURE_7   7            
#define     HDR_FUTURE_8   8            
#define     HDR_FUTURE_9   9            
#define    HDR_FUTURE_10   10           
#define    HDR_FUTURE_11   11           
#define    HDR_FUTURE_12   12           
#define    HDR_FUTURE_13   13           
#define    HDR_FUTURE_14   14            

#endif


/* Enumeration from Table titled: RC Encoding (Enum - rc_t) - 3 bits
*                        In File: 110_Link_Fabric_Sublayer.xml
*/
#if defined(__STDC__)

enum rc {
              RC_DETERMINISTIC_0 = 0,           /* In order bias to optimize latency (minimal hops) */
                   RC_ADAPTIVE_0 = 1,           /* No order requirement bias to optimize latency (minimal hops) */
              RC_DETERMINISTIC_1 = 2,           /* In order bias to optimize bandwidth (allows non minimal hops) */
                   RC_ADAPTIVE_1 = 3            /* No order requirement bias to optimize bandwidth (allows non minimal hops) */
};

#else

#define       RC_DETERMINISTIC_0   0            /* In order bias to optimize latency (minimal hops) */
#define            RC_ADAPTIVE_0   1            /* No order requirement bias to optimize latency (minimal hops) */
#define       RC_DETERMINISTIC_1   2            /* In order bias to optimize bandwidth (allows non minimal hops) */
#define            RC_ADAPTIVE_1   3             /* No order requirement bias to optimize bandwidth (allows non minimal hops) */

#endif


/* Enumeration from Table titled: L4 Type Encoding for 16B Header Format (Enum - ptl_l4_t) - 8 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum ptl_l4 {
                         PTL_RTS = 240,         /* Portals Request To Send (RTS) for Put/Atomic/Get */
                    PTL_REND_REQ = 241,         /* Portals Basic Rendezvous Request (Put/Atomic/Get) */
                  PTL_REND_EVENT = 242,         /* Portals Rendezvous Event */
                PTL_E2E_CTRL_REQ = 243,         /* Portals E2E Control Request. Ordering rules dependent on OPCODE. */
               PTL_E2E_CTRL_RESP = 244,         /* Portals E2E Control Response. */
                     PTL_REQUEST = 248,         /* Portals Request (Put/Atomic/Get) */
               PTL_FETCH_REQUEST = 249,         /* Portals Fetching Request (FetchAtomic/TwoOperand Atomics) */
                    PTL_RESPONSE = 250,         /* Portals Reply / Portal Full ACK / E2E Extended ACK */
              PTL_E2E_BASIC_ACK0 = 252,         /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=00b */
              PTL_E2E_BASIC_ACK1 = 253,         /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=01b */
              PTL_E2E_BASIC_ACK2 = 254,         /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=10b */
              PTL_E2E_BASIC_ACK3 = 255          /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=11b */
};

#else

#define                  PTL_RTS   240          /* Portals Request To Send (RTS) for Put/Atomic/Get */
#define             PTL_REND_REQ   241          /* Portals Basic Rendezvous Request (Put/Atomic/Get) */
#define           PTL_REND_EVENT   242          /* Portals Rendezvous Event */
#define         PTL_E2E_CTRL_REQ   243          /* Portals E2E Control Request. Ordering rules dependent on OPCODE. */
#define        PTL_E2E_CTRL_RESP   244          /* Portals E2E Control Response. */
#define              PTL_REQUEST   248          /* Portals Request (Put/Atomic/Get) */
#define        PTL_FETCH_REQUEST   249          /* Portals Fetching Request (FetchAtomic/TwoOperand Atomics) */
#define             PTL_RESPONSE   250          /* Portals Reply / Portal Full ACK / E2E Extended ACK */
#define       PTL_E2E_BASIC_ACK0   252          /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=00b */
#define       PTL_E2E_BASIC_ACK1   253          /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=01b */
#define       PTL_E2E_BASIC_ACK2   254          /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=10b */
#define       PTL_E2E_BASIC_ACK3   255           /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=11b */

#endif


/* Enumeration from Table titled: OPCODE Assignments for Basic Requests (PTL_REQUEST), Rendezvous RTS (PTL_RTS), Rendezvous Requests (PTL_REND_REQ), and Rendezvous Events (PTL_REND_EVENT) (Enum - ptl_op_req_t) - 5 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum ptl_op_req {
             PTL_REQ_PUT = 0,           /* Put data to the target address */
             PTL_REQ_GET = 1,           /* Get data from the target address and return it to the initiator */
             PTL_REQ_MIN = 4,           /* Compute the minimum of the initiator and target value */
             PTL_REQ_MAX = 5,           /* Compute the maximum of the initiator and target value */
             PTL_REQ_SUM = 6,           /* Compute the sum of the initiator and target value. This is a non-saturating addition, so that the result will simply roll-over. */
            PTL_REQ_DIFF = 7,           /* Compute the difference between the target and initiator value (target - initiator). This is a non-saturating subtraction, so that the result will simply roll-over */
            PTL_REQ_PROD = 8,           /* Compute the product of the initiator and target value. The low N bits of an NxN product are returned. */
             PTL_REQ_LOR = 9,           /* Compute the logical OR of the initiator and target value */
            PTL_REQ_LAND = 10,          /* Compute the logical AND of the initiator and target value */
            PTL_REQ_LXOR = 11,          /* Compute the logical XOR of the initiator and target value */
             PTL_REQ_BOR = 12,          /* Compute the bitwise OR of the initiator and target value */
            PTL_REQ_BAND = 13,          /* Compute the bitwise AND of the initiator and target value */
            PTL_REQ_BXOR = 14           /* Compute the bitwise XOR of the initiator and target value */
};

#else

#define      PTL_REQ_PUT   0            /* Put data to the target address */
#define      PTL_REQ_GET   1            /* Get data from the target address and return it to the initiator */
#define      PTL_REQ_MIN   4            /* Compute the minimum of the initiator and target value */
#define      PTL_REQ_MAX   5            /* Compute the maximum of the initiator and target value */
#define      PTL_REQ_SUM   6            /* Compute the sum of the initiator and target value. This is a non-saturating addition, so that the result will simply roll-over. */
#define     PTL_REQ_DIFF   7            /* Compute the difference between the target and initiator value (target - initiator). This is a non-saturating subtraction, so that the result will simply roll-over */
#define     PTL_REQ_PROD   8            /* Compute the product of the initiator and target value. The low N bits of an NxN product are returned. */
#define      PTL_REQ_LOR   9            /* Compute the logical OR of the initiator and target value */
#define     PTL_REQ_LAND   10           /* Compute the logical AND of the initiator and target value */
#define     PTL_REQ_LXOR   11           /* Compute the logical XOR of the initiator and target value */
#define      PTL_REQ_BOR   12           /* Compute the bitwise OR of the initiator and target value */
#define     PTL_REQ_BAND   13           /* Compute the bitwise AND of the initiator and target value */
#define     PTL_REQ_BXOR   14            /* Compute the bitwise XOR of the initiator and target value */

#endif


/* Enumeration from Table titled: OPCODE Assignments for Fetching Operations, including Swap, CSwap, and Fetching Atomics (Enum - ptl_fetch_op_req_t) - 5 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum ptl_fetch_op_req {
                   PTL_REQ_FETCHING_SWAP = 0,           /* Retrieve the current value from the target and replace it with the new value. This operation is limited to operating on a single element of a given datatype */
                    PTL_REQ_FETCHING_MIN = 4,           /* Compute the minimum of the initiator and target value and return the original value */
                    PTL_REQ_FETCHING_MAX = 5,           /* Compute the maximum of the initiator and target value and return the original value */
                    PTL_REQ_FETCHING_SUM = 6,           /* Compute the sum of the initiator and target value and return the original value */
                   PTL_REQ_FETCHING_DIFF = 7,           /* Compute the difference between the target and initiator value (target - initiator) and return the original value */
                   PTL_REQ_FETCHING_PROD = 8,           /* Compute the product of the initiator and target value and return the original value */
                    PTL_REQ_FETCHING_LOR = 9,           /* Compute the logical OR of the initiator and target value and return the original value */
                   PTL_REQ_FETCHING_LAND = 10,          /* Compute the logical AND of the initiator and target value and return the original value */
                   PTL_REQ_FETCHING_LXOR = 11,          /* Compute the logical XOR of the initiator and target value and return the original value */
                    PTL_REQ_FETCHING_BOR = 12,          /* Compute the bitwise OR of the initiator and target value and return the original value */
                   PTL_REQ_FETCHING_BAND = 13,          /* Compute the bitwise AND of the initiator and target value and return the original value */
                   PTL_REQ_FETCHING_BXOR = 14,          /* Compute the bitwise XOR of the initiator and target value and return the original value */
                  PTL_REQ_FETCHING_CSWAP = 17,          /* A conditional version of the swap operation. If the value of the operand is equal to the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to operating on a single element of a given datatype. */
               PTL_REQ_FETCHING_CSWAP_NE = 18,          /* A conditional version of the swap operation. If the value of the operand is not equal to the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to operating on a single element of a given datatype */
               PTL_REQ_FETCHING_CSWAP_LE = 19,          /* A conditional version of the swap operation. If the value of the operand is less than or equal to the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to operating on a single element of a given datatype. */
               PTL_REQ_FETCHING_CSWAP_LT = 20,          /* A conditional version of the swap operation. If the value of the operand is less than the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to single data items. */
               PTL_REQ_FETCHING_CSWAP_GE = 21,          /* A conditional version of the swap operation. If the value of the operand is greater than or equal to the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to operating on a single element of a given datatype. */
               PTL_REQ_FETCHING_CSWAP_GT = 22,          /* A conditional version of the swap operation. If the value of the operand is greater than the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to operating on a single element of a given datatype. */
                  PTL_REQ_FETCHING_MSWAP = 23           /* A masked version of the swap operation. Update the bits of the target value that are set to 1 in the operand using the bits in the initiator value. Return the target value. This operation is limited to operating on a single element of a given datatype. */
};

#else

#define            PTL_REQ_FETCHING_SWAP   0            /* Retrieve the current value from the target and replace it with the new value. This operation is limited to operating on a single element of a given datatype */
#define             PTL_REQ_FETCHING_MIN   4            /* Compute the minimum of the initiator and target value and return the original value */
#define             PTL_REQ_FETCHING_MAX   5            /* Compute the maximum of the initiator and target value and return the original value */
#define             PTL_REQ_FETCHING_SUM   6            /* Compute the sum of the initiator and target value and return the original value */
#define            PTL_REQ_FETCHING_DIFF   7            /* Compute the difference between the target and initiator value (target - initiator) and return the original value */
#define            PTL_REQ_FETCHING_PROD   8            /* Compute the product of the initiator and target value and return the original value */
#define             PTL_REQ_FETCHING_LOR   9            /* Compute the logical OR of the initiator and target value and return the original value */
#define            PTL_REQ_FETCHING_LAND   10           /* Compute the logical AND of the initiator and target value and return the original value */
#define            PTL_REQ_FETCHING_LXOR   11           /* Compute the logical XOR of the initiator and target value and return the original value */
#define             PTL_REQ_FETCHING_BOR   12           /* Compute the bitwise OR of the initiator and target value and return the original value */
#define            PTL_REQ_FETCHING_BAND   13           /* Compute the bitwise AND of the initiator and target value and return the original value */
#define            PTL_REQ_FETCHING_BXOR   14           /* Compute the bitwise XOR of the initiator and target value and return the original value */
#define           PTL_REQ_FETCHING_CSWAP   17           /* A conditional version of the swap operation. If the value of the operand is equal to the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to operating on a single element of a given datatype. */
#define        PTL_REQ_FETCHING_CSWAP_NE   18           /* A conditional version of the swap operation. If the value of the operand is not equal to the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to operating on a single element of a given datatype */
#define        PTL_REQ_FETCHING_CSWAP_LE   19           /* A conditional version of the swap operation. If the value of the operand is less than or equal to the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to operating on a single element of a given datatype. */
#define        PTL_REQ_FETCHING_CSWAP_LT   20           /* A conditional version of the swap operation. If the value of the operand is less than the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to single data items. */
#define        PTL_REQ_FETCHING_CSWAP_GE   21           /* A conditional version of the swap operation. If the value of the operand is greater than or equal to the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to operating on a single element of a given datatype. */
#define        PTL_REQ_FETCHING_CSWAP_GT   22           /* A conditional version of the swap operation. If the value of the operand is greater than the target value, the initiator and target value are swapped. The target value is always returned. This operation is limited to operating on a single element of a given datatype. */
#define           PTL_REQ_FETCHING_MSWAP   23            /* A masked version of the swap operation. Update the bits of the target value that are set to 1 in the operand using the bits in the initiator value. Return the target value. This operation is limited to operating on a single element of a given datatype. */

#endif


/* Enumeration from Table titled: OPCODE Assignments for Portals Responses (Enum - ptl_op_response_t) - 5 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum ptl_op_response {
                                 PTL_ACK = 0,           /* Normal Portals ACK */
                              PTL_NO_ACK = 1,           /* Portals ACK was refused by the target process. The stateful response is needed to convey to the initiator side implementation that a PTL_EVENT_ACK should not be delivered for this operation. This allows the initiator to free resources that might be reserved for the purpose. */
                               PTL_REPLY = 2,           /* Normal Portals Reply */
                         PTL_SHORT_REPLY = 3,           /* Portals Reply (response to a Get/Swap/Fetching Atomic operation) with only enough information for an OC event. This enables a smaller packet format. */
                        PTL_NACK_PTE_DIS = 4,           /* The Portals operation encountered a disabled PT Entry */
                          PTL_NACK_PERMV = 5,           /* The Portals operation failed the permissions check at the target */
                            PTL_NACK_OPV = 6,           /* The Portals operation specified an invalid operation (Put/Get) for the ME or LE it resolved to */
                           PTL_NACK_SEGV = 7,           /* The Portals operation resolved to a virtual address that would have caused a segmentation fault. */
                        PTL_NACK_INV_TGT = 8,           /* The Portals operation specified an invalid target PID or target PT Index. */
                    PTL_NACK_UNSUPPORTED = 9,           /* Indicates that an unsupported operation was attempted. */
                        PTL_E2E_ONLY_ACK = 12,          /* Used for an E2E extended ACK format */
               PTL_E2E_ONLY_NACK_SPECIAL = 13,          /* Used for E2E NACK / Special ACK formats that add the maximum distance and oldest outstanding fields. */
                                 PTL_CTS = 16,          /* The initiator may send the data and does not need to include an event message after completing the data. */
                                PTL_ECTS = 17           /* The target was unable to allocate state to track completion for this message. The initiator must track completion and send and event message after all acknowledgements for the rendezvous operation have been received. */
};

#else

#define                          PTL_ACK   0            /* Normal Portals ACK */
#define                       PTL_NO_ACK   1            /* Portals ACK was refused by the target process. The stateful response is needed to convey to the initiator side implementation that a PTL_EVENT_ACK should not be delivered for this operation. This allows the initiator to free resources that might be reserved for the purpose. */
#define                        PTL_REPLY   2            /* Normal Portals Reply */
#define                  PTL_SHORT_REPLY   3            /* Portals Reply (response to a Get/Swap/Fetching Atomic operation) with only enough information for an OC event. This enables a smaller packet format. */
#define                 PTL_NACK_PTE_DIS   4            /* The Portals operation encountered a disabled PT Entry */
#define                   PTL_NACK_PERMV   5            /* The Portals operation failed the permissions check at the target */
#define                     PTL_NACK_OPV   6            /* The Portals operation specified an invalid operation (Put/Get) for the ME or LE it resolved to */
#define                    PTL_NACK_SEGV   7            /* The Portals operation resolved to a virtual address that would have caused a segmentation fault. */
#define                 PTL_NACK_INV_TGT   8            /* The Portals operation specified an invalid target PID or target PT Index. */
#define             PTL_NACK_UNSUPPORTED   9            /* Indicates that an unsupported operation was attempted. */
#define                 PTL_E2E_ONLY_ACK   12           /* Used for an E2E extended ACK format */
#define        PTL_E2E_ONLY_NACK_SPECIAL   13           /* Used for E2E NACK / Special ACK formats that add the maximum distance and oldest outstanding fields. */
#define                          PTL_CTS   16           /* The initiator may send the data and does not need to include an event message after completing the data. */
#define                         PTL_ECTS   17            /* The target was unable to allocate state to track completion for this message. The initiator must track completion and send and event message after all acknowledgements for the rendezvous operation have been received. */

#endif


/* Enumeration from Table titled: OPCODE Assignments for E2E Control Packets (Enum - ptl_op_e2e_ctrl_t) - 5 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum ptl_op_e2e_ctrl {
              PTL_SINGLE_CONNECT = 0,           /* Establish a new connection between nodes for a specific traffic class */
               PTL_MULTI_CONNECT = 1,           /* Establish a new connection between a pair of nodes for all configured traffic classes */
              PTL_SINGLE_DESTROY = 2,           /* Remove an existing connection between a pair of nodes for a specific traffic class */
               PTL_MULTI_DESTROY = 3,           /* Remove an existing connection between a pair of nodes for all traffic classes */
                  PTL_E2E_FILLER = 4,           /* Replaces a deleted packet to maintain the sequence number space. PSN field is used to update the ordered or unordered sequence number space based on the routing code - just as it is with a standard packet. */
                   PTL_E2E_ESTAB = 5,           /* A new connection has been established using the sequence numbers included */
                    PTL_E2E_NACK = 6,           /* The new connection establishment failed. */
              PTL_E2E_STATUS_REQ = 7,           /* Requests the current status of the target (receive) side of the connection for a given <SLID, DLID, TC> tuple. Generates a PTL_E2E_STATUS_RESP. */
             PTL_E2E_STATUS_RESP = 8,           /* Carries the current status of a connection for a given <SLID, DLID, TC> tuple, which includes the maximum sequence distance and current expected PSN for both the ordered and unordered channels. */
                           TBD_0 = 9,           
                           TBD_1 = 9,           
                           TBD_2 = 10,          
                           TBD_3 = 11,          
                           TBD_4 = 12,          
                           TBD_5 = 13,          
                           TBD_6 = 14,          
                           TBD_7 = 15,          
                           TBD_8 = 16,          
                           TBD_9 = 17,          
                          TBD_10 = 18,          
                          TBD_11 = 19,          
                          TBD_12 = 20,          
                          TBD_13 = 21,          
                          TBD_14 = 22,          
                          TBD_15 = 23,          
                          TBD_16 = 24,          
                          TBD_17 = 25,          
                          TBD_18 = 26,          
                          TBD_19 = 27,          
                          TBD_20 = 28,          
                          TBD_21 = 29,          
                          TBD_22 = 30           
};

#else

#define       PTL_SINGLE_CONNECT   0            /* Establish a new connection between nodes for a specific traffic class */
#define        PTL_MULTI_CONNECT   1            /* Establish a new connection between a pair of nodes for all configured traffic classes */
#define       PTL_SINGLE_DESTROY   2            /* Remove an existing connection between a pair of nodes for a specific traffic class */
#define        PTL_MULTI_DESTROY   3            /* Remove an existing connection between a pair of nodes for all traffic classes */
#define           PTL_E2E_FILLER   4            /* Replaces a deleted packet to maintain the sequence number space. PSN field is used to update the ordered or unordered sequence number space based on the routing code - just as it is with a standard packet. */
#define            PTL_E2E_ESTAB   5            /* A new connection has been established using the sequence numbers included */
#define             PTL_E2E_NACK   6            /* The new connection establishment failed. */
#define       PTL_E2E_STATUS_REQ   7            /* Requests the current status of the target (receive) side of the connection for a given <SLID, DLID, TC> tuple. Generates a PTL_E2E_STATUS_RESP. */
#define      PTL_E2E_STATUS_RESP   8            /* Carries the current status of a connection for a given <SLID, DLID, TC> tuple, which includes the maximum sequence distance and current expected PSN for both the ordered and unordered channels. */
#define                    TBD_0   9            
#define                    TBD_1   9            
#define                    TBD_2   10           
#define                    TBD_3   11           
#define                    TBD_4   12           
#define                    TBD_5   13           
#define                    TBD_6   14           
#define                    TBD_7   15           
#define                    TBD_8   16           
#define                    TBD_9   17           
#define                   TBD_10   18           
#define                   TBD_11   19           
#define                   TBD_12   20           
#define                   TBD_13   21           
#define                   TBD_14   22           
#define                   TBD_15   23           
#define                   TBD_16   24           
#define                   TBD_17   25           
#define                   TBD_18   26           
#define                   TBD_19   27           
#define                   TBD_20   28           
#define                   TBD_21   29           
#define                   TBD_22   30            

#endif


/* Enumeration from Table titled: Encoding of the BECN Field (Enum - becn_t) - 1 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum becn {
         NO_BECN = 0,           /* No backward explicit congestion notification */
            BECN = 1            /* Backward explicit congestion notification */
};

#else

#define  NO_BECN   0            /* No backward explicit congestion notification */
#define     BECN   1             /* Backward explicit congestion notification */

#endif


/* Enumeration from Table titled: Encoding of the FECN Field (Enum - fecn_t) - 1 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum fecn {
         NO_FECN = 0,           /* No forward explicit congestion notification */
            FECN = 1            /* Forward explicit congestion notification */
};

#else

#define  NO_FECN   0            /* No forward explicit congestion notification */
#define     FECN   1             /* Forward explicit congestion notification */

#endif


/* Enumeration from Table titled: Encoding of the ACK_OPCODE Field (Enum - ack_op_t) - 4 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum ack_op {
                  PTL_E2E_NO_ACK = 0,           /* This packet does not include an E2E Ack. Maximum distance and expected PSN are not valid. */
                     PTL_E2E_ACK = 1,           /* This packet has an E2E acknowledgement for the specified packet. */
                PTL_E2E_NACK_OOS = 4,           /* A packet was received out-of-sequence. The most recently received sequence number is indicated in the ACK_PSN. */
         PTL_E2E_NACK_NOT_BOOTED = 5,           /* A packet was received, but the local node is not sufficiently initialized to accept it. */
                 PTL_E2E_NACK_NC = 6,           /* A packet was received, but the local sequence table indicates that the nodes are not connected for this traffic class. */
           PTL_E2E_NACK_RESOURCE = 7            /* A packet was received, but local resource exhaustion (e.g. resources for handling out-of-order packets) prevented accepting it. */
};

#else

#define           PTL_E2E_NO_ACK   0            /* This packet does not include an E2E Ack. Maximum distance and expected PSN are not valid. */
#define              PTL_E2E_ACK   1            /* This packet has an E2E acknowledgement for the specified packet. */
#define         PTL_E2E_NACK_OOS   4            /* A packet was received out-of-sequence. The most recently received sequence number is indicated in the ACK_PSN. */
#define  PTL_E2E_NACK_NOT_BOOTED   5            /* A packet was received, but the local node is not sufficiently initialized to accept it. */
#define          PTL_E2E_NACK_NC   6            /* A packet was received, but the local sequence table indicates that the nodes are not connected for this traffic class. */
#define    PTL_E2E_NACK_RESOURCE   7             /* A packet was received, but local resource exhaustion (e.g. resources for handling out-of-order packets) prevented accepting it. */

#endif


/* Enumeration from Table titled: Encoding of the Network Interface (NI) Field (Enum - ni_t) - 2 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum ni {
         PTL_NONMATCHING_LOGICAL = 0,           /* Non-matching, logically addressed */
        PTL_NONMATCHING_PHYSICAL = 1,           /* Non-matching, physically addressed */
            PTL_MATCHING_LOGICAL = 2,           /* Matching, logically addressed */
           PTL_MATCHING_PHYSICAL = 3            /* Matching, physically addressed */
};

#else

#define  PTL_NONMATCHING_LOGICAL   0            /* Non-matching, logically addressed */
#define PTL_NONMATCHING_PHYSICAL   1            /* Non-matching, physically addressed */
#define     PTL_MATCHING_LOGICAL   2            /* Matching, logically addressed */
#define    PTL_MATCHING_PHYSICAL   3             /* Matching, physically addressed */

#endif


/* Enumeration from Table titled: Encoding of the Acknowledgement Request (ACK_REQ) Field (Enum - ptl_ack_req_t) - 2 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum ptl_ack_req {
          PTL_NO_ACK_REQ = 0,           /* No Portals acknowledgement is requested */
          PTL_OC_ACK_REQ = 1,           /* An operation completed acknowledgement was requested */
          PTL_CT_ACK_REQ = 2,           /* A counting acknowledgement was requested */
             PTL_ACK_REQ = 3            /* A full acknowledgement was requested */
};

#else

#define   PTL_NO_ACK_REQ   0            /* No Portals acknowledgement is requested */
#define   PTL_OC_ACK_REQ   1            /* An operation completed acknowledgement was requested */
#define   PTL_CT_ACK_REQ   2            /* A counting acknowledgement was requested */
#define      PTL_ACK_REQ   3             /* A full acknowledgement was requested */

#endif


/* Enumeration from Table titled: Encoding of the List (LS) Field (Enum - ptl_list_t) - 1 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum ptl_list {
               PTL_PRIORITY_LIST = 0,           /* Indicates that the request matched the priority list */
               PTL_OVERFLOW_LIST = 1            /* Indicates that the request matched the overflow list */
};

#else

#define        PTL_PRIORITY_LIST   0            /* Indicates that the request matched the priority list */
#define        PTL_OVERFLOW_LIST   1             /* Indicates that the request matched the overflow list */

#endif


/* Enumeration from Table titled: Encoding of the Header Data (HD) Field (Enum - hd_t) - 1 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum hd {
           HDR_DATA_ZERO = 0,           /* Header data at the initiator was specified as zero */
        HDR_DATA_NONZERO = 1            /* Header data at the initiator contained a nonzero value */
};

#else

#define    HDR_DATA_ZERO   0            /* Header data at the initiator was specified as zero */
#define HDR_DATA_NONZERO   1             /* Header data at the initiator contained a nonzero value */

#endif


/* Enumeration from Table titled: Atomic DType Field (Enum - ptl_datatype_t) - 6 bits
*                        In File: 131_Portals_Transport_Layer.xml
*/
#if defined(__STDC__)

enum ptl_datatype {
                                    NONE = 0,           /* None */
                              PTL_INT8_T = 2,           /* 8 bit signed integer */
                             PTL_UINT8_T = 3,           /* 8 bit unsigned integer */
                             PTL_INT16_T = 4,           /* 16 bit signed integer */
                            PTL_UINT16_T = 5,           /* 16 bit unsigned integer */
                             PTL_INT32_T = 6,           /* 32 bit signed integer */
                            PTL_UINT32_T = 7,           /* 32 bit unsigned integer */
                             PTL_INT64_T = 8,           /* 64 bit signed integer */
                            PTL_UINT64_T = 9,           /* 64 bit unsigned integer */
                            PTL_INT128_T = 10,          /* 128 bit signed integer */
                           PTL_UINT128_T = 11,          /* 128 bit unsigned integer */
                               PTL_FLOAT = 16,          /* 32 bit floating-point (single precision, IEEE) */
                       PTL_FLOAT_COMPLEX = 17,          /* 32 bit complex floating-point (single precision, IEEE) */
                              PTL_DOUBLE = 18,          /* 64 bit floating-point (double precision, IEEE) */
                      PTL_DOUBLE_COMPLEX = 19,          /* 64 bit complex floating-point (double precision, IEEE) */
                      PTL_LONG_DOUBLE_96 = 20,          /* 96 bit floating-point (long double precision, IEEE) */
              PTL_LONG_DOUBLE_96_COMPLEX = 21,          /* 96 bit complex floating-point (long double precision, IEEE) */
                     PTL_LONG_DOUBLE_128 = 22,          /* 128 bit floating-point (long double precision, IEEE) */
             PTL_LONG_DOUBLE_128_COMPLEX = 23           /* 128 bit complex floating-point (long double precision, IEEE) */
};

#else

#define                             NONE   0            /* None */
#define                       PTL_INT8_T   2            /* 8 bit signed integer */
#define                      PTL_UINT8_T   3            /* 8 bit unsigned integer */
#define                      PTL_INT16_T   4            /* 16 bit signed integer */
#define                     PTL_UINT16_T   5            /* 16 bit unsigned integer */
#define                      PTL_INT32_T   6            /* 32 bit signed integer */
#define                     PTL_UINT32_T   7            /* 32 bit unsigned integer */
#define                      PTL_INT64_T   8            /* 64 bit signed integer */
#define                     PTL_UINT64_T   9            /* 64 bit unsigned integer */
#define                     PTL_INT128_T   10           /* 128 bit signed integer */
#define                    PTL_UINT128_T   11           /* 128 bit unsigned integer */
#define                        PTL_FLOAT   16           /* 32 bit floating-point (single precision, IEEE) */
#define                PTL_FLOAT_COMPLEX   17           /* 32 bit complex floating-point (single precision, IEEE) */
#define                       PTL_DOUBLE   18           /* 64 bit floating-point (double precision, IEEE) */
#define               PTL_DOUBLE_COMPLEX   19           /* 64 bit complex floating-point (double precision, IEEE) */
#define               PTL_LONG_DOUBLE_96   20           /* 96 bit floating-point (long double precision, IEEE) */
#define       PTL_LONG_DOUBLE_96_COMPLEX   21           /* 96 bit complex floating-point (long double precision, IEEE) */
#define              PTL_LONG_DOUBLE_128   22           /* 128 bit floating-point (long double precision, IEEE) */
#define      PTL_LONG_DOUBLE_128_COMPLEX   23            /* 128 bit complex floating-point (long double precision, IEEE) */

#endif


/* Enumeration from Table titled: Transmit Command Type (Enum - tx_ctype_t) - 4 bits
*                        In File: 200_Software_Interfaces.xml
*/
#if defined(__STDC__)

enum tx_ctype {
                     RTS = 0,           /* Portals Request to Send (RTS) for a Put, Atomic, or Get operation */
            RDV__REQUEST = 1,           /* Portals Basic Rendezvous Request (Put/Atomic/Get) */
               RDV_EVENT = 2,           /* Portals Basic Rendezvous Event */
                E2E_CTRL = 3,           /* Portals E2E Control */
           NonPortalsMsg = 6,           /* Generate one of the non-Portals message types */
            LocalCommand = 7,           /* Issue a command to the local HFI, including state modification and connection state control. */
                 REQUEST = 8,           /* Portals Basic Request (Put/Atomic/Get) */
        FETCHING_REQUEST = 9,           /* Portals Fetching Request (FetchAtomic/Two Operand Atomics) */
                Response = 10,          /* Portals Reply / Portal Full ACK */
              BASIC_ACK0 = 12,          /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=00b */
              BASIC_ACK1 = 13,          /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=01b */
              BASIC_ACK2 = 14,          /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=10b */
              BASIC_ACK3 = 15           /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=11b */
};

#else

#define              RTS   0            /* Portals Request to Send (RTS) for a Put, Atomic, or Get operation */
#define     RDV__REQUEST   1            /* Portals Basic Rendezvous Request (Put/Atomic/Get) */
#define        RDV_EVENT   2            /* Portals Basic Rendezvous Event */
#define         E2E_CTRL   3            /* Portals E2E Control */
#define    NonPortalsMsg   6            /* Generate one of the non-Portals message types */
#define     LocalCommand   7            /* Issue a command to the local HFI, including state modification and connection state control. */
#define          REQUEST   8            /* Portals Basic Request (Put/Atomic/Get) */
#define FETCHING_REQUEST   9            /* Portals Fetching Request (FetchAtomic/Two Operand Atomics) */
#define         Response   10           /* Portals Reply / Portal Full ACK */
#define       BASIC_ACK0   12           /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=00b */
#define       BASIC_ACK1   13           /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=01b */
#define       BASIC_ACK2   14           /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=10b */
#define       BASIC_ACK3   15            /* Portals E2E Basic ACK, pkt_hdr_id[15:14]=11b */

#endif


/* Enumeration from Table titled: Transmit Transfer Type (Enum - transfer_type_t) - 2bits
*                        In File: 200_Software_Interfaces.xml
*/
#if defined(__STDC__)

enum transfer_type {
        BUFFERED = 0,           /* Uses a buffered OMB entry to hold the payload */
             PIO = 1,           /* Uses programmed I/O to push the data, but uses DMA to retransmit it */
             DMA = 2,           /* Uses DMA to transfer the data */
         SPECIAL = 3            /* Uses the non-standard command format (e.g. the special high efficiency encoding for 8B transfers). May be specific to CType. */
};

#else

#define BUFFERED   0            /* Uses a buffered OMB entry to hold the payload */
#define      PIO   1            /* Uses programmed I/O to push the data, but uses DMA to retransmit it */
#define      DMA   2            /* Uses DMA to transfer the data */
#define  SPECIAL   3             /* Uses the non-standard command format (e.g. the special high efficiency encoding for 8B transfers). May be specific to CType. */

#endif


/* Enumeration from Table titled: Command Assignments for NonPortals Messages (Enum - nonptl_cmd_t) - 7 bits
*                        In File: 200_Software_Interfaces.xml
*/
#if defined(__STDC__)

enum nonptl_cmd {
             GENERAL_DMA = 0,           
             OFED_9B_DMA = 4,           /* 9B packet formats, no immediate data */
           OFED_9B_DMA_I = 5,           /* 9B packet formats, with immediate data, */
            OFED_16B_DMA = 8,           /* Reserved:16B packet formats, no immediate data */
          OFED_16B_DMA_I = 9,           /* Reserved:16B packet formats, with immediate data */
           PSM_EAGER_DMA = 16,          /* 9B packet formats, */
             PSM_TID_DMA = 20,          /* 9B packet formats */
                 PSM_PIO = 24           
};

#else

#define      GENERAL_DMA   0            
#define      OFED_9B_DMA   4            /* 9B packet formats, no immediate data */
#define    OFED_9B_DMA_I   5            /* 9B packet formats, with immediate data, */
#define     OFED_16B_DMA   8            /* Reserved:16B packet formats, no immediate data */
#define   OFED_16B_DMA_I   9            /* Reserved:16B packet formats, with immediate data */
#define    PSM_EAGER_DMA   16           /* 9B packet formats, */
#define      PSM_TID_DMA   20           /* 9B packet formats */
#define          PSM_PIO   24            

#endif


/* Enumeration from Table titled: Valid Type (Enum - flag_t) - 1 bits
*                        In File: 200_Software_Interfaces.xml
*/
#if defined(__STDC__)

enum flag {
               FXR_FALSE = 0,           /* boolean false */
                FXR_TRUE = 1            /* boolean true */
};

#else

#define        FXR_FALSE   0            /* boolean false */
#define         FXR_TRUE   1             /* boolean true */

#endif


/* Enumeration from Table titled: Receive CQ Command (Enum - rx_cq_cmd_t) - 12 bits
*                        In File: 200_Software_Interfaces.xml
*/
#if defined(__STDC__)

enum rx_cq_cmd {
                       PCB_WRITE = 0,           /* Write a PCB entry (needed for ordering/atomicity) */
                        PT_WRITE = 2,           /* Directly store a PT Entry (needed for User space access and ordering/atomicity). Also used to implement: PTE_FAST_PATH, PTE_NOT_FAST_PATH, PTE_ENABLE, and PTE_DISABLE. */
                   EQ_DESC_WRITE = 4,           /* Directly store an EQ Descriptor (needed for User space access and performance) */
                 APPEND_PRIORITY = 64,          /* Append and ME or LE (chosen by the NI) to the priority list. */
                 APPEND_OVERFLOW = 65,          /* Append and ME or LE (chosen by the NI) to the overflow list. */
                          SEARCH = 66,          /* Search the unexpected header list for matching items and return matches. */
                   SEARCH_DELETE = 67,          /* Search the unexpected header list for matching items, return matches, and delete them from the unexpected header list. */
                          UNLINK = 68,          /* Unlink the specified ME handle */
                TRIGGERED_APPEND = 69,          /* Insert a triggered operation . */
             ORDERED_TRIG_APPEND = 70,          /* Insert a triggered operation. This command variant is guaranteed to have a threshold larger than the threshold of the last item in the list (modulo 2^64) */
               TRIGGERED_DISABLE = 71,          /* Disable triggered valid bit on CT. */
                          CT_SET = 96,          /* Set the value of a counting event (needed to insure that the Triggered Operation Unit gets a copy of the update) */
                          CT_INC = 97,          /* Increment the value of a counting event by a specified amount (needed to insure that the Triggered Operation Unit gets a copy of the update) */
                      PD_CLEANUP = 128,         /* Cleanup state for a given PD instance. */
                    PD_DO_STUFF1 = 129,         /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
                    PD_DO_STUFF2 = 130,         /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
                    PD_DO_STUFF3 = 131,         /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
                    PD_DO_STUFF4 = 132,         /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
                    PD_DO_STUFF5 = 133,         /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
                    PD_DO_STUFF6 = 134,         /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
                    PD_DO_STUFF7 = 135          /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
};

#else

#define                PCB_WRITE   0            /* Write a PCB entry (needed for ordering/atomicity) */
#define                 PT_WRITE   2            /* Directly store a PT Entry (needed for User space access and ordering/atomicity). Also used to implement: PTE_FAST_PATH, PTE_NOT_FAST_PATH, PTE_ENABLE, and PTE_DISABLE. */
#define            EQ_DESC_WRITE   4            /* Directly store an EQ Descriptor (needed for User space access and performance) */
#define          APPEND_PRIORITY   64           /* Append and ME or LE (chosen by the NI) to the priority list. */
#define          APPEND_OVERFLOW   65           /* Append and ME or LE (chosen by the NI) to the overflow list. */
#define                   SEARCH   66           /* Search the unexpected header list for matching items and return matches. */
#define            SEARCH_DELETE   67           /* Search the unexpected header list for matching items, return matches, and delete them from the unexpected header list. */
#define                   UNLINK   68           /* Unlink the specified ME handle */
#define         TRIGGERED_APPEND   69           /* Insert a triggered operation . */
#define      ORDERED_TRIG_APPEND   70           /* Insert a triggered operation. This command variant is guaranteed to have a threshold larger than the threshold of the last item in the list (modulo 2^64) */
#define        TRIGGERED_DISABLE   71           /* Disable triggered valid bit on CT. */
#define                   CT_SET   96           /* Set the value of a counting event (needed to insure that the Triggered Operation Unit gets a copy of the update) */
#define                   CT_INC   97           /* Increment the value of a counting event by a specified amount (needed to insure that the Triggered Operation Unit gets a copy of the update) */
#define               PD_CLEANUP   128          /* Cleanup state for a given PD instance. */
#define             PD_DO_STUFF1   129          /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
#define             PD_DO_STUFF2   130          /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
#define             PD_DO_STUFF3   131          /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
#define             PD_DO_STUFF4   132          /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
#define             PD_DO_STUFF5   133          /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
#define             PD_DO_STUFF6   134          /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */
#define             PD_DO_STUFF7   135           /* Reserved opcode with unique firmware entry point to enable future hardware/software interaction expansion. Yes, this is the CYA opcode. */

#endif


/* Enumeration from Table titled: Receive Triggered Operation Target Queue (Enum - rx_tq_t) - 1 bit
*                        In File: 200_Software_Interfaces.xml
*/
#if defined(__STDC__)

enum rx_tq {
         TRIG_TX = 0,           /* Triggered operation command will go to the TX command queue. */
         TRIG_RX = 1            /* Triggered operation command will go to the RX command queue. */
};

#else

#define  TRIG_TX   0            /* Triggered operation command will go to the TX command queue. */
#define  TRIG_RX   1             /* Triggered operation command will go to the RX command queue. */

#endif


/* Enumeration from Table titled: Event Type (Enum - ptl_event_kind_t) - 6 bits
*                        In File: 200_Software_Interfaces.xml
*/
#if defined(__STDC__)

enum ptl_event_kind {
                           PTL_EVENT_GET = 0,           /* Data was 'pulled' from a local list entry as part of a 'get' operation. A get operation completed at the target . Portals will not read from memory on behalf of this operation once this event has been logged */
                  PTL_EVENT_GET_OVERFLOW = 1,           /* A list entry posted by PtlLEAppend() or PtlMEAppend() matched a get header in the unexpected list.  Data of length MLENGTH was 'pulled' from an entry in the overflow list as part of the get operation beginning at the Start address */
                           PTL_EVENT_PUT = 2,           /* A put matched a previously posted list entry. A put operation completed at the target . Portals will not alter memory on behalf of this operation once this event has been logged */
                  PTL_EVENT_PUT_OVERFLOW = 3,           /* A list entry posted by PtlLEAppend() or PtlMEAppend() matched a put header in the unexpected list. A put that previously arrived matched a new list entry. Data of length MLENGTH was deposited at the Start address. */
                        PTL_EVENT_ATOMIC = 4,           /* An atomic operation that does not return data to the initiator completed at the target . Portals will not read from or alter memory on behalf of this operation once this event has been logged. */
               PTL_EVENT_ATOMIC_OVERFLOW = 5,           /* A list entry posted by PtlLEAppend() or PtlMEAppend() matched an atomic header in the unexpected list for an operation which does not return data to the initiator. */
                  PTL_EVENT_FETCH_ATOMIC = 6,           /* An atomic operation that returns data to the initiator completed at the target . These include PtlFetchAtomic() and PtlSwap(). Portals will not read from or alter memory on behalf of this operation once this event has been logged. */
         PTL_EVENT_FETCH_ATOMIC_OVERFLOW = 7,           /* A list entry posted by PtlLEAppend() or PtlMEAppend() matched an atomic header in the unexpected list for an operation which returns data to the initiator */
                         PTL_EVENT_REPLY = 8,           /* A reply operation has completed at the initiator , either due to a get operation or an atomic which returned data to the initiator. This event is logged after the data (if any) from the reply has been written into the memory descriptor. Receipt of a PTL_EVENT_REPLY indicates remote completion of the operation. */
                          PTL_EVENT_SEND = 9,           /* A put or atomic has completed at the initiator . This event is logged after it is safe to reuse the buffer, but does not mean the message has been processed by the target. */
                           PTL_EVENT_ACK = 10,          /* An acknowledgment was received. This event is logged when the acknowledgment is received. Receipt of a PTL_EVENT_ACK indicates remote completion of the operation. Remote completion indicates that local completion has also occurred. */
                   PTL_EVENT_PT_DISABLED = 11,          /* Resources exhaustion has occurred on this portal table entry, which has entered a flow control situation. */
                   PTL_EVENT_AUTO_UNLINK = 12,          /* A list entry/match list entry was automatically unlinked. A PTL_EVENT_AUTO_UNLINK event is generated even if the list entry/match list entry passed into the PtlLEAppend()/PtlMEAppend() operation was marked with the PTL_LE_USE_ONCE/PTL_ME_USE_ONCE option and found a corresponding unexpected message before being 'linked' into the priority list. A PTL_EVENT_AUTO_UNLINK must be delivered after all PTL_EVENT_GET, PTL_EVENT_PUT, PTL_EVENT_ATOMIC, and PTL_EVENT_FETCH_ATOMIC events associated with the list entry/match list entry have been delivered. */
                     PTL_EVENT_AUTO_FREE = 13,          /* A list entry/match list entry previously automatically unlinked from the overflow list is now free to be reused by the application. A PTL_EVENT_AUTO_FREE event is generated when Portals will not generate any further events which resulted from messages delivered into the specified overflow list entry. This also indicates that the unexpected list contains no more items associated with this entry. A list entry/match list entry which disabled unexpected headers will not generate this event, even if placed in the overflow list. */
                        PTL_EVENT_SEARCH = 14,          /* A PtlLESearch() or PtlMESearch() call completed. If a matching message was found in the overflow list, PTL_NI_OK is returned in the ni_fail_type field of the event and the event queue entries are filled in as if it were an overflow event. Otherwise, a failure is recorded in the ni_fail_type field using PTL_NI_NO_MATCH, the user_ptr is filled in correctly, and the other fields are undefined. */
                          PTL_EVENT_LINK = 15,          /* A list entry posted by PtlLEAppend() or PtlMEAppend() has successfully linked into the specified list */
                         PTL_EVENT_ERROR = 16           /* An error occurred that is not specified or cannot return all of the required fields in a valid error type. PTL_EVENT_ERROR is intended to be used in cases where unspecified errors may e deductible and recoverable by the application. For example, file systems may be able to recover from errors that cannot be fully described by the Portals implementation. */
};

#else

#define                    PTL_EVENT_GET   0            /* Data was 'pulled' from a local list entry as part of a 'get' operation. A get operation completed at the target . Portals will not read from memory on behalf of this operation once this event has been logged */
#define           PTL_EVENT_GET_OVERFLOW   1            /* A list entry posted by PtlLEAppend() or PtlMEAppend() matched a get header in the unexpected list.  Data of length MLENGTH was 'pulled' from an entry in the overflow list as part of the get operation beginning at the Start address */
#define                    PTL_EVENT_PUT   2            /* A put matched a previously posted list entry. A put operation completed at the target . Portals will not alter memory on behalf of this operation once this event has been logged */
#define           PTL_EVENT_PUT_OVERFLOW   3            /* A list entry posted by PtlLEAppend() or PtlMEAppend() matched a put header in the unexpected list. A put that previously arrived matched a new list entry. Data of length MLENGTH was deposited at the Start address. */
#define                 PTL_EVENT_ATOMIC   4            /* An atomic operation that does not return data to the initiator completed at the target . Portals will not read from or alter memory on behalf of this operation once this event has been logged. */
#define        PTL_EVENT_ATOMIC_OVERFLOW   5            /* A list entry posted by PtlLEAppend() or PtlMEAppend() matched an atomic header in the unexpected list for an operation which does not return data to the initiator. */
#define           PTL_EVENT_FETCH_ATOMIC   6            /* An atomic operation that returns data to the initiator completed at the target . These include PtlFetchAtomic() and PtlSwap(). Portals will not read from or alter memory on behalf of this operation once this event has been logged. */
#define  PTL_EVENT_FETCH_ATOMIC_OVERFLOW   7            /* A list entry posted by PtlLEAppend() or PtlMEAppend() matched an atomic header in the unexpected list for an operation which returns data to the initiator */
#define                  PTL_EVENT_REPLY   8            /* A reply operation has completed at the initiator , either due to a get operation or an atomic which returned data to the initiator. This event is logged after the data (if any) from the reply has been written into the memory descriptor. Receipt of a PTL_EVENT_REPLY indicates remote completion of the operation. */
#define                   PTL_EVENT_SEND   9            /* A put or atomic has completed at the initiator . This event is logged after it is safe to reuse the buffer, but does not mean the message has been processed by the target. */
#define                    PTL_EVENT_ACK   10           /* An acknowledgment was received. This event is logged when the acknowledgment is received. Receipt of a PTL_EVENT_ACK indicates remote completion of the operation. Remote completion indicates that local completion has also occurred. */
#define            PTL_EVENT_PT_DISABLED   11           /* Resources exhaustion has occurred on this portal table entry, which has entered a flow control situation. */
#define            PTL_EVENT_AUTO_UNLINK   12           /* A list entry/match list entry was automatically unlinked. A PTL_EVENT_AUTO_UNLINK event is generated even if the list entry/match list entry passed into the PtlLEAppend()/PtlMEAppend() operation was marked with the PTL_LE_USE_ONCE/PTL_ME_USE_ONCE option and found a corresponding unexpected message before being 'linked' into the priority list. A PTL_EVENT_AUTO_UNLINK must be delivered after all PTL_EVENT_GET, PTL_EVENT_PUT, PTL_EVENT_ATOMIC, and PTL_EVENT_FETCH_ATOMIC events associated with the list entry/match list entry have been delivered. */
#define              PTL_EVENT_AUTO_FREE   13           /* A list entry/match list entry previously automatically unlinked from the overflow list is now free to be reused by the application. A PTL_EVENT_AUTO_FREE event is generated when Portals will not generate any further events which resulted from messages delivered into the specified overflow list entry. This also indicates that the unexpected list contains no more items associated with this entry. A list entry/match list entry which disabled unexpected headers will not generate this event, even if placed in the overflow list. */
#define                 PTL_EVENT_SEARCH   14           /* A PtlLESearch() or PtlMESearch() call completed. If a matching message was found in the overflow list, PTL_NI_OK is returned in the ni_fail_type field of the event and the event queue entries are filled in as if it were an overflow event. Otherwise, a failure is recorded in the ni_fail_type field using PTL_NI_NO_MATCH, the user_ptr is filled in correctly, and the other fields are undefined. */
#define                   PTL_EVENT_LINK   15           /* A list entry posted by PtlLEAppend() or PtlMEAppend() has successfully linked into the specified list */
#define                  PTL_EVENT_ERROR   16            /* An error occurred that is not specified or cannot return all of the required fields in a valid error type. PTL_EVENT_ERROR is intended to be used in cases where unspecified errors may e deductible and recoverable by the application. For example, file systems may be able to recover from errors that cannot be fully described by the Portals implementation. */

#endif


/* Enumeration from Table titled: Event Type (Enum - ptl_ni_fail_t) - 6 bits
*                        In File: 200_Software_Interfaces.xml
*/
#if defined(__STDC__)

enum ptl_ni_fail {
                       PTL_NI_OK = 0,           /* The operation causing the event was successful */
            PTL_NI_UNDELIVERABLE = 1,           /* Indicates a system failure that prevents message delivery */
                  PTL_NI_DROPPED = 2,           /* Indicates that the message associated with this full event was dropped at the target for reasons other than a disabled portal table entry. This failure type should only be returned on initiator events. */
           PTL_NI_INVALID_TARGET = 8,           /* Indicates that the message associated with this full event was dropped at the target because either the PID or PT Index was invalid. This failure type should only be returned on initiator events. */
              PTL_NI_PT_DISABLED = 9,           /* Indicates that the portal table entry at the target was disabled and did not process the operation, either because the entry was disabled with PtlPTDisable() or because the entry provides flow control and a resource has been exhausted. This failure type should only be returned on initiator events. */
           PTL_NI_PERM_VIOLATION = 10,          /* Indicates that the remote Portals addressing has indicated a permissions violation for the operation that caused this event. This failure type should only be returned on initiator events. */
             PTL_NI_OP_VIOLATION = 11,          /* Indicates that the remote Portals addressing has indicated an operation violation for the operation that caused this event. This failure type should only be returned on initiator events. */
                     PTL_NI_SEGV = 12,          /* Indicates that the message associated with this full event was dropped at the target because it would have caused a segmentation fault. */
                 PTL_NI_NO_MATCH = 13,          /* On a PTL_EVENT_SEARCH, this indicates that a match was not found. */
                PTL_NI_CANCELLED = 14,          /* Indicates that the event is the result of canceling a message. */
              PTL_NI_UNSUPPORTED = 15           /* An unsupported operation was attempted. This is delivered at the initiator when a PTL_NACK_UNSUPPORTED is received or an unsupported operation is detected locally and prevented. */
};

#else

#define                PTL_NI_OK   0            /* The operation causing the event was successful */
#define     PTL_NI_UNDELIVERABLE   1            /* Indicates a system failure that prevents message delivery */
#define           PTL_NI_DROPPED   2            /* Indicates that the message associated with this full event was dropped at the target for reasons other than a disabled portal table entry. This failure type should only be returned on initiator events. */
#define    PTL_NI_INVALID_TARGET   8            /* Indicates that the message associated with this full event was dropped at the target because either the PID or PT Index was invalid. This failure type should only be returned on initiator events. */
#define       PTL_NI_PT_DISABLED   9            /* Indicates that the portal table entry at the target was disabled and did not process the operation, either because the entry was disabled with PtlPTDisable() or because the entry provides flow control and a resource has been exhausted. This failure type should only be returned on initiator events. */
#define    PTL_NI_PERM_VIOLATION   10           /* Indicates that the remote Portals addressing has indicated a permissions violation for the operation that caused this event. This failure type should only be returned on initiator events. */
#define      PTL_NI_OP_VIOLATION   11           /* Indicates that the remote Portals addressing has indicated an operation violation for the operation that caused this event. This failure type should only be returned on initiator events. */
#define              PTL_NI_SEGV   12           /* Indicates that the message associated with this full event was dropped at the target because it would have caused a segmentation fault. */
#define          PTL_NI_NO_MATCH   13           /* On a PTL_EVENT_SEARCH, this indicates that a match was not found. */
#define         PTL_NI_CANCELLED   14           /* Indicates that the event is the result of canceling a message. */
#define       PTL_NI_UNSUPPORTED   15            /* An unsupported operation was attempted. This is delivered at the initiator when a PTL_NACK_UNSUPPORTED is received or an unsupported operation is detected locally and prevented. */

#endif


/* Enumeration from Table titled: Atomic Operation Encoding (Enum - ptl_op_t) - 5 bits
*                        In File: 200_Software_Interfaces.xml
*/
#if defined(__STDC__)

enum ptl_op {
                PTL_SWAP = 0,           
                 PTL_MIN = 4,           
                 PTL_MAX = 5,           
                 PTL_SUM = 6,           
                PTL_DIFF = 7,           
                PTL_PROD = 8,           
                 PTL_LOR = 9,           
                PTL_LAND = 10,          
                PTL_LXOR = 11,          
                 PTL_BOR = 12,          
                PTL_BAND = 13,          
                PTL_BXOR = 14,          
               PTL_CSWAP = 17,          
            PTL_CSWAP_NE = 18,          
            PTL_CSWAP_LE = 19,          
            PTL_CSWAP_LT = 20,          
            PTL_CSWAP_GE = 21,          
            PTL_CSWAP_GT = 22,          
               PTL_MSWAP = 23           
};

#else

#define         PTL_SWAP   0            
#define          PTL_MIN   4            
#define          PTL_MAX   5            
#define          PTL_SUM   6            
#define         PTL_DIFF   7            
#define         PTL_PROD   8            
#define          PTL_LOR   9            
#define         PTL_LAND   10           
#define         PTL_LXOR   11           
#define          PTL_BOR   12           
#define         PTL_BAND   13           
#define         PTL_BXOR   14           
#define        PTL_CSWAP   17           
#define     PTL_CSWAP_NE   18           
#define     PTL_CSWAP_LE   19           
#define     PTL_CSWAP_LT   20           
#define     PTL_CSWAP_GE   21           
#define     PTL_CSWAP_GT   22           
#define        PTL_MSWAP   23            

#endif


/* Enumeration from Table titled: Portals Status Registers (Enum - ptl_sr_index_t) - 4bits
*                        In File: 200_Software_Interfaces.xml
*/
#if defined(__STDC__)

enum ptl_sr_index {
                       PTL_SR_DROP_COUNT = 0,           /* The count of all dropped requests (Portals messages / RTS) to the interface. */
            PTL_SR_PERMISSION_VIOLATIONS = 1,           /* The count of all attempted permission violations. */
             PTL_SR_OPERATION_VIOLATIONS = 2,           /* The count of all attempted operation violations. */
             PTL_SR_MAX_RETRANSMIT_LIMIT = 3            /* The count of all of the messages that have failed due to one or more packets reaching a retransmit limit. */
};

#else

#define                PTL_SR_DROP_COUNT   0            /* The count of all dropped requests (Portals messages / RTS) to the interface. */
#define     PTL_SR_PERMISSION_VIOLATIONS   1            /* The count of all attempted permission violations. */
#define      PTL_SR_OPERATION_VIOLATIONS   2            /* The count of all attempted operation violations. */
#define      PTL_SR_MAX_RETRANSMIT_LIMIT   3             /* The count of all of the messages that have failed due to one or more packets reaching a retransmit limit. */

#endif


/* Enumeration from Table titled: Buffer State (Enum - rend_buff_state_t) - 3 bits
*                        In File: 140_OutstandingRequest_and_Reliability.xml
*/
#if defined(__STDC__)

enum rend_buff_state {
                RTS_SENT = 0,           /* An RTS has been sent for this message. */
                 OMB_ACK = 1,           /* The RTS has been acknowledged, but a CTS has not been received. The OPB entry was freed. The RTS will not be retransmitted. Cleaning of OMB entries in the ACK state will be required. */
              CTS_NO_ACK = 2,           /* A CTS has been received for this message, but an acknowledgement was not included. The message will not retransmit an RTS, but it must not be freed until the acknowledgement has been received or the OPB entry for the OMB entry has timed out. */
                 CTS_ACK = 3,           /* A CTS with a piggybacked acknowledgement has been received for this message. */
             ECTS_NO_ACK = 4,           /* An ECTS has been received for this message, but an acknowledgement was not included. See CTS_NO_ACK. */
                ECTS_ACK = 5,           /* An ECTS with a piggybacked acknowledgement has been received for this message. */
              EVENT_SENT = 6            /* The final event message for an ECTS flow has been sent and is awaiting acknowledgement. */
};

#else

#define         RTS_SENT   0            /* An RTS has been sent for this message. */
#define          OMB_ACK   1            /* The RTS has been acknowledged, but a CTS has not been received. The OPB entry was freed. The RTS will not be retransmitted. Cleaning of OMB entries in the ACK state will be required. */
#define       CTS_NO_ACK   2            /* A CTS has been received for this message, but an acknowledgement was not included. The message will not retransmit an RTS, but it must not be freed until the acknowledgement has been received or the OPB entry for the OMB entry has timed out. */
#define          CTS_ACK   3            /* A CTS with a piggybacked acknowledgement has been received for this message. */
#define      ECTS_NO_ACK   4            /* An ECTS has been received for this message, but an acknowledgement was not included. See CTS_NO_ACK. */
#define         ECTS_ACK   5            /* An ECTS with a piggybacked acknowledgement has been received for this message. */
#define       EVENT_SENT   6             /* The final event message for an ECTS flow has been sent and is awaiting acknowledgement. */

#endif


/* Enumeration from Table titled: OMB Entry Type (Enum - omb_entry_type_t) - 1 bits
*                        In File: 140_OutstandingRequest_and_Reliability.xml
*/
#if defined(__STDC__)

enum omb_entry_type {
                MSG_DESC = 0,           /* Entry holds a message descriptor */
               DATA_DESC = 1            /* Entry holds a data descriptor */
};

#else

#define         MSG_DESC   0            /* Entry holds a message descriptor */
#define        DATA_DESC   1             /* Entry holds a data descriptor */

#endif


/* Enumeration from Table titled: Privilege Level (Enum - priv_t) - 1 bits
*                        In File: 140_OutstandingRequest_and_Reliability.xml
*/
#if defined(__STDC__)

enum priv {
          KERNEL = 0,           /* Privilege level zero (kernel / ring 0 level of privilege) */
            USER = 1            /* Privilege level one (ring 3 / user level of privilege) */
};

#else

#define   KERNEL   0            /* Privilege level zero (kernel / ring 0 level of privilege) */
#define     USER   1             /* Privilege level one (ring 3 / user level of privilege) */

#endif


/* Enumeration from Table titled: OPB Buffer State (Enum - opb_buff_state_t) - 3 bits
*                        In File: 140_OutstandingRequest_and_Reliability.xml
*/
#if defined(__STDC__)

enum opb_buff_state {
                     PACKET_SENT = 0,           /* A packet has been sent */
                    ACK_RECEIVED = 1,           /* Packet has been acknowledged, but has not received the response that is required. Packet will not be retransmitted, but OPB entry is subject to harvesting if the peer node goes away. */
               RESPONSE_RECEIVED = 2,           /* The response has been received (and processed), but the E2E acknowledgement has not. */
                         PENDING = 3,           /* Packet has been queued for later transmit (e.g. retransmit) */
                 ACK_CMD_PENDING = 4,           /* An OPB entry has seen a response (e.g. Reply to a Get) and is waiting for an acknowledgement to propagate through the pipeline. */
              ACK_CMD_PENDING_NA = 5,           /* An OPB entry has seen a response (e.g. Reply to a Get) and is waiting for an acknowledgement to propagate through the pipeline, but the E2E ack has not been received yet. */
                     ACK_PENDING = 6,           /* OPB entry may be used to hold a pending acknowledgement. Entry is held until acknowledgement is issued into the correct MC/TC into the DMA engine. */
                  ACK_PENDING_NA = 7            /* OPB entry may be used to hold a pending acknowledgement. Entry is held until acknowledgement is issued into the correct MC/TC into the DMA engine and a protocol acknowledgement is received. */
};

#else

#define              PACKET_SENT   0            /* A packet has been sent */
#define             ACK_RECEIVED   1            /* Packet has been acknowledged, but has not received the response that is required. Packet will not be retransmitted, but OPB entry is subject to harvesting if the peer node goes away. */
#define        RESPONSE_RECEIVED   2            /* The response has been received (and processed), but the E2E acknowledgement has not. */
#define                  PENDING   3            /* Packet has been queued for later transmit (e.g. retransmit) */
#define          ACK_CMD_PENDING   4            /* An OPB entry has seen a response (e.g. Reply to a Get) and is waiting for an acknowledgement to propagate through the pipeline. */
#define       ACK_CMD_PENDING_NA   5            /* An OPB entry has seen a response (e.g. Reply to a Get) and is waiting for an acknowledgement to propagate through the pipeline, but the E2E ack has not been received yet. */
#define              ACK_PENDING   6            /* OPB entry may be used to hold a pending acknowledgement. Entry is held until acknowledgement is issued into the correct MC/TC into the DMA engine. */
#define           ACK_PENDING_NA   7             /* OPB entry may be used to hold a pending acknowledgement. Entry is held until acknowledgement is issued into the correct MC/TC into the DMA engine and a protocol acknowledgement is received. */

#endif


/* Enumeration from Table titled: Transmit Protocol Control Field (Enum - tx_proto_ctrl_t) - 4 bits
*                        In File: 140_OutstandingRequest_and_Reliability.xml
*/
#if defined(__STDC__)

enum tx_proto_ctrl {
          TX_UNCONNECTED = 0,           /* The transmit protocol state is always initialized to unconnected. */
            TX_CONNECTED = 1,           
           TX_CONNECTING = 2            
};

#else

#define   TX_UNCONNECTED   0            /* The transmit protocol state is always initialized to unconnected. */
#define     TX_CONNECTED   1            
#define    TX_CONNECTING   2             

#endif



#endif 		/* DEF_FXR_SW_SW_DEF */
