//                                                                             
// File:       fxr_rx_dma_csrs.h                                               
// Creator:    pvesvslx                                                        
// Time:       Friday Apr 25, 2014 [1:12:44 pm]                                
//                                                                             
// Path:       /tmp/pvesvslx/nebulon_run/12747                                 
// Arguments:  /p/com/eda/denali/blueprint/3.7.4/Linux/blueprint -chdr -I      
//             /p/slx/eda/intel/nebulon/2.05_fdo/include -I                    
//             /p/slx/pvesv/fxr_autogen/fxr -xml fxr_rx_dma.rdl                
//                                                                             
// Sources:    /tmp/pvesvslx/nebulon_run/12747/fxr_rx_dma.rdl                  
//             /tmp/pvesvslx/nebulon_run/12747/fxr_rx_dma.rdlh                 
//             /tmp/pvesvslx/nebulon_run/12747/lib_udp.rdl                     
//             /p/com/eda/intel/nebulon/2.05p1/generators/generator_common.pm  
//             /p/com/eda/intel/nebulon/2.05p1/generators/xml.pm               
//             /p/com/eda/intel/nebulon/2.05p1/generators/walk_through.pm      
//             /p/com/eda/intel/nebulon/2.05p1/generators/chdr.pm              
//                                                                             
// Blueprint:   3.7.4 (Tue Jun 23 00:17:01 PDT 2009)                           
// Machine:    scci56220                                                       
// OS:         Linux 2.6.16.60-0.58.1.3835.0.PTF.638363-smp                    
// Description:                                                                
//                                                                             
//Receive DMA address map                                                      
//                                                                             
// Copyright (C) 2014 Denali Software Inc.  All rights reserved                
// THIS FILE IS AUTOMATICALLY GENERATED BY DENALI BLUEPRINT, DO NOT EDIT       
//                                                                             



// RX_DMA_CFG_BUFFER desc:  This is an RX DMA configuration CSR. It allows adjusting the depth
// and initialization method of the DMA buffers.
typedef volatile union {
    struct {
        uint64_t  disable_auto_init    :   1;    //  Disable the automatic
                                                 // initialization of the linked
                                                 // list. Software initialization
                                                 // is required if disabled.
        uint64_t  depth_limit          :   8;    //  Limit the depth of the linked
                                                 // lists, along with the depth of
                                                 // the buffer used.
        uint64_t  RSVD_0               :  55;    // Nebulon auto filled RSVD [63:9]

    };
    uint64_t                         val;
} RX_DMA_CFG_BUFFER_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_LINKED_LIST desc:  This is an RX DMA debug CSR. It allows access to all of the linked
// list DMA queue arrays. These arrays can not be written to during
// normal operation. This register is for debug use, and for
// initialization of the linked list if needed. There is an automatic
// initialization function built in that can be disabled.
typedef volatile union {
    struct {
        uint64_t  data                 :   8;    //  Data to be written, or data
                                                 // read from access
        uint64_t  parity               :   1;    //  Parity for data being
                                                 // written, or parity read from
                                                 // access
        uint64_t  Reserved_63_9        :  55;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_LINKED_LIST_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_TAIL_LIST desc:  This is an RX DMA debug CSR. It allows access to all of the Tail
// list. These arrays can not be written to during normal operation.
// This register is for debug use only.
typedef volatile union {
    struct {
        uint64_t  full                 :   1;    //  1=tail location contains 64
                                                 // bytes, 0=tail location
                                                 // contains 32 bytes.
        uint64_t  tail                 :   8;    //  Tail pointer for the head
                                                 // location accessed.
        uint64_t  parity               :   1;    //  Parity for data being
                                                 // written, or parity read from
                                                 // access
        uint64_t  Reserved_63_10       :  54;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_TAIL_LIST_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_HEAD_LIST desc:  This is an RX DMA debug CSR. It allows access to all of the Head
// list. These arrays can not be written to during normal operation.
// This register is for debug use only.
typedef volatile union {
    struct {
        uint64_t  byte_cnt             :   6;    //  Bytes already access in the
                                                 // new_head location. Up to 63.
        uint64_t  new_head             :   8;    //  The pointer to the head of
                                                 // the un-accessed part of the
                                                 // packet.
        uint64_t  parity               :   1;    //  Parity for data being
                                                 // written, or parity read from
                                                 // access
        uint64_t  Reserved_63_15       :  49;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_HEAD_LIST_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_ADDR desc:  This is an RX DMA debug CSR. It allows indirect access to all of the
// DMA buffer arrays. These arrays can not be written to during normal
// operation. This register is for debug use only. Note that this
// register is 288 bits wide. The data for the read or write to this
// register is contained in the next five CSR's
typedef volatile union {
    struct {
        uint64_t  address              :   9;    //  Address of DMA Buffer
                                                 // location to be accessed
        uint64_t  mctc                 :   4;    //  Message Class and Traffic
                                                 // Class being accessed
        uint64_t  write_cmd            :   1;    //  Write = 1, Read = 0.
        uint64_t  Reserved_15_14       :   2;    // 
        uint64_t  cmd_complete         :   1;    //  Set to one after a completed
                                                 // access
        uint64_t  new_cmd              :   1;    //  Indicated the command in this
                                                 // CSR is ready for hardware.
        uint64_t  Reserved_63_18       :  46;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_ADDR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_DATA0 desc:  This is an RX DMA debug CSR. This is the data for bits [63:0] of the
// RX DMA buffer being accessed with the RX_DMA_DBG_BUFFER_ADDR
// register. The data from this CSR is written to the DMA buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_DATA0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_DATA1 desc:  This is an RX DMA debug CSR. This is the data for bits [127:64] of
// the RX DMA buffer being accessed with the RX_DMA_DBG_BUFFER_ADDR
// register. The data from this CSR is written to the DMA buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_DATA1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_DATA2 desc:  This is an RX DMA debug CSR. This is the data for bits [191:128] of
// the RX DMA buffer being accessed with the RX_DMA_DBG_BUFFER_ADDR
// register. The data from this CSR is written to the DMA buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_DATA2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_DATA3 desc:  This is an RX DMA debug CSR. This is the data for bits [255:192] of
// the RX DMA buffer being accessed with the RX_DMA_DBG_BUFFER_ADDR
// register. The data from this CSR is written to the DMA buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_DATA3_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_DATA4 desc:  This is an RX DMA debug CSR. This is the data for bits [287:256] of
// the RX DMA buffer being accessed with the RX_DMA_DBG_BUFFER_ADDR
// register. The data from this CSR is written to the DMA buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active. This data is the ECC codes for
// the stored data in the buffer.
typedef volatile union {
    struct {
        uint64_t  Data                 :  32;    // 
        uint64_t  Reserved_63_32       :  32;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_DATA4_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_AT_ARRAY_ADDR desc:  This is an RX DMA debug CSR. It allows indirect access to all of the
// RX DMA Translation Array. This array can not be written to during
// normal operation. This register is for debug use only. Note that this
// register is 128 bits wide. The data for the read or write to this
// register is contained in the next two CSR's
typedef volatile union {
    struct {
        uint64_t  address              :   7;    //  Address of Translation Buffer
                                                 // location to be accessed
        uint64_t  mctc                 :   4;    //  Message Class and Traffic
                                                 // Class being accessed
        uint64_t  write_cmd            :   1;    //  Write = 1, Read = 0.
        uint64_t  Reserved_15_12       :   4;    // 
        uint64_t  cmd_complete         :   1;    //  Set to one after a completed
                                                 // access
        uint64_t  new_cmd              :   1;    //  Indicated the command in this
                                                 // CSR is ready for hardware.
        uint64_t  Reserved_63_18       :  46;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_AT_ARRAY_ADDR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_AT_ARRAY_DATA0 desc:  This is an RX DMA debug CSR. This is the data for bits [63:0] of the
// RX DMA Translation buffer being accessed with the
// RX_DMA_DBG_AT_ARRAY_ADDR register. The data from this CSR is written
// to the AT Array if the write bit is active in that CSR, or this data
// will contain the read data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_AT_ARRAY_DATA0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_AT_ARRAY_DATA1 desc:  This is an RX DMA debug CSR. This is the data for bits [127:64] of
// the RX DMA Translation buffer being accessed with the
// RX_DMA_DBG_AT_ARRAY_ADDR register. The data from this CSR is written
// to the AT Array if the write bit is active in that CSR, or this data
// will contain the read data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_AT_ARRAY_DATA1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_WAR_BUF desc:  This is an RX DMA debug CSR. It allows access to the WARRead Buffer.
// This array can not be written to during normal operation. This
// register is for debug use only.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  Data read or to be written to
                                                 // the WAR Read Buffer.

    };
    uint64_t                         val;
} RX_DMA_DBG_WAR_BUF_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_ERR_BUF_MBE desc:  MBE error counts from the DMA buffers in each Message Class. All
// errors from a single message class are accumulated into one register.
typedef volatile union {
    struct {
        uint64_t  syndrome             :   8;    //  Syndrome of last MBE
        uint64_t  address              :   9;    //  Address of last MBE
        uint64_t  qword                :   2;    //  QWord position of last MBE
        uint64_t  tc                   :   2;    //  Traffic class of last MBE
        uint64_t  mbe_cnt              :   8;    //  Saturating counter of MBE's
                                                 // from all sources
        uint64_t  Reserved_63_29       :  35;    //  Reserved

    };
    uint64_t                         val;
} RX_DMA_ERR_BUF_MBE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_ERR_LL_PARITY desc:  Parity error counts from the RX DMA Linked List arrays in each
// Message Class. All errors from a single message class are accumulated
// into one register.
typedef volatile union {
    struct {
        uint64_t  tc0_parity           :   1;    //  Parity error found in Linked
                                                 // List of TC0
        uint64_t  address_tc0          :   8;    //  Address of last Linked List
                                                 // Parity Error in TC0
        uint64_t  tc1_parity           :   1;    //  Parity error found in Linked
                                                 // List of TC1
        uint64_t  address_tc1          :   8;    //  Address of last Linked List
                                                 // Parity Error in TC1
        uint64_t  tc2_parity           :   1;    //  Parity error found in Linked
                                                 // List of TC2
        uint64_t  address_tc2          :   8;    //  Address of last Linked List
                                                 // Parity Error in TC2
        uint64_t  tc3_parity           :   1;    //  Parity error found in Linked
                                                 // List of TC3
        uint64_t  address_tc3          :   8;    //  Address of last Linked List
                                                 // Parity Error in TC3
        uint64_t  error_cnt            :   8;    //  Saturating counter of parity
                                                 // errors from all sources
        uint64_t  Reserved_63_44       :  20;    //  Reserved

    };
    uint64_t                         val;
} RX_DMA_ERR_LL_PARITY_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_ERR_TAIL_PARITY desc:  Parity error counts from the RX DMA Tail List arrays in each Message
// Class. All errors from a single message class are accumulated into
// one register.
typedef volatile union {
    struct {
        uint64_t  tc0_parity           :   1;    //  Parity error found in Tail
                                                 // Array of TC0
        uint64_t  address_tc0          :   8;    //  Address of last Tail Array
                                                 // Parity Error in TC0
        uint64_t  tc1_parity           :   1;    //  Parity error found in Tail
                                                 // Array of TC1
        uint64_t  address_tc1          :   8;    //  Address of last Tail Array
                                                 // Parity Error in TC1
        uint64_t  tc2_parity           :   1;    //  Parity error found in Tail
                                                 // Array of TC2
        uint64_t  address_tc2          :   8;    //  Address of last Tail Array
                                                 // Parity Error in TC2
        uint64_t  tc3_parity           :   1;    //  Parity error found in Tail
                                                 // Array of TC3
        uint64_t  address_tc3          :   8;    //  Address of last Tail Array
                                                 // Parity Error in TC3
        uint64_t  error_cnt            :   8;    //  Saturating counter of parity
                                                 // errors from all sources
        uint64_t  Reserved_63_44       :  20;    //  Reserved

    };
    uint64_t                         val;
} RX_DMA_ERR_TAIL_PARITY_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_ERR_HEAD_PARITY desc:  Parity error counts from the RX DMA Head List arrays in each Message
// Class. All errors from a single message class are accumulated into
// one register.
typedef volatile union {
    struct {
        uint64_t  tc0_parity           :   1;    //  Parity error found in Head
                                                 // Array of TC0
        uint64_t  address_tc0          :   8;    //  Address of last Head Array
                                                 // Parity Error in TC0
        uint64_t  tc1_parity           :   1;    //  Parity error found in Head
                                                 // Array of TC1
        uint64_t  address_tc1          :   8;    //  Address of last Head Array
                                                 // Parity Error in TC1
        uint64_t  tc2_parity           :   1;    //  Parity error found in Head
                                                 // Array of TC2
        uint64_t  address_tc2          :   8;    //  Address of last Head Array
                                                 // Parity Error in TC2
        uint64_t  tc3_parity           :   1;    //  Parity error found in Head
                                                 // Array of TC3
        uint64_t  address_tc3          :   8;    //  Address of last Head Array
                                                 // Parity Error in TC3
        uint64_t  error_cnt            :   8;    //  Saturating counter of parity
                                                 // errors from all sources
        uint64_t  Reserved_63_44       :  20;    //  Reserved

    };
    uint64_t                         val;
} RX_DMA_ERR_HEAD_PARITY_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_ERR_AT_ARRAY_PARITY desc:  Parity error counts from the RX DMA Translation array.
typedef volatile union {
    struct {
        uint64_t  tc0_parity           :   1;    //  Parity error found in Head
                                                 // Array of TC0
        uint64_t  address              :   7;    //  Address of last Translation
                                                 // Array Parity Error in TC0
        uint64_t  Reserved_63_8        :  56;    //  Reserved

    };
    uint64_t                         val;
} RX_DMA_ERR_AT_ARRAY_PARITY_t;

// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    RX_DMA_CFG_BUFFER_t        RX_DMA_CFG_BUFFER[8]; // offset 4'h0, width 64
    RX_DMA_DBG_LINKED_LIST_t   RX_DMA_DBG_LINKED_LIST[256]; // offset 8'h40, width 64
    RX_DMA_DBG_TAIL_LIST_t     RX_DMA_DBG_TAIL_LIST[256]; // offset 12'h840, width 64
    RX_DMA_DBG_HEAD_LIST_t     RX_DMA_DBG_HEAD_LIST[256]; // offset 16'h1040, width 64
    RX_DMA_DBG_BUFFER_ADDR_t   RX_DMA_DBG_BUFFER_ADDR; // offset 16'h1840, width 64
    RX_DMA_DBG_BUFFER_DATA0_t  RX_DMA_DBG_BUFFER_DATA0; // offset 16'h1848, width 64
    RX_DMA_DBG_BUFFER_DATA1_t  RX_DMA_DBG_BUFFER_DATA1; // offset 16'h1850, width 64
    RX_DMA_DBG_BUFFER_DATA2_t  RX_DMA_DBG_BUFFER_DATA2; // offset 16'h1858, width 64
    RX_DMA_DBG_BUFFER_DATA3_t  RX_DMA_DBG_BUFFER_DATA3; // offset 16'h1860, width 64
    RX_DMA_DBG_BUFFER_DATA4_t  RX_DMA_DBG_BUFFER_DATA4; // offset 16'h1868, width 64
    RX_DMA_DBG_AT_ARRAY_ADDR_t RX_DMA_DBG_AT_ARRAY_ADDR; // offset 16'h1870, width 64
    RX_DMA_DBG_AT_ARRAY_DATA0_t RX_DMA_DBG_AT_ARRAY_DATA0; // offset 16'h1878, width 64
    RX_DMA_DBG_AT_ARRAY_DATA1_t RX_DMA_DBG_AT_ARRAY_DATA1; // offset 16'h1880, width 64
    RX_DMA_DBG_WAR_BUF_t       RX_DMA_DBG_WAR_BUF[2048]; // offset 16'h1888, width 64
    RX_DMA_ERR_BUF_MBE_t       RX_DMA_ERR_BUF_MBE[2]; // offset 16'h5888, width 64
    RX_DMA_ERR_LL_PARITY_t     RX_DMA_ERR_LL_PARITY[2]; // offset 16'h5898, width 64
    RX_DMA_ERR_TAIL_PARITY_t   RX_DMA_ERR_TAIL_PARITY[2]; // offset 16'h58A8, width 64
    RX_DMA_ERR_HEAD_PARITY_t   RX_DMA_ERR_HEAD_PARITY[2]; // offset 16'h58B8, width 64
    RX_DMA_ERR_AT_ARRAY_PARITY_t RX_DMA_ERR_AT_ARRAY_PARITY; // offset 16'h58C8, width 64
} fxr_rx_dma_csrs_t;                             // size:  16'h58D0
