//                                                                             
// File:       fxr_rx_hiarb_csrs.h                                             
// Creator:    pvesvslx                                                        
// Time:       Friday Aug 1, 2014 [11:06:17 am]                                
//                                                                             
// Path:       /tmp/pvesvslx/nebulon_run/30229                                 
// Arguments:  /p/com/eda/denali/blueprint/3.7.4/Linux/blueprint -chdr -I      
//             /p/slx/eda/intel/nebulon/2.05_fdo/include -I                    
//             /p/slx/pvesv/fxr_autogen/fxr fxr_rx_hiarb_csrs.rdl              
//                                                                             
// Sources:    /tmp/pvesvslx/nebulon_run/30229/fxr_rx_hiarb_csrs.rdlh          
//             /tmp/pvesvslx/nebulon_run/30229/lib_udp.rdl                     
//             /tmp/pvesvslx/nebulon_run/30229/fxr_rx_hiarb_csrs.rdl           
//             /p/com/eda/intel/nebulon/2.05p1/generators/generator_common.pm  
//             /p/com/eda/intel/nebulon/2.05p1/generators/chdr.pm              
//                                                                             
// Blueprint:   3.7.4 (Tue Jun 23 00:17:01 PDT 2009)                           
// Machine:    scci56217                                                       
// OS:         Linux 2.6.16.60-0.58.1.3835.0.PTF.638363-smp                    
// Description:                                                                
//                                                                             
//Receive HIARB address map                                                    
//                                                                             
// Copyright (C) 2014 Denali Software Inc.  All rights reserved                
// THIS FILE IS AUTOMATICALLY GENERATED BY DENALI BLUEPRINT, DO NOT EDIT       
//                                                                             



// rx_cfg_hiarb_credit_max desc:  Max credit settings for Address Translation Interface and Host
// Interface.
typedef volatile union {
    struct {
        uint64_t  hi_credit_max        :   8;    //  Credit max for Host Interface
        uint64_t  at_credit_max        :   8;    //  Credit max for Address
                                                 // Translation interface
        uint64_t  Reserved_63_16       :  48;    //  Reserved

    };
    uint64_t                         val;
} rx_cfg_hiarb_credit_max_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rx_cfg_hiarb_pcb_base desc:  Base address for the PCB in Host Memory.
typedef volatile union {
    struct {
        uint64_t  base_address         :  57;    //  Address for teh PCB in Host
                                                 // Memory
        uint64_t  physical             :   1;    //  0=Virtual Address 1 =
                                                 // Physical Address
        uint64_t  Reserved_63_58       :   6;    //  Reserved

    };
    uint64_t                         val;
} rx_cfg_hiarb_pcb_base_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rx_cfg_hiarb_cache_hints desc:  Settings for the cache hints to the Host Interface for various
// command type. Each hint pair is of the form {Allocating L1, Temporal
// L1/LLC}.
typedef volatile union {
    struct {
        uint64_t  small_rd_hints       :   2;    //  Small Message Reads (Less
                                                 // than 64B). These will assume
                                                 // no locality. If temporal or
                                                 // spatial locality exists, HI
                                                 // will automatically promote
                                                 // them to Allocating.
        uint64_t  small_wr_hints       :   2;    //  Small Message Writes (Less
                                                 // than 64B). These will be
                                                 // automatically promoted to
                                                 // Allocating writes by the HI so
                                                 // that a write-merge can be done
                                                 // in the L1. Therefore the
                                                 // Allocating hint will be
                                                 // assumed set.
        uint64_t  med_rd_hints         :   2;    //  Medium Message Reads (Between
                                                 // 64B and 2KB). These are
                                                 // performed by the TxDMA.
        uint64_t  med_wr_hints         :   2;    //  Medium Message Writes
                                                 // (Between 64B and 2KB). These
                                                 // will not allocate in the L1.
                                                 // By default, they will be
                                                 // marked as Temporal so that
                                                 // they allocate in the LLC (like
                                                 // DDIO). Note that Atomics will
                                                 // be promoted to Allocating.
        uint64_t  large_rd_hints       :   2;    //  Large Message Reads (Greater
                                                 // than 2KB). These are
                                                 // performend by the TxDMA.
        uint64_t  large_wr_hints       :   2;    //  Large Message Writes (Greater
                                                 // than 2KB). These will not
                                                 // allocate in the L1. By
                                                 // default, they will be marked
                                                 // as Temporal so that they
                                                 // allocate in the LLC (like
                                                 // DDIO). Note that Atomics will
                                                 // be promoted to Allocating.
        uint64_t  eq_hints             :   2;    //  Event Queue (EQ) Writes.
                                                 // While not reused by the HFI,
                                                 // will eventually be read by the
                                                 // host processor. The writes are
                                                 // marked as allocating in the L2
                                                 // to facilitate a cache-to-cache
                                                 // transfer when the host
                                                 // performs this read. They are
                                                 // not marked Temporal so that
                                                 // the L1 will evict them first
                                                 // if it needs to do a capacity
                                                 // evict.
        uint64_t  ct_hints             :   2;    //  Counting Event (CT) Updates.
                                                 // These updates will be
                                                 // implemented using atomics.
                                                 // Since there is a high degree
                                                 // of reuse for counting events,
                                                 // the atomics are marked as
                                                 // Allocating and Temporal.
        uint64_t  hfi_hints            :   2;    //  HFI Cache Operations. For
                                                 // read/write operations
                                                 // generated by non-coherent HFI
                                                 // caches, some reuse is
                                                 // expected. They are marked
                                                 // Non-Allocating in the L1 and
                                                 // Temporal so that they may
                                                 // allocate in the LLC..
        uint64_t  Reserved_31_18       :  14;    //  Reserved
        uint64_t  rd_credit_thresh     :   8;    //  Medium Size Read Threshold.
                                                 // From 64B to this number*64
                                                 // bytes inclusive is treated as
                                                 // Medium Size Read.Default is
                                                 // 2KB.
        uint64_t  wr_credit_thresh     :   8;    //  Medium Size Write Threshold.
                                                 // From 64B to this number*64
                                                 // bytes inclusive is treated as
                                                 // Medium Size Write. Default is
                                                 // 2KB.
        uint64_t  Reserved_63_48       :  16;    //  Reserved

    };
    uint64_t                         val;
} rx_cfg_hiarb_cache_hints_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rx_hiarb_error_mbe desc:  MBE error counts from all sources.
typedef volatile union {
    struct {
        uint64_t  syndrome             :   8;    //  syndrome of last mbe
        uint64_t  address              :   3;    //  address of last mbe
        uint64_t  qword                :   2;    //  qword position of last mbe
        uint64_t  src_interface        :   4;    //  source interface id of last
                                                 // mbe
        uint64_t  mbe_cnt              :   8;    //  saturating counter of mbe's
                                                 // from all sources
        uint64_t  Reserved_63_25       :  39;    //  Reserved

    };
    uint64_t                         val;
} rx_hiarb_error_mbe_t;

// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    rx_cfg_hiarb_credit_max_t  rx_cfg_hiarb_credit_max; // offset 4'h0, width 64
    rx_cfg_hiarb_pcb_base_t    rx_cfg_hiarb_pcb_base; // offset 4'h8, width 64
    rx_cfg_hiarb_cache_hints_t rx_cfg_hiarb_cache_hints; // offset 8'h10, width 64
    rx_hiarb_error_mbe_t       rx_hiarb_error_mbe; // offset 8'h18, width 64
} fxr_rx_hiarb_csrs_t;                           // size:  8'h20
