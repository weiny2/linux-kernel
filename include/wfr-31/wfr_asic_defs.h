/*
* -------------------------------------------------------------------
* --                      Intel Proprietary
* --              Copyright (C) 2013 Intel Corporation
* --                    All Rights Reserved
* -------------------------------------------------------------------
* --           Auto-generated by /p/slx/pvesv/wfr_autogen/utils/scripts/i_csrs/i_csrs.pl 
* --  i_csrs.pl Version 1.4 last modified on Wednesday 1/8/14 13:42:49
* --   /p/slx/pvesv/wfr_autogen/utils/scripts/i_csrs/i_csrs.pl -C -o /p/slx/pvesv/wfr_autogen/wfr /p/slx/pvesv/wfr_autogen/SL1_fixed_xml/WFR/231_ASIC_Registers.xml  
* --------------------------------------------------------------------
*/

#ifndef DEF_WFR_ASIC_SW_DEF
#define DEF_WFR_ASIC_SW_DEF

#define ASIC_OFFSET								0x0000000
#define ASIC_NUM_SCRATCH							4
#define ASIC_MAX_SCRATCH							3
#define ASIC_MAN_EFUSE_NUM							64
#define ASIC_MAN_EFUSE_MAX							63
#define ASIC_WFR_EFUSE_NUM							64
#define ASIC_WFR_EFUSE_MAX							63
/*
* Table #6 of 231_ASIC_Registers.xml - ASIC_CFG_SBUS_REQUEST
* SBus request interface (see SBus Master spec).
*/
#define WFR_ASIC_CFG_SBUS_REQUEST						(WFR_ASIC + 0x000000000000)
#define WFR_ASIC_CFG_SBUS_REQUEST_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_IN_SHIFT					32
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_IN_MASK					0xFFFFFFFFull
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_IN_SMASK					0xFFFFFFFF00000000ull
#define WFR_ASIC_CFG_SBUS_REQUEST_COMMAND_SHIFT					16
#define WFR_ASIC_CFG_SBUS_REQUEST_COMMAND_MASK					0xFFull
#define WFR_ASIC_CFG_SBUS_REQUEST_COMMAND_SMASK					0xFF0000ull
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_ADDR_SHIFT				8
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_ADDR_MASK				0xFFull
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_ADDR_SMASK				0xFF00ull
#define WFR_ASIC_CFG_SBUS_REQUEST_RECEIVER_ADDR_SHIFT				0
#define WFR_ASIC_CFG_SBUS_REQUEST_RECEIVER_ADDR_MASK				0xFFull
#define WFR_ASIC_CFG_SBUS_REQUEST_RECEIVER_ADDR_SMASK				0xFFull
/*
* Table #7 of 231_ASIC_Registers.xml - ASIC_CFG_SBUS_EXECUTE
* SBus request interface execution bits (see SBus Master spec).
*/
#define WFR_ASIC_CFG_SBUS_EXECUTE						(WFR_ASIC + 0x000000000008)
#define WFR_ASIC_CFG_SBUS_EXECUTE_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_CFG_SBUS_EXECUTE_FAST_MODE_SHIFT				1
#define WFR_ASIC_CFG_SBUS_EXECUTE_FAST_MODE_MASK				0x1ull
#define WFR_ASIC_CFG_SBUS_EXECUTE_FAST_MODE_SMASK				0x2ull
#define WFR_ASIC_CFG_SBUS_EXECUTE_EXECUTE_SHIFT					0
#define WFR_ASIC_CFG_SBUS_EXECUTE_EXECUTE_MASK					0x1ull
#define WFR_ASIC_CFG_SBUS_EXECUTE_EXECUTE_SMASK					0x1ull
/*
* Table #8 of 231_ASIC_Registers.xml - ASIC_STS_SBUS_RESULT
* SBus request interface result data (see SBus Master spec).
*/
#define WFR_ASIC_STS_SBUS_RESULT						(WFR_ASIC + 0x000000000010)
#define WFR_ASIC_STS_SBUS_RESULT_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_STS_SBUS_RESULT_DATA_OUT_SHIFT					32
#define WFR_ASIC_STS_SBUS_RESULT_DATA_OUT_MASK					0xFFFFFFFFull
#define WFR_ASIC_STS_SBUS_RESULT_DATA_OUT_SMASK					0xFFFFFFFF00000000ull
#define WFR_ASIC_STS_SBUS_RESULT_RESULT_CODE_SHIFT				2
#define WFR_ASIC_STS_SBUS_RESULT_RESULT_CODE_MASK				0x7ull
#define WFR_ASIC_STS_SBUS_RESULT_RESULT_CODE_SMASK				0x1Cull
#define WFR_ASIC_STS_SBUS_RESULT_RCV_DATA_VALID_SHIFT				1
#define WFR_ASIC_STS_SBUS_RESULT_RCV_DATA_VALID_MASK				0x1ull
#define WFR_ASIC_STS_SBUS_RESULT_RCV_DATA_VALID_SMASK				0x2ull
#define WFR_ASIC_STS_SBUS_RESULT_DONE_SHIFT					0
#define WFR_ASIC_STS_SBUS_RESULT_DONE_MASK					0x1ull
#define WFR_ASIC_STS_SBUS_RESULT_DONE_SMASK					0x1ull
/*
* Table #9 of 231_ASIC_Registers.xml - ASIC_STS_SBUS_COUNTERS
* Counters for SBus EXECUTE and RCV_DATA_VALID bits. RCV_DATA_VALID could be 
* cleared before software gets a chance to read it, so these counters can be 
* used to determine if a transaction completed (when EXECUTE_CNT and 
* RCV_DATA_VALID_CNT match).
*/
#define WFR_ASIC_STS_SBUS_COUNTERS						(WFR_ASIC + 0x000000000018)
#define WFR_ASIC_STS_SBUS_COUNTERS_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_STS_SBUS_COUNTERS_RCV_DATA_VALID_CNT_SHIFT			16
#define WFR_ASIC_STS_SBUS_COUNTERS_RCV_DATA_VALID_CNT_MASK			0xFFFFull
#define WFR_ASIC_STS_SBUS_COUNTERS_RCV_DATA_VALID_CNT_SMASK			0xFFFF0000ull
#define WFR_ASIC_STS_SBUS_COUNTERS_EXECUTE_CNT_SHIFT				0
#define WFR_ASIC_STS_SBUS_COUNTERS_EXECUTE_CNT_MASK				0xFFFFull
#define WFR_ASIC_STS_SBUS_COUNTERS_EXECUTE_CNT_SMASK				0xFFFFull
/*
* Table #10 of 231_ASIC_Registers.xml - ASIC_CFG_SCRATCH
* These scratch registers are read/write and for software use only. Since these 
* scratch CSRs are in the ASIC block, they are shared by both HFIs. This can be 
* potentially used by host software to communicate software-defined 
* status/control information between the host software for HFI0 and the host 
* software for HFI1.
*/
#define WFR_ASIC_CFG_SCRATCH							(WFR_ASIC + 0x000000000020)
#define WFR_ASIC_CFG_SCRATCH_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_CFG_SCRATCH_SCRATCH_SHIFT					0
#define WFR_ASIC_CFG_SCRATCH_SCRATCH_MASK					0xFFFFFFFFFFFFFFFFull
#define WFR_ASIC_CFG_SCRATCH_SCRATCH_SMASK					0xFFFFFFFFFFFFFFFFull
/*
* Table #11 of 231_ASIC_Registers.xml - ASIC_CFG_MUTEX
* This CSR provides state and a special atomic write behavior that can be used 
* by host software to implement a mutex. It provides a single mutual exclusion 
* lock that can be used to mediate two different 'users'.
*/
#define WFR_ASIC_CFG_MUTEX							(WFR_ASIC + 0x000000000040)
#define WFR_ASIC_CFG_MUTEX_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_CFG_MUTEX_USER_SHIFT						0
#define WFR_ASIC_CFG_MUTEX_USER_MASK						0x3ull
#define WFR_ASIC_CFG_MUTEX_USER_SMASK						0x3ull
/*
* Table #13 of 231_ASIC_Registers.xml - ASIC_CFG_DRV_STR
* The fields in this CSR correspond to bits [33:0] of EfuseDrvStr in #%%#Section 
* 18.1, #%%#'EFUSE'#%%# and #%%#Section 15.8.3.62, #%%#'ASIC_WFR_EFUSE_REGS11'#%%#. 
* The fields are broken out here to show how the 2-bit and 4-bit fields control 
* the drive strength of different #%%#WFR#%%# ASIC miscellaneous output 
* pins.
*/
#define WFR_ASIC_CFG_DRV_STR							(WFR_ASIC + 0x000000000048)
#define WFR_ASIC_CFG_DRV_STR_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_GPIO2P5_SHIFT			32
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_GPIO2P5_MASK				0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_GPIO2P5_SMASK			0x300000000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EFUSE_VEN_SHIFT			30
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EFUSE_VEN_MASK			0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EFUSE_VEN_SMASK			0xC0000000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_GPIO_SHIFT				28
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_GPIO_MASK				0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_GPIO_SMASK				0x30000000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_MBIST_FAIL_SHIFT			26
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_MBIST_FAIL_MASK			0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_MBIST_FAIL_SMASK			0xC000000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_WP_N_SHIFT			24
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_WP_N_MASK			0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_WP_N_SMASK			0x3000000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_SS_N_SHIFT			22
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_SS_N_MASK			0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_SS_N_SMASK			0xC00000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_SCLK_SHIFT			20
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_SCLK_MASK			0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_SCLK_SMASK			0x300000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_MOSI_SHIFT			18
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_MOSI_MASK			0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_EPROM_MOSI_SMASK			0xC0000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_INTERNAL_MBP_SHIFT			14
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_INTERNAL_MBP_MASK			0xFull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_INTERNAL_MBP_SMASK			0x3C000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_THERMISTRIP_SHIFT			12
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_THERMISTRIP_MASK			0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_THERMISTRIP_SMASK			0x3000ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_SMB_DATA_SHIFT			10
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_SMB_DATA_MASK			0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_SMB_DATA_SMASK			0xC00ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_SMB_CLK_SHIFT			8
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_SMB_CLK_MASK				0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_SMB_CLK_SMASK			0x300ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_RESET_N_SHIFT			6
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_RESET_N_MASK				0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_RESET_N_SMASK			0xC0ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_LED_N_SHIFT				4
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_LED_N_MASK				0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_LED_N_SMASK				0x30ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_I2C_DAT_SHIFT			2
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_I2C_DAT_MASK				0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_I2C_DAT_SMASK			0xCull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_I2C_CLK_SHIFT			0
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_I2C_CLK_MASK				0x3ull
#define WFR_ASIC_CFG_DRV_STR_EFUSE_DRV_STR_I2C_CLK_SMASK			0x3ull
/*
* Table #14 of 231_ASIC_Registers.xml - ASIC_CFG_THERM_POLL_EN
* Enables hardware polling of the Avago temperature sensor. Polling of the 
* temperature sensor should not be enabled until it is properly initialized 
* according to Avago's '28 nm ASIC I/O Databook', Chapter 8, 'Thermal/Voltage 
* Monitoring'. This includes the setting of its internal clock divider and 
* setting the start bit. For more information, see #%%#Section 6.6.1, 
* #%%#'SMBus'#%%#.
*/
#define WFR_ASIC_CFG_THERM_POLL_EN						(WFR_ASIC + 0x000000000050)
#define WFR_ASIC_CFG_THERM_POLL_EN_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_CFG_THERM_POLL_EN_THERM_POLL_EN_SHIFT				0
#define WFR_ASIC_CFG_THERM_POLL_EN_THERM_POLL_EN_MASK				0x1ull
#define WFR_ASIC_CFG_THERM_POLL_EN_THERM_POLL_EN_SMASK				0x1ull
/*
* Table #15 of 231_ASIC_Registers.xml - ASIC_STS_THERM
* This register provides host read-only access to the status of the thermal 
* sensor. The values correspond to the fields of the following 4 SMBus 
* registers: #%%#Section 17.1.3.3, #%%#'SMBUS_CFG_TS_HI_LIMIT'#%%#, #%%#Section 
* 17.1.3.4, #%%#'SMBUS_CFG_TS_LO_LIMIT'#%%#, #%%#Section 17.1.3.5, 
* #%%#'SMBUS_CFG_TS_TCRIT_LIMIT'#%%# and #%%#Section 17.1.3.6, 
* #%%#'SMBUS_STS_TS_TEMP'#%%#. The thermal sensor must be initialized and 
* enabled using ASIC_CFG_THERM_POLL_EN for CURR_TEMP to read the current 
* temperature. For more information, see #%%#Section 6.6.1, #%%#'SMBus'#%%#.
*/
#define WFR_ASIC_STS_THERM							(WFR_ASIC + 0x000000000058)
#define WFR_ASIC_STS_THERM_RESETCSR						0x0690000006900000ull
#define WFR_ASIC_STS_THERM_HI_TEMP_SHIFT					50
#define WFR_ASIC_STS_THERM_HI_TEMP_MASK						0x7FFull
#define WFR_ASIC_STS_THERM_HI_TEMP_SMASK					0x1FFC000000000000ull
#define WFR_ASIC_STS_THERM_LO_TEMP_SHIFT					34
#define WFR_ASIC_STS_THERM_LO_TEMP_MASK						0x7FFull
#define WFR_ASIC_STS_THERM_LO_TEMP_SMASK					0x1FFC00000000ull
#define WFR_ASIC_STS_THERM_CRIT_TEMP_SHIFT					18
#define WFR_ASIC_STS_THERM_CRIT_TEMP_MASK					0x7FFull
#define WFR_ASIC_STS_THERM_CRIT_TEMP_SMASK					0x1FFC0000ull
#define WFR_ASIC_STS_THERM_TCRIT_SHIFT						15
#define WFR_ASIC_STS_THERM_TCRIT_MASK						0x1ull
#define WFR_ASIC_STS_THERM_TCRIT_SMASK						0x8000ull
#define WFR_ASIC_STS_THERM_HIGH_SHIFT						14
#define WFR_ASIC_STS_THERM_HIGH_MASK						0x1ull
#define WFR_ASIC_STS_THERM_HIGH_SMASK						0x4000ull
#define WFR_ASIC_STS_THERM_LOW_SHIFT						13
#define WFR_ASIC_STS_THERM_LOW_MASK						0x1ull
#define WFR_ASIC_STS_THERM_LOW_SMASK						0x2000ull
#define WFR_ASIC_STS_THERM_CURR_TEMP_SHIFT					2
#define WFR_ASIC_STS_THERM_CURR_TEMP_MASK					0x7FFull
#define WFR_ASIC_STS_THERM_CURR_TEMP_SMASK					0x1FFCull
/*
* Table #16 of 231_ASIC_Registers.xml - ASIC_PCIE_SD_HOST_CMD
* This CSR specifies the command interrupt that is issued to all of the PCIe 
* SerDes. Note that these are not interrupts to the host. Interrupt is the name 
* given by the IP vendor for commands given to the SerDes macro.
*/
#define WFR_ASIC_PCIE_SD_HOST_CMD						(WFR_ASIC + 0x000000000100)
#define WFR_ASIC_PCIE_SD_HOST_CMD_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_PCIE_SD_HOST_CMD_SBUS_RCVR_ADDR_SHIFT				2
#define WFR_ASIC_PCIE_SD_HOST_CMD_SBUS_RCVR_ADDR_MASK				0xFFull
#define WFR_ASIC_PCIE_SD_HOST_CMD_SBUS_RCVR_ADDR_SMASK				0x3FCull
#define WFR_ASIC_PCIE_SD_HOST_CMD_INTRPT_CMD_SHIFT				0
#define WFR_ASIC_PCIE_SD_HOST_CMD_INTRPT_CMD_MASK				0x3ull
#define WFR_ASIC_PCIE_SD_HOST_CMD_INTRPT_CMD_SMASK				0x3ull
/*
* Table #17 of 231_ASIC_Registers.xml - ASIC_PCIE_SD_HOST_STATUS
* This CSR returns the status of the firmware download.
*/
#define WFR_ASIC_PCIE_SD_HOST_STATUS						(WFR_ASIC + 0x000000000108)
#define WFR_ASIC_PCIE_SD_HOST_STATUS_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_PCIE_SD_HOST_STATUS_FW_DNLD_STS_SHIFT				0
#define WFR_ASIC_PCIE_SD_HOST_STATUS_FW_DNLD_STS_MASK				0x3ull
#define WFR_ASIC_PCIE_SD_HOST_STATUS_FW_DNLD_STS_SMASK				0x3ull
/*
* Table #18 of 231_ASIC_Registers.xml - ASIC_PCIE_SD_INTRPT_DATA_CODE
* This CSR specifies the 16-bit code and 16-bit data for the interrupt command. 
* The interpretation of the code and data is specified by the Avago Spico 
* Firmware User Documentation..
*/
#define WFR_ASIC_PCIE_SD_INTRPT_DATA_CODE					(WFR_ASIC + 0x000000000110)
#define WFR_ASIC_PCIE_SD_INTRPT_DATA_CODE_RESETCSR				0x0000000000000000ull
#define WFR_ASIC_PCIE_SD_INTRPT_DATA_CODE_INTRPT_CODE_SHIFT			16
#define WFR_ASIC_PCIE_SD_INTRPT_DATA_CODE_INTRPT_CODE_MASK			0xFFFFull
#define WFR_ASIC_PCIE_SD_INTRPT_DATA_CODE_INTRPT_CODE_SMASK			0xFFFF0000ull
#define WFR_ASIC_PCIE_SD_INTRPT_DATA_CODE_INTRPT_DATA_SHIFT			0
#define WFR_ASIC_PCIE_SD_INTRPT_DATA_CODE_INTRPT_DATA_MASK			0xFFFFull
#define WFR_ASIC_PCIE_SD_INTRPT_DATA_CODE_INTRPT_DATA_SMASK			0xFFFFull
/*
* Table #19 of 231_ASIC_Registers.xml - ASIC_PCIE_SD_INTRPT_ENABLE
* This CSR specifies the set of PCIe SerDes macros that the interrupt command is 
* issued to.
*/
#define WFR_ASIC_PCIE_SD_INTRPT_ENABLE						(WFR_ASIC + 0x000000000118)
#define WFR_ASIC_PCIE_SD_INTRPT_ENABLE_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_PCIE_SD_INTRPT_ENABLE_HFI1_INTRPT_ENABLE_SHIFT			16
#define WFR_ASIC_PCIE_SD_INTRPT_ENABLE_HFI1_INTRPT_ENABLE_MASK			0xFFFFull
#define WFR_ASIC_PCIE_SD_INTRPT_ENABLE_HFI1_INTRPT_ENABLE_SMASK			0xFFFF0000ull
#define WFR_ASIC_PCIE_SD_INTRPT_ENABLE_HFI0_INTRPT_ENABLE_SHIFT			0
#define WFR_ASIC_PCIE_SD_INTRPT_ENABLE_HFI0_INTRPT_ENABLE_MASK			0xFFFFull
#define WFR_ASIC_PCIE_SD_INTRPT_ENABLE_HFI0_INTRPT_ENABLE_SMASK			0xFFFFull
/*
* Table #20 of 231_ASIC_Registers.xml - ASIC_PCIE_SD_INTRPT_PROGRESS
* This CSR indicates the progress of each of the PCIe SerDes macros that the 
* interrupt command has been issued to. Note that only the enabled SerDes will 
* process an interrupt command. This CSR is for diagnostic purpose and the 
* ASIC_PCIE_SD_INTRPT_STATUS should be used to determine completion of an 
* interrupt command.
*/
#define WFR_ASIC_PCIE_SD_INTRPT_PROGRESS					(WFR_ASIC + 0x000000000120)
#define WFR_ASIC_PCIE_SD_INTRPT_PROGRESS_RESETCSR				0x0000000000000000ull
#define WFR_ASIC_PCIE_SD_INTRPT_PROGRESS_HFI1_INTRPT_PROGRESS_SHIFT		16
#define WFR_ASIC_PCIE_SD_INTRPT_PROGRESS_HFI1_INTRPT_PROGRESS_MASK		0xFFFFull
#define WFR_ASIC_PCIE_SD_INTRPT_PROGRESS_HFI1_INTRPT_PROGRESS_SMASK		0xFFFF0000ull
#define WFR_ASIC_PCIE_SD_INTRPT_PROGRESS_HFI0_INTRPT_PROGRESS_SHIFT		0
#define WFR_ASIC_PCIE_SD_INTRPT_PROGRESS_HFI0_INTRPT_PROGRESS_MASK		0xFFFFull
#define WFR_ASIC_PCIE_SD_INTRPT_PROGRESS_HFI0_INTRPT_PROGRESS_SMASK		0xFFFFull
/*
* Table #21 of 231_ASIC_Registers.xml - ASIC_PCIE_SD_INTRPT_STATUS
* This CSR is used to determine the completion of the interrupt commands to each 
* of the PCIe SerDes macros. Once completed, the interrupt respond data, if any, 
* is available in the PCIE_SD_INTRPT_RSPD_DATA registers. Note that only the 
* enabled SerDes will report a status.
*/
#define WFR_ASIC_PCIE_SD_INTRPT_STATUS						(WFR_ASIC + 0x000000000128)
#define WFR_ASIC_PCIE_SD_INTRPT_STATUS_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_PCIE_SD_INTRPT_STATUS_HFI1_INTRPT_STS_SHIFT			16
#define WFR_ASIC_PCIE_SD_INTRPT_STATUS_HFI1_INTRPT_STS_MASK			0xFFFFull
#define WFR_ASIC_PCIE_SD_INTRPT_STATUS_HFI1_INTRPT_STS_SMASK			0xFFFF0000ull
#define WFR_ASIC_PCIE_SD_INTRPT_STATUS_HFI0_INTRPT_STS_SHIFT			0
#define WFR_ASIC_PCIE_SD_INTRPT_STATUS_HFI0_INTRPT_STS_MASK			0xFFFFull
#define WFR_ASIC_PCIE_SD_INTRPT_STATUS_HFI0_INTRPT_STS_SMASK			0xFFFFull
/*
* Table #22 of 231_ASIC_Registers.xml - ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA
* This CSR contains the response data from each of the PCIe SerDes after 
* executing the interrupt command. HFI0 has 16 PCIe SerDes and each returns a 
* 16-bit value. Lanes 0-3 are packed into the first CSR, lanes 4-7 in the next 
* CSR, etc. The response data is valid after an interrupt command has 
* successfully completed. Note that only the enabled SerDes will return response 
* data. The interpretation of the response data is specified by the Avago Spico 
* Firmware User Documentation.
*/
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA					(WFR_ASIC + 0x000000000130)
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_RESETCSR				0x0000000000000000ull
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD3_INTRPT_RSPD_DATA_SHIFT	48
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD3_INTRPT_RSPD_DATA_MASK	0xFFFFull
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD3_INTRPT_RSPD_DATA_SMASK	0xFFFF000000000000ull
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD2_INTRPT_RSPD_DATA_SHIFT	32
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD2_INTRPT_RSPD_DATA_MASK	0xFFFFull
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD2_INTRPT_RSPD_DATA_SMASK	0xFFFF00000000ull
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD1_INTRPT_RSPD_DATA_SHIFT	16
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD1_INTRPT_RSPD_DATA_MASK	0xFFFFull
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD1_INTRPT_RSPD_DATA_SMASK	0xFFFF0000ull
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD0_INTRPT_RSPD_DATA_SHIFT	0
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD0_INTRPT_RSPD_DATA_MASK	0xFFFFull
#define WFR_ASIC_HFI0_PCIE_SD_INTRPT_RSPD_DATA_SD0_INTRPT_RSPD_DATA_SMASK	0xFFFFull
/*
* Table #23 of 231_ASIC_Registers.xml - ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA
* This CSR specifies the response data from the PCIe SerDes after executing the 
* interrupt command. HFI1 has 16 PCIe SerDes and each returns a 16-bit value. 
* Lanes 0-3 are packed into the first CSR, lanes 4-7 in the next CSR, etc. The 
* response data is valid after an interrupt command has successfully completed. 
* Note that only the enabled SerDes will return response data. The 
* interpretation of the response data is specified by the Avago Spico Firmware 
* User Documentation.
*/
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA					(WFR_ASIC + 0x000000000150)
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_RESETCSR				0x0000000000000000ull
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD3_INTRPT_RSPD_DATA_SHIFT	48
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD3_INTRPT_RSPD_DATA_MASK	0xFFFFull
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD3_INTRPT_RSPD_DATA_SMASK	0xFFFF000000000000ull
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD2_INTRPT_RSPD_DATA_SHIFT	32
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD2_INTRPT_RSPD_DATA_MASK	0xFFFFull
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD2_INTRPT_RSPD_DATA_SMASK	0xFFFF00000000ull
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD1_INTRPT_RSPD_DATA_SHIFT	16
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD1_INTRPT_RSPD_DATA_MASK	0xFFFFull
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD1_INTRPT_RSPD_DATA_SMASK	0xFFFF0000ull
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD0_INTRPT_RSPD_DATA_SHIFT	0
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD0_INTRPT_RSPD_DATA_MASK	0xFFFFull
#define WFR_ASIC_HFI1_PCIE_SD_INTRPT_RSPD_DATA_SD0_INTRPT_RSPD_DATA_SMASK	0xFFFFull
/*
* Table #24 of 231_ASIC_Registers.xml - ASIC_GPIO_IN
* This CSR is used to read the current value of the GPIO pins (prior to any 
* inversion).
*/
#define WFR_ASIC_GPIO_IN							(WFR_ASIC + 0x000000000200)
#define WFR_ASIC_GPIO_IN_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_GPIO_IN_GPIO_IN_SHIFT						0
#define WFR_ASIC_GPIO_IN_GPIO_IN_MASK						0xFFFFull
#define WFR_ASIC_GPIO_IN_GPIO_IN_SMASK						0xFFFFull
/*
* Table #25 of 231_ASIC_Registers.xml - ASIC_GPIO_OE
* This CSR specifies the output enable for the GPIO pins.
*/
#define WFR_ASIC_GPIO_OE							(WFR_ASIC + 0x000000000208)
#define WFR_ASIC_GPIO_OE_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_GPIO_OE_GPIO_OE_SHIFT						0
#define WFR_ASIC_GPIO_OE_GPIO_OE_MASK						0xFFFFull
#define WFR_ASIC_GPIO_OE_GPIO_OE_SMASK						0xFFFFull
/*
* Table #26 of 231_ASIC_Registers.xml - ASIC_GPIO_INVERT
* This CSR specifies whether the read value of the GPIO pins should be inverted 
* or not.
*/
#define WFR_ASIC_GPIO_INVERT							(WFR_ASIC + 0x000000000210)
#define WFR_ASIC_GPIO_INVERT_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_GPIO_INVERT_GPIO_INVERT_SHIFT					0
#define WFR_ASIC_GPIO_INVERT_GPIO_INVERT_MASK					0xFFFFull
#define WFR_ASIC_GPIO_INVERT_GPIO_INVERT_SMASK					0xFFFFull
/*
* Table #27 of 231_ASIC_Registers.xml - ASIC_GPIO_OUT
* This CSR specifies the output value of the GPIO pins.
*/
#define WFR_ASIC_GPIO_OUT							(WFR_ASIC + 0x000000000218)
#define WFR_ASIC_GPIO_OUT_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_GPIO_OUT_GPIO_OUT_SHIFT					0
#define WFR_ASIC_GPIO_OUT_GPIO_OUT_MASK						0xFFFFull
#define WFR_ASIC_GPIO_OUT_GPIO_OUT_SMASK					0xFFFFull
/*
* Table #28 of 231_ASIC_Registers.xml - ASIC_GPIO_MASK
* This CSR specifies the mask value for the GPIO pins and is used to mask the 
* GPIO status value to indicate whether the GPIO interrupt is to be 
* delivered.
*/
#define WFR_ASIC_GPIO_MASK							(WFR_ASIC + 0x000000000220)
#define WFR_ASIC_GPIO_MASK_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_GPIO_MASK_GPIO_MASK_SHIFT					0
#define WFR_ASIC_GPIO_MASK_GPIO_MASK_MASK					0xFFFFull
#define WFR_ASIC_GPIO_MASK_GPIO_MASK_SMASK					0xFFFFull
/*
* Table #29 of 231_ASIC_Registers.xml - ASIC_GPIO_STATUS
* This CSR can be used to read the GPIO status.
*/
#define WFR_ASIC_GPIO_STATUS							(WFR_ASIC + 0x000000000228)
#define WFR_ASIC_GPIO_STATUS_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_GPIO_STATUS_GPIO_STATUS_SHIFT					0
#define WFR_ASIC_GPIO_STATUS_GPIO_STATUS_MASK					0xFFFFull
#define WFR_ASIC_GPIO_STATUS_GPIO_STATUS_SMASK					0xFFFFull
/*
* Table #30 of 231_ASIC_Registers.xml - ASIC_GPIO_CLEAR
* This CSR can be used to clear the GPIO status. Note that this field is not 
* marked with '/P', but this is fine since this register always reads as 
* 0.
*/
#define WFR_ASIC_GPIO_CLEAR							(WFR_ASIC + 0x000000000230)
#define WFR_ASIC_GPIO_CLEAR_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_GPIO_CLEAR_GPIO_CLEAR_SHIFT					0
#define WFR_ASIC_GPIO_CLEAR_GPIO_CLEAR_MASK					0xFFFFull
#define WFR_ASIC_GPIO_CLEAR_GPIO_CLEAR_SMASK					0xFFFFull
/*
* Table #31 of 231_ASIC_Registers.xml - ASIC_GPIO_FORCE
* This CSR can be used to force the GPIO status. Note that this field is not 
* marked with '/P', but this is fine since this register always reads as 
* 0.
*/
#define WFR_ASIC_GPIO_FORCE							(WFR_ASIC + 0x000000000238)
#define WFR_ASIC_GPIO_FORCE_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_GPIO_FORCE_GPIO_FORCE_SHIFT					0
#define WFR_ASIC_GPIO_FORCE_GPIO_FORCE_MASK					0xFFFFull
#define WFR_ASIC_GPIO_FORCE_GPIO_FORCE_SMASK					0xFFFFull
/*
* Table #32 of 231_ASIC_Registers.xml - ASIC_QSFP1_IN
* This CSR is used to read the current value of the QSFP1 pins (prior to any 
* inversion).
*/
#define WFR_ASIC_QSFP1_IN							(WFR_ASIC + 0x000000000240)
#define WFR_ASIC_QSFP1_IN_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP1_IN_QSFP1_IN_SHIFT					0
#define WFR_ASIC_QSFP1_IN_QSFP1_IN_MASK						0x1Full
#define WFR_ASIC_QSFP1_IN_QSFP1_IN_SMASK					0x1Full
/*
* Table #33 of 231_ASIC_Registers.xml - ASIC_QSFP1_OE
* This CSR specifies the output enable for the QSFP1 pins.
*/
#define WFR_ASIC_QSFP1_OE							(WFR_ASIC + 0x000000000248)
#define WFR_ASIC_QSFP1_OE_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP1_OE_QSFP1_OE_SHIFT					0
#define WFR_ASIC_QSFP1_OE_QSFP1_OE_MASK						0x1Full
#define WFR_ASIC_QSFP1_OE_QSFP1_OE_SMASK					0x1Full
/*
* Table #34 of 231_ASIC_Registers.xml - ASIC_QSFP1_INVERT
* This CSR specifies whether the read value of the QSFP1 pins should be inverted 
* or not.
*/
#define WFR_ASIC_QSFP1_INVERT							(WFR_ASIC + 0x000000000250)
#define WFR_ASIC_QSFP1_INVERT_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP1_INVERT_QSFP1_INVERT_SHIFT				0
#define WFR_ASIC_QSFP1_INVERT_QSFP1_INVERT_MASK					0x1Full
#define WFR_ASIC_QSFP1_INVERT_QSFP1_INVERT_SMASK				0x1Full
/*
* Table #35 of 231_ASIC_Registers.xml - ASIC_QSFP1_OUT
* This CSR specifies the output value of the QSFP1 pins.
*/
#define WFR_ASIC_QSFP1_OUT							(WFR_ASIC + 0x000000000258)
#define WFR_ASIC_QSFP1_OUT_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP1_OUT_QSFP1_OUT_SHIFT					0
#define WFR_ASIC_QSFP1_OUT_QSFP1_OUT_MASK					0x1Full
#define WFR_ASIC_QSFP1_OUT_QSFP1_OUT_SMASK					0x1Full
/*
* Table #36 of 231_ASIC_Registers.xml - ASIC_QSFP1_MASK
* This CSR specifies the mask value for the QSFP1 pins and is used to mask the 
* QSFP1 status value to indicate whether the QSFP1 interrupt is to be 
* delivered.
*/
#define WFR_ASIC_QSFP1_MASK							(WFR_ASIC + 0x000000000260)
#define WFR_ASIC_QSFP1_MASK_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP1_MASK_QSFP1_MASK_SHIFT					0
#define WFR_ASIC_QSFP1_MASK_QSFP1_MASK_MASK					0x1Full
#define WFR_ASIC_QSFP1_MASK_QSFP1_MASK_SMASK					0x1Full
/*
* Table #37 of 231_ASIC_Registers.xml - ASIC_QSFP1_STATUS
* This CSR can be used to read the QSFP1 status.
*/
#define WFR_ASIC_QSFP1_STATUS							(WFR_ASIC + 0x000000000268)
#define WFR_ASIC_QSFP1_STATUS_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP1_STATUS_QSFP1_STATUS_SHIFT				0
#define WFR_ASIC_QSFP1_STATUS_QSFP1_STATUS_MASK					0x1Full
#define WFR_ASIC_QSFP1_STATUS_QSFP1_STATUS_SMASK				0x1Full
/*
* Table #38 of 231_ASIC_Registers.xml - ASIC_QSFP1_CLEAR
* This CSR can be used to clear the QSFP1 status. Note that this field is not 
* marked with '/P', but this is fine since this register always reads as 
* 0.
*/
#define WFR_ASIC_QSFP1_CLEAR							(WFR_ASIC + 0x000000000270)
#define WFR_ASIC_QSFP1_CLEAR_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP1_CLEAR_QSFP1_CLEAR_SHIFT					0
#define WFR_ASIC_QSFP1_CLEAR_QSFP1_CLEAR_MASK					0x1Full
#define WFR_ASIC_QSFP1_CLEAR_QSFP1_CLEAR_SMASK					0x1Full
/*
* Table #39 of 231_ASIC_Registers.xml - ASIC_QSFP1_FORCE
* This CSR can be used to force the QSFP1 status. Note that this field is not 
* marked with '/P', but this is fine since this register always reads as 
* 0.
*/
#define WFR_ASIC_QSFP1_FORCE							(WFR_ASIC + 0x000000000278)
#define WFR_ASIC_QSFP1_FORCE_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP1_FORCE_QSFP1_FORCE_SHIFT					0
#define WFR_ASIC_QSFP1_FORCE_QSFP1_FORCE_MASK					0x1Full
#define WFR_ASIC_QSFP1_FORCE_QSFP1_FORCE_SMASK					0x1Full
/*
* Table #40 of 231_ASIC_Registers.xml - ASIC_QSFP2_IN
* This CSR is used to read the current value of the QSFP2 pins (prior to any 
* inversion).
*/
#define WFR_ASIC_QSFP2_IN							(WFR_ASIC + 0x000000000280)
#define WFR_ASIC_QSFP2_IN_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP2_IN_QSFP2_IN_SHIFT					0
#define WFR_ASIC_QSFP2_IN_QSFP2_IN_MASK						0x1Full
#define WFR_ASIC_QSFP2_IN_QSFP2_IN_SMASK					0x1Full
/*
* Table #41 of 231_ASIC_Registers.xml - ASIC_QSFP2_OE
* This CSR specifies the output enable for the QSFP2 pins.
*/
#define WFR_ASIC_QSFP2_OE							(WFR_ASIC + 0x000000000288)
#define WFR_ASIC_QSFP2_OE_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP2_OE_QSFP2_OE_SHIFT					0
#define WFR_ASIC_QSFP2_OE_QSFP2_OE_MASK						0x1Full
#define WFR_ASIC_QSFP2_OE_QSFP2_OE_SMASK					0x1Full
/*
* Table #42 of 231_ASIC_Registers.xml - ASIC_QSFP2_INVERT
* This CSR specifies whether the read value of the QSFP2 pins should be inverted 
* or not.
*/
#define WFR_ASIC_QSFP2_INVERT							(WFR_ASIC + 0x000000000290)
#define WFR_ASIC_QSFP2_INVERT_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP2_INVERT_QSFP2_INVERT_SHIFT				0
#define WFR_ASIC_QSFP2_INVERT_QSFP2_INVERT_MASK					0x1Full
#define WFR_ASIC_QSFP2_INVERT_QSFP2_INVERT_SMASK				0x1Full
/*
* Table #43 of 231_ASIC_Registers.xml - ASIC_QSFP2_OUT
* This CSR specifies the output value of the QSFP2 pins.
*/
#define WFR_ASIC_QSFP2_OUT							(WFR_ASIC + 0x000000000298)
#define WFR_ASIC_QSFP2_OUT_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP2_OUT_QSFP2_OUT_SHIFT					0
#define WFR_ASIC_QSFP2_OUT_QSFP2_OUT_MASK					0x1Full
#define WFR_ASIC_QSFP2_OUT_QSFP2_OUT_SMASK					0x1Full
/*
* Table #44 of 231_ASIC_Registers.xml - ASIC_QSFP2_MASK
* This CSR specifies the mask value for the QSFP2 pins and is used to mask the 
* QSFP2 status value to indicate whether the QSFP2 interrupt is to be 
* delivered.
*/
#define WFR_ASIC_QSFP2_MASK							(WFR_ASIC + 0x0000000002A0)
#define WFR_ASIC_QSFP2_MASK_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP2_MASK_QSFP2_MASK_SHIFT					0
#define WFR_ASIC_QSFP2_MASK_QSFP2_MASK_MASK					0x1Full
#define WFR_ASIC_QSFP2_MASK_QSFP2_MASK_SMASK					0x1Full
/*
* Table #45 of 231_ASIC_Registers.xml - ASIC_QSFP2_STATUS
* This CSR can be used to read the QSFP2 status.
*/
#define WFR_ASIC_QSFP2_STATUS							(WFR_ASIC + 0x0000000002A8)
#define WFR_ASIC_QSFP2_STATUS_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP2_STATUS_QSFP2_STATUS_SHIFT				0
#define WFR_ASIC_QSFP2_STATUS_QSFP2_STATUS_MASK					0x1Full
#define WFR_ASIC_QSFP2_STATUS_QSFP2_STATUS_SMASK				0x1Full
/*
* Table #46 of 231_ASIC_Registers.xml - ASIC_QSFP2_CLEAR
* This CSR can be used to clear the QSFP2 status. Note that this field is not 
* marked with '/P', but this is fine since this register always reads as 
* 0.
*/
#define WFR_ASIC_QSFP2_CLEAR							(WFR_ASIC + 0x0000000002B0)
#define WFR_ASIC_QSFP2_CLEAR_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP2_CLEAR_QSFP2_CLEAR_SHIFT					0
#define WFR_ASIC_QSFP2_CLEAR_QSFP2_CLEAR_MASK					0x1Full
#define WFR_ASIC_QSFP2_CLEAR_QSFP2_CLEAR_SMASK					0x1Full
/*
* Table #47 of 231_ASIC_Registers.xml - ASIC_QSFP2_FORCE
* This CSR can be used to force the QSFP2 status. Note that this field is not 
* marked with '/P', but this is fine since this register always reads as 
* 0.
*/
#define WFR_ASIC_QSFP2_FORCE							(WFR_ASIC + 0x0000000002B8)
#define WFR_ASIC_QSFP2_FORCE_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_QSFP2_FORCE_QSFP2_FORCE_SHIFT					0
#define WFR_ASIC_QSFP2_FORCE_QSFP2_FORCE_MASK					0x1Full
#define WFR_ASIC_QSFP2_FORCE_QSFP2_FORCE_SMASK					0x1Full
/*
* Table #48 of 231_ASIC_Registers.xml - ASIC_EEP_CTL_STAT
* This CSR is the control and status register for the EEPROM/FLASH 
* interface.
*/
#define WFR_ASIC_EEP_CTL_STAT							(WFR_ASIC + 0x000000000300)
#define WFR_ASIC_EEP_CTL_STAT_RESETCSR						0x0000000000000200ull
#define WFR_ASIC_EEP_CTL_STAT_CTLR_STAT_SHIFT					31
#define WFR_ASIC_EEP_CTL_STAT_CTLR_STAT_MASK					0x1ull
#define WFR_ASIC_EEP_CTL_STAT_CTLR_STAT_SMASK					0x80000000ull
#define WFR_ASIC_EEP_CTL_STAT_RATE_SPI_SHIFT					8
#define WFR_ASIC_EEP_CTL_STAT_RATE_SPI_MASK					0x3ull
#define WFR_ASIC_EEP_CTL_STAT_RATE_SPI_SMASK					0x300ull
#define WFR_ASIC_EEP_CTL_STAT_ROM_BAR_ACC_SHIFT					7
#define WFR_ASIC_EEP_CTL_STAT_ROM_BAR_ACC_MASK					0x1ull
#define WFR_ASIC_EEP_CTL_STAT_ROM_BAR_ACC_SMASK					0x80ull
#define WFR_ASIC_EEP_CTL_STAT_CMD_WR_ERR_SHIFT					6
#define WFR_ASIC_EEP_CTL_STAT_CMD_WR_ERR_MASK					0x1ull
#define WFR_ASIC_EEP_CTL_STAT_CMD_WR_ERR_SMASK					0x40ull
#define WFR_ASIC_EEP_CTL_STAT_LST_DATA_WR_SHIFT					5
#define WFR_ASIC_EEP_CTL_STAT_LST_DATA_WR_MASK					0x1ull
#define WFR_ASIC_EEP_CTL_STAT_LST_DATA_WR_SMASK					0x20ull
#define WFR_ASIC_EEP_CTL_STAT_PAGE_MODE_SHIFT					4
#define WFR_ASIC_EEP_CTL_STAT_PAGE_MODE_MASK					0x1ull
#define WFR_ASIC_EEP_CTL_STAT_PAGE_MODE_SMASK					0x10ull
#define WFR_ASIC_EEP_CTL_STAT_BYTE_PROG_SHIFT					3
#define WFR_ASIC_EEP_CTL_STAT_BYTE_PROG_MASK					0x1ull
#define WFR_ASIC_EEP_CTL_STAT_BYTE_PROG_SMASK					0x8ull
#define WFR_ASIC_EEP_CTL_STAT_EP_RESET_SHIFT					2
#define WFR_ASIC_EEP_CTL_STAT_EP_RESET_MASK					0x1ull
#define WFR_ASIC_EEP_CTL_STAT_EP_RESET_SMASK					0x4ull
#define WFR_ASIC_EEP_CTL_STAT_EP_ACC_EN_SHIFT					0
#define WFR_ASIC_EEP_CTL_STAT_EP_ACC_EN_MASK					0x3ull
#define WFR_ASIC_EEP_CTL_STAT_EP_ACC_EN_SMASK					0x3ull
/*
* Table #49 of 231_ASIC_Registers.xml - ASIC_EEP_ADDR_CMD
* This CSR is the address and command register for the EEPROM/FLASH 
* interface.
*/
#define WFR_ASIC_EEP_ADDR_CMD							(WFR_ASIC + 0x000000000308)
#define WFR_ASIC_EEP_ADDR_CMD_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_EEP_ADDR_CMD_EP_CMD_SHIFT					24
#define WFR_ASIC_EEP_ADDR_CMD_EP_CMD_MASK					0xFFull
#define WFR_ASIC_EEP_ADDR_CMD_EP_CMD_SMASK					0xFF000000ull
#define WFR_ASIC_EEP_ADDR_CMD_EP_ADDR_SHIFT					0
#define WFR_ASIC_EEP_ADDR_CMD_EP_ADDR_MASK					0xFFFFFFull
#define WFR_ASIC_EEP_ADDR_CMD_EP_ADDR_SMASK					0xFFFFFFull
/*
* Table #50 of 231_ASIC_Registers.xml - ASIC_EEP_DATA
* This CSR is the read/write data register for the EEPROM/FLASH 
* interface.
*/
#define WFR_ASIC_EEP_DATA							(WFR_ASIC + 0x000000000310)
#define WFR_ASIC_EEP_DATA_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_EEP_DATA_EP_DATA_SHIFT						0
#define WFR_ASIC_EEP_DATA_EP_DATA_MASK						0xFFFFFFFFull
#define WFR_ASIC_EEP_DATA_EP_DATA_SMASK						0xFFFFFFFFull
/*
* Table #51 of 231_ASIC_Registers.xml - ASIC_MAN_EFUSE0
* This CSR provides RO access to the 4 kilobit MAN_EFUSE array using 64 x 64-bit 
* CSRs. The first 4 CSRs are specified at the field level, and the remaining 60 
* CSRs are specified as an array since the fields are reserved by the 
* manufacturing partner. More information is provided in #%%#Section 18.1, 
* #%%#'EFUSE'#%%#.
*/
#define WFR_ASIC_MAN_EFUSE0							(WFR_ASIC + 0x000000001000)
#define WFR_ASIC_MAN_EFUSE0_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_MAN_EFUSE0_EFUSE_MAN_INFO_SHIFT				5
#define WFR_ASIC_MAN_EFUSE0_EFUSE_MAN_INFO_MASK					0x3FFFFFFFFFFFFFull
#define WFR_ASIC_MAN_EFUSE0_EFUSE_MAN_INFO_SMASK				0x7FFFFFFFFFFFFE0ull
#define WFR_ASIC_MAN_EFUSE0_EFUSE_PRODUCT_BINNING_SHIFT				0
#define WFR_ASIC_MAN_EFUSE0_EFUSE_PRODUCT_BINNING_MASK				0x1Full
#define WFR_ASIC_MAN_EFUSE0_EFUSE_PRODUCT_BINNING_SMASK				0x1Full
/*
* Table #52 of 231_ASIC_Registers.xml - ASIC_MAN_EFUSE1
* This CSR provides RO access to the 4 kilobit MAN_EFUSE array using 64 x 64-bit 
* CSRs. The first 4 CSRs are specified at the field level, and the remaining 60 
* CSRs are specified as an array since the fields are reserved by the 
* manufacturing partner. More information is provided in #%%#Section 18.1, 
* #%%#'EFUSE'#%%#.
*/
#define WFR_ASIC_MAN_EFUSE1							(WFR_ASIC + 0x000000001008)
#define WFR_ASIC_MAN_EFUSE1_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_REI_SHIFT				48
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_REI_MASK				0x1ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_REI_SMASK				0x1000000000000ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_HFI1_DISABLE_SHIFT				47
#define WFR_ASIC_MAN_EFUSE1_EFUSE_HFI1_DISABLE_MASK				0x1ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_HFI1_DISABLE_SMASK				0x800000000000ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_HFI0_DISABLE_SHIFT				46
#define WFR_ASIC_MAN_EFUSE1_EFUSE_HFI0_DISABLE_MASK				0x1ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_HFI0_DISABLE_SMASK				0x400000000000ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_MBIST_CHECK_SHIFT			45
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_MBIST_CHECK_MASK			0x1ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_MBIST_CHECK_SMASK			0x200000000000ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_MBIST_SHIFT				44
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_MBIST_MASK				0x1ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_MBIST_SMASK				0x100000000000ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_OVER_RIDE_SHIFT			43
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_OVER_RIDE_MASK			0x1ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_OVER_RIDE_SMASK			0x80000000000ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_BURN_SHIFT				42
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_BURN_MASK				0x1ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_DISABLE_BURN_SMASK				0x40000000000ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_VOLTAGE_OFFSET_SHIFT				38
#define WFR_ASIC_MAN_EFUSE1_EFUSE_VOLTAGE_OFFSET_MASK				0xFull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_VOLTAGE_OFFSET_SMASK				0x3C000000000ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_OSCILLATOR_COUNT_ID_SHIFT			19
#define WFR_ASIC_MAN_EFUSE1_EFUSE_OSCILLATOR_COUNT_ID_MASK			0xFFFull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_OSCILLATOR_COUNT_ID_SMASK			0x7FF80000ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_PMRO_SETTING_SHIFT				17
#define WFR_ASIC_MAN_EFUSE1_EFUSE_PMRO_SETTING_MASK				0x3ull
#define WFR_ASIC_MAN_EFUSE1_EFUSE_PMRO_SETTING_SMASK				0x60000ull
/*
* Table #53 of 231_ASIC_Registers.xml - ASIC_MAN_EFUSE2
* This CSR provides RO access to the 4 kilobit MAN_EFUSE array using 64 x 64-bit 
* CSRs. The first 4 CSRs are specified at the field level, and the remaining 60 
* CSRs are specified as an array since the fields are reserved by the 
* manufacturing partner. More information is provided in #%%#Section 18.1, 
* #%%#'EFUSE'#%%#.
*/
#define WFR_ASIC_MAN_EFUSE2							(WFR_ASIC + 0x000000001010)
#define WFR_ASIC_MAN_EFUSE2_RESETCSR						0x0000000000000000ull
/*
* Table #54 of 231_ASIC_Registers.xml - ASIC_MAN_EFUSE3
* This CSR provides RO access to the 4 kilobit MAN_EFUSE array using 64 x 64-bit 
* CSRs. The first 4 CSRs are specified at the field level, and the remaining 60 
* CSRs are specified as an array since the fields are reserved by the 
* manufacturing partner. More information is provided in #%%#Section 18.1, 
* #%%#'EFUSE'#%%#.
*/
#define WFR_ASIC_MAN_EFUSE3							(WFR_ASIC + 0x000000001018)
#define WFR_ASIC_MAN_EFUSE3_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_MAN_EFUSE3_EFUSE_MAN_DATE_SHIFT				48
#define WFR_ASIC_MAN_EFUSE3_EFUSE_MAN_DATE_MASK					0xFFFFull
#define WFR_ASIC_MAN_EFUSE3_EFUSE_MAN_DATE_SMASK				0xFFFF000000000000ull
#define WFR_ASIC_MAN_EFUSE3_EFUSE_SERIAL_NUMBER_SHIFT				0
#define WFR_ASIC_MAN_EFUSE3_EFUSE_SERIAL_NUMBER_MASK				0xFFFFFFull
#define WFR_ASIC_MAN_EFUSE3_EFUSE_SERIAL_NUMBER_SMASK				0xFFFFFFull
/*
* Table #55 of 231_ASIC_Registers.xml - ASIC_MAN_EFUSE4TO63
* This CSR provides RO access to the 4 kilobit MAN_EFUSE array using 64 x 64-bit 
* CSRs. The first 4 CSRs are specified at the field level, and the remaining 60 
* CSRs are specified as an array since the fields are reserved by the 
* manufacturing partner. More information is provided in #%%#Section 18.1, 
* #%%#'EFUSE'#%%#.
*/
#define WFR_ASIC_MAN_EFUSE4TO63							(WFR_ASIC + 0x000000001020)
#define WFR_ASIC_MAN_EFUSE4TO63_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_MAN_EFUSE4TO63_MAN_EFUSE_SHIFT					0
#define WFR_ASIC_MAN_EFUSE4TO63_MAN_EFUSE_MASK					0xFFFFFFFFFFFFFFFFull
#define WFR_ASIC_MAN_EFUSE4TO63_MAN_EFUSE_SMASK					0xFFFFFFFFFFFFFFFFull
/*
* Table #56 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE
* This CSR provides RO access to the 4 kilobit WFR_EFUSE array using 64 x 64-bit 
* CSRs. The first 1 kilobit of this array has the same structure as the 16 
* WFR_EFUSE_REGS CSRs but contains the EFUSE values prior to application of 
* patches and overrides. Note that the reset value of 0x0 corresponds to no 
* fuses blown. The interpretation of the EFUSE values is described in 
* #%%#Section 18.1, #%%#'EFUSE'#%%#.
*/
#define WFR_ASIC_WFR_EFUSE							(WFR_ASIC + 0x000000001200)
#define WFR_ASIC_WFR_EFUSE_RESETCSR						0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_WFR_EFUSE_SHIFT					0
#define WFR_ASIC_WFR_EFUSE_WFR_EFUSE_MASK					0xFFFFFFFFFFFFFFFFull
#define WFR_ASIC_WFR_EFUSE_WFR_EFUSE_SMASK					0xFFFFFFFFFFFFFFFFull
/*
* Table #57 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS0
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. The patch table in the WFR_EFUSE is not accessible through 
* these CSRs. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS0						(WFR_ASIC + 0x000000001400)
#define WFR_ASIC_WFR_EFUSE_REGS0_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS0_EFUSE_GUID_SUB_UNIT_SHIFT			56
#define WFR_ASIC_WFR_EFUSE_REGS0_EFUSE_GUID_SUB_UNIT_MASK			0x7Full
#define WFR_ASIC_WFR_EFUSE_REGS0_EFUSE_GUID_SUB_UNIT_SMASK			0x7F00000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS0_EFUSE_GUID_TYPE_SHIFT				24
#define WFR_ASIC_WFR_EFUSE_REGS0_EFUSE_GUID_TYPE_MASK				0xFFull
#define WFR_ASIC_WFR_EFUSE_REGS0_EFUSE_GUID_TYPE_SMASK				0xFF000000ull
#define WFR_ASIC_WFR_EFUSE_REGS0_EFUSE_OUI_SHIFT				0
#define WFR_ASIC_WFR_EFUSE_REGS0_EFUSE_OUI_MASK					0xFFFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS0_EFUSE_OUI_SMASK				0xFFFFFFull
/*
* Table #58 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS1
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS1						(WFR_ASIC + 0x000000001408)
#define WFR_ASIC_WFR_EFUSE_REGS1_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_FIRMWARE_VALIDATION_ENABLE_SHIFT		60
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_FIRMWARE_VALIDATION_ENABLE_MASK		0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_FIRMWARE_VALIDATION_ENABLE_SMASK		0x1000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_ROM_BAR_HFI1_ENABLE_SHIFT		59
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_ROM_BAR_HFI1_ENABLE_MASK		0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_ROM_BAR_HFI1_ENABLE_SMASK		0x800000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_ROM_BAR_HFI0_ENABLE_SHIFT		58
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_ROM_BAR_HFI0_ENABLE_MASK		0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_ROM_BAR_HFI0_ENABLE_SMASK		0x400000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_CSR_JTAG_IF_DISABLE_SHIFT		51
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_CSR_JTAG_IF_DISABLE_MASK			0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_CSR_JTAG_IF_DISABLE_SMASK		0x8000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_DFD_ORANGE_UNLOCK_DISABLE_SHIFT		50
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_DFD_ORANGE_UNLOCK_DISABLE_MASK		0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_DFD_ORANGE_UNLOCK_DISABLE_SMASK		0x4000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_DFD_RED_UNLOCK_DISABLE_SHIFT		49
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_DFD_RED_UNLOCK_DISABLE_MASK		0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_DFD_RED_UNLOCK_DISABLE_SMASK		0x2000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_DFD_LOCK_ENABLE_SHIFT			48
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_DFD_LOCK_ENABLE_MASK			0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_DFD_LOCK_ENABLE_SMASK			0x1000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_SUBSYSTEM_ID_SHIFT			32
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_SUBSYSTEM_ID_MASK			0xFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_SUBSYSTEM_ID_SMASK			0xFFFF00000000ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_SUBSYSTEM_VENDOR_ID_SHIFT		16
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_SUBSYSTEM_VENDOR_ID_MASK		0xFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_SUBSYSTEM_VENDOR_ID_SMASK		0xFFFF0000ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D1_SUP_SHIFT				9
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D1_SUP_MASK				0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D1_SUP_SMASK				0x200ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_DEV_SPEC_INT_SHIFT			8
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_DEV_SPEC_INT_MASK			0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_DEV_SPEC_INT_SMASK			0x100ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_PM_VERSION_SHIFT			5
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_PM_VERSION_MASK			0x7ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_PM_VERSION_SMASK			0xE0ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_NO_SOFT_RESET_SHIFT			4
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_NO_SOFT_RESET_MASK			0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_NO_SOFT_RESET_SMASK			0x10ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D3_HOT_PM_MSG_SUP_SHIFT		3
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D3_HOT_PM_MSG_SUP_MASK		0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D3_HOT_PM_MSG_SUP_SMASK		0x8ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D1_PM_MSG_SUP_SHIFT			2
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D1_PM_MSG_SUP_MASK			0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D1_PM_MSG_SUP_SMASK			0x4ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D0_PM_MSG_SUP_SHIFT			1
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D0_PM_MSG_SUP_MASK			0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS1_EFUSE_PCI_D0_PM_MSG_SUP_SMASK			0x2ull
/*
* Table #59 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS2
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS2						(WFR_ASIC + 0x000000001410)
#define WFR_ASIC_WFR_EFUSE_REGS2_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS2_EFUSE_FIRMWARE_PUBLIC_KEY_HASH0_SHIFT		0
#define WFR_ASIC_WFR_EFUSE_REGS2_EFUSE_FIRMWARE_PUBLIC_KEY_HASH0_MASK		0xFFFFFFFFFFFFFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS2_EFUSE_FIRMWARE_PUBLIC_KEY_HASH0_SMASK		0xFFFFFFFFFFFFFFFFull
/*
* Table #60 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS3
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS3						(WFR_ASIC + 0x000000001418)
#define WFR_ASIC_WFR_EFUSE_REGS3_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS3_EFUSE_FIRMWARE_PUBLIC_KEY_HASH1_SHIFT		0
#define WFR_ASIC_WFR_EFUSE_REGS3_EFUSE_FIRMWARE_PUBLIC_KEY_HASH1_MASK		0xFFFFFFFFFFFFFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS3_EFUSE_FIRMWARE_PUBLIC_KEY_HASH1_SMASK		0xFFFFFFFFFFFFFFFFull
/*
* Table #61 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS4
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS4						(WFR_ASIC + 0x000000001420)
#define WFR_ASIC_WFR_EFUSE_REGS4_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS4_EFUSE_FIRMWARE_PUBLIC_KEY_HASH2_SHIFT		0
#define WFR_ASIC_WFR_EFUSE_REGS4_EFUSE_FIRMWARE_PUBLIC_KEY_HASH2_MASK		0xFFFFFFFFFFFFFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS4_EFUSE_FIRMWARE_PUBLIC_KEY_HASH2_SMASK		0xFFFFFFFFFFFFFFFFull
/*
* Table #62 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS5
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS5						(WFR_ASIC + 0x000000001428)
#define WFR_ASIC_WFR_EFUSE_REGS5_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS5_EFUSE_FIRMWARE_PUBLIC_KEY_HASH3_SHIFT		0
#define WFR_ASIC_WFR_EFUSE_REGS5_EFUSE_FIRMWARE_PUBLIC_KEY_HASH3_MASK		0xFFFFFFFFFFFFFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS5_EFUSE_FIRMWARE_PUBLIC_KEY_HASH3_SMASK		0xFFFFFFFFFFFFFFFFull
/*
* Table #63 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS6
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS6						(WFR_ASIC + 0x000000001430)
#define WFR_ASIC_WFR_EFUSE_REGS6_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_PATCH_VERSION_SHIFT			32
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_PATCH_VERSION_MASK			0xFFFFFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_PATCH_VERSION_SMASK			0xFFFFFFFF00000000ull
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_DC_HFI1_SHIFT				24
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_DC_HFI1_MASK				0xFFull
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_DC_HFI1_SMASK				0xFF000000ull
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_DC_HFI0_SHIFT				16
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_DC_HFI0_MASK				0xFFull
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_DC_HFI0_SMASK				0xFF0000ull
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_VERSION_SHIFT				0
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_VERSION_MASK				0xFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS6_EFUSE_VERSION_SMASK				0xFFFFull
/*
* Table #64 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS7
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS7						(WFR_ASIC + 0x000000001438)
#define WFR_ASIC_WFR_EFUSE_REGS7_RESETCSR					0x0000000000000000ull
/*
* Table #65 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS8
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS8						(WFR_ASIC + 0x000000001440)
#define WFR_ASIC_WFR_EFUSE_REGS8_RESETCSR					0x0000000000000000ull
/*
* Table #66 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS9
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS9						(WFR_ASIC + 0x000000001448)
#define WFR_ASIC_WFR_EFUSE_REGS9_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_CLASS_CODE_SHIFT			40
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_CLASS_CODE_MASK			0xFFFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_CLASS_CODE_SMASK			0xFFFFFF0000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_REVISION_ID_SHIFT			32
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_REVISION_ID_MASK			0xFFull
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_REVISION_ID_SMASK			0xFF00000000ull
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_DEVICE_ID_SHIFT			16
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_DEVICE_ID_MASK			0xFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_DEVICE_ID_SMASK			0xFFFF0000ull
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_VENDOR_ID_SHIFT			0
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_VENDOR_ID_MASK			0xFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS9_EFUSE_PCI_VENDOR_ID_SMASK			0xFFFFull
/*
* Table #67 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS10
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS10						(WFR_ASIC + 0x000000001450)
#define WFR_ASIC_WFR_EFUSE_REGS10_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_TARGET_LINK_SPD_SHIFT		56
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_TARGET_LINK_SPD_MASK		0xFull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_TARGET_LINK_SPD_SMASK		0xF00000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_CHIP_REV_MINOR_SHIFT			48
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_CHIP_REV_MINOR_MASK			0xFFull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_CHIP_REV_MINOR_SMASK			0xFF000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_PORT_NUM_SHIFT			40
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_PORT_NUM_MASK			0xFFull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_PORT_NUM_SMASK			0xFF0000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_CM_CLK_L1S_EXIT_LATENCY_SHIFT	35
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_CM_CLK_L1S_EXIT_LATENCY_MASK	0x7ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_CM_CLK_L1S_EXIT_LATENCY_SMASK	0x3800000000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ASYNC_L1S_EXIT_LATENCY_SHIFT	32
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ASYNC_L1S_EXIT_LATENCY_MASK	0x7ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ASYNC_L1S_EXIT_LATENCY_SMASK	0x700000000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_CM_CLK_L0S_EXIT_LATENCY_SHIFT	27
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_CM_CLK_L0S_EXIT_LATENCY_MASK	0x7ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_CM_CLK_L0S_EXIT_LATENCY_SMASK	0x38000000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ASYNC_L0S_EXIT_LATENCY_SHIFT	24
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ASYNC_L0S_EXIT_LATENCY_MASK	0x7ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ASYNC_L0S_EXIT_LATENCY_SMASK	0x7000000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ASPM_SUP_SHIFT			22
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ASPM_SUP_MASK			0x3ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ASPM_SUP_SMASK			0xC00000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_MAX_LINK_WIDTH_SHIFT		16
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_MAX_LINK_WIDTH_MASK		0x3Full
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_MAX_LINK_WIDTH_SMASK		0x3F0000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_CLK_PWR_MNGT_SHIFT			15
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_CLK_PWR_MNGT_MASK			0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_CLK_PWR_MNGT_SMASK			0x8000ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_MAX_LINK_SPD_SHIFT			11
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_MAX_LINK_SPD_MASK			0xFull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_MAX_LINK_SPD_SMASK			0x7800ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_L1S_ACCEPT_LATENCY_SHIFT		8
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_L1S_ACCEPT_LATENCY_MASK		0x7ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_L1S_ACCEPT_LATENCY_SMASK		0x700ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ROLE_BASED_ERR_RPT_SHIFT		7
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ROLE_BASED_ERR_RPT_MASK		0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_ROLE_BASED_ERR_RPT_SMASK		0x80ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_L0S_ACCEPT_LATENCY_SHIFT		4
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_L0S_ACCEPT_LATENCY_MASK		0x7ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_L0S_ACCEPT_LATENCY_SMASK		0x70ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_EXT_TAG_SUP_SHIFT			3
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_EXT_TAG_SUP_MASK			0x1ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_EXT_TAG_SUP_SMASK			0x8ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_MAX_PAYLOAD_SIZE_SUP_SHIFT		0
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_MAX_PAYLOAD_SIZE_SUP_MASK		0x7ull
#define WFR_ASIC_WFR_EFUSE_REGS10_EFUSE_PCIE_MAX_PAYLOAD_SIZE_SUP_SMASK		0x7ull
/*
* Table #68 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS11
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown. The intention is that the reserved EFUSE bits are set aside for any 
* additional programmable drive strengths that might be added later.
*/
#define WFR_ASIC_WFR_EFUSE_REGS11						(WFR_ASIC + 0x000000001458)
#define WFR_ASIC_WFR_EFUSE_REGS11_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS11_EFUSE_OUTPUT_PIN_DISABLE_SHIFT		48
#define WFR_ASIC_WFR_EFUSE_REGS11_EFUSE_OUTPUT_PIN_DISABLE_MASK			0xFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS11_EFUSE_OUTPUT_PIN_DISABLE_SMASK		0xFFFF000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS11_EFUSE_DRV_STR_SHIFT				0
#define WFR_ASIC_WFR_EFUSE_REGS11_EFUSE_DRV_STR_MASK				0x3FFFFFFFFull
#define WFR_ASIC_WFR_EFUSE_REGS11_EFUSE_DRV_STR_SMASK				0x3FFFFFFFFull
/*
* Table #69 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS12
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS12						(WFR_ASIC + 0x000000001460)
#define WFR_ASIC_WFR_EFUSE_REGS12_RESETCSR					0x0000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_SM_BUS_SA_SHIFT				61
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_SM_BUS_SA_MASK				0x7ull
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_SM_BUS_SA_SMASK				0xE000000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_TLO_LIMIT_SHIFT				48
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_TLO_LIMIT_MASK				0x7FFull
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_TLO_LIMIT_SMASK				0x7FF000000000000ull
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_THI_LIMIT_SHIFT				32
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_THI_LIMIT_MASK				0x7FFull
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_THI_LIMIT_SMASK				0x7FF00000000ull
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_TCRIT_LIMIT_SHIFT			16
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_TCRIT_LIMIT_MASK			0x7FFull
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_TCRIT_LIMIT_SMASK			0x7FF0000ull
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_THERM_IS_TRIP_SHIFT			0
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_THERM_IS_TRIP_MASK			0x7FFull
#define WFR_ASIC_WFR_EFUSE_REGS12_EFUSE_THERM_IS_TRIP_SMASK			0x7FFull
/*
* Table #70 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS13
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS13						(WFR_ASIC + 0x000000001468)
#define WFR_ASIC_WFR_EFUSE_REGS13_RESETCSR					0x0000000000000000ull
/*
* Table #71 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS14
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS14						(WFR_ASIC + 0x000000001470)
#define WFR_ASIC_WFR_EFUSE_REGS14_RESETCSR					0x0000000000000000ull
/*
* Table #72 of 231_ASIC_Registers.xml - ASIC_WFR_EFUSE_REGS15
* This CSR provides RO access to 64 bits of the 1 kilobit registers called 
* WFR_EFUSE_REGS. These are the WFR_EFUSE values after patching and over-rides 
* have been applied. Note that the reset value of 0x0 corresponds to no fuses 
* blown.
*/
#define WFR_ASIC_WFR_EFUSE_REGS15						(WFR_ASIC + 0x000000001478)
#define WFR_ASIC_WFR_EFUSE_REGS15_RESETCSR					0x0000000000000000ull

#endif 		/* DEF_WFR_ASIC_SW_DEF */
