/*
* Autogenerated by i_csrs.pl on Thu Sep 19 07:54:38 2013
* 
* i_csrs.pl Version 1.1 last modified on Thursday 9/19/13 07:54:33.
*/
/*
* Table #6 of 231_ASIC_Registers.xml - ASIC_CFG_SBUS_REQUEST
* SBus request interface (see SBus Master spec).
*/
#define WFR_ASIC_CFG_SBUS_REQUEST                           (WFR_ASIC + 0x000000000000)
#define WFR_ASIC_CFG_SBUS_REQUEST_RESETCSR                  0x0000000000000000ull
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_IN_SHIFT             32
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_IN_MASK              0xFFFFFFFFull
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_IN_SMASK             0xFFFFFFFF00000000ull
#define WFR_ASIC_CFG_SBUS_REQUEST_COMMAND_SHIFT             16
#define WFR_ASIC_CFG_SBUS_REQUEST_COMMAND_MASK              0xFFull
#define WFR_ASIC_CFG_SBUS_REQUEST_COMMAND_SMASK             0xFF0000ull
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_ADDR_SHIFT           8
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_ADDR_MASK            0xFFull
#define WFR_ASIC_CFG_SBUS_REQUEST_DATA_ADDR_SMASK           0xFF00ull
#define WFR_ASIC_CFG_SBUS_REQUEST_RECEIVER_ADDR_SHIFT       0
#define WFR_ASIC_CFG_SBUS_REQUEST_RECEIVER_ADDR_MASK        0xFFull
#define WFR_ASIC_CFG_SBUS_REQUEST_RECEIVER_ADDR_SMASK       0xFFull
/*
* Table #7 of 231_ASIC_Registers.xml - ASIC_CFG_SBUS_EXECUTE
* SBus request interface execution bits (see SBus Master spec).
*/
#define WFR_ASIC_CFG_SBUS_EXECUTE                           (WFR_ASIC + 0x000000000008)
#define WFR_ASIC_CFG_SBUS_EXECUTE_RESETCSR                  0x0000000000000000ull
#define WFR_ASIC_CFG_SBUS_EXECUTE_FAST_MODE_SHIFT           1
#define WFR_ASIC_CFG_SBUS_EXECUTE_FAST_MODE_MASK            0x1ull
#define WFR_ASIC_CFG_SBUS_EXECUTE_FAST_MODE_SMASK           0x2ull
#define WFR_ASIC_CFG_SBUS_EXECUTE_EXECUTE_SHIFT             0
#define WFR_ASIC_CFG_SBUS_EXECUTE_EXECUTE_MASK              0x1ull
#define WFR_ASIC_CFG_SBUS_EXECUTE_EXECUTE_SMASK             0x1ull
/*
* Table #8 of 231_ASIC_Registers.xml - ASIC_STS_SBUS_RESULT
* SBus request interface result data (see SBus Master spec).
*/
#define WFR_ASIC_STS_SBUS_RESULT                            (WFR_ASIC + 0x000000000010)
#define WFR_ASIC_STS_SBUS_RESULT_RESETCSR                   0x0000000000000000ull
#define WFR_ASIC_STS_SBUS_RESULT_DATA_OUT_SHIFT             32
#define WFR_ASIC_STS_SBUS_RESULT_DATA_OUT_MASK              0xFFFFFFFFull
#define WFR_ASIC_STS_SBUS_RESULT_DATA_OUT_SMASK             0xFFFFFFFF00000000ull
#define WFR_ASIC_STS_SBUS_RESULT_RESULT_CODE_SHIFT          2
#define WFR_ASIC_STS_SBUS_RESULT_RESULT_CODE_MASK           0xFFull
#define WFR_ASIC_STS_SBUS_RESULT_RESULT_CODE_SMASK          0x3FCull
#define WFR_ASIC_STS_SBUS_RESULT_RCV_DATA_VALID_SHIFT       1
#define WFR_ASIC_STS_SBUS_RESULT_RCV_DATA_VALID_MASK        0x1ull
#define WFR_ASIC_STS_SBUS_RESULT_RCV_DATA_VALID_SMASK       0x2ull
#define WFR_ASIC_STS_SBUS_RESULT_DONE_SHIFT                 0
#define WFR_ASIC_STS_SBUS_RESULT_DONE_MASK                  0x1ull
#define WFR_ASIC_STS_SBUS_RESULT_DONE_SMASK                 0x1ull
/*
* Table #9 of 231_ASIC_Registers.xml - ASIC_STS_SBUS_COUNTERS
* Counters for SBus EXECUTE and RCV_DATA_VALID bits. RCV_DATA_VALID could be 
* cleared before software gets a chance to read it, so these counters can be 
* used to determine if a transaction completed (when EXECUTE_CNT and 
* RCV_DATA_VALID_CNT match).
*/
#define WFR_ASIC_STS_SBUS_COUNTERS                          (WFR_ASIC + 0x000000000018)
#define WFR_ASIC_STS_SBUS_COUNTERS_RESETCSR                 0x0000000000000000ull
#define WFR_ASIC_STS_SBUS_COUNTERS_RCV_DATA_VALID_CNT_SHIFT 16
#define WFR_ASIC_STS_SBUS_COUNTERS_RCV_DATA_VALID_CNT_MASK  0xFFFFull
#define WFR_ASIC_STS_SBUS_COUNTERS_RCV_DATA_VALID_CNT_SMASK 0xFFFF0000ull
#define WFR_ASIC_STS_SBUS_COUNTERS_EXECUTE_CNT_SHIFT        0
#define WFR_ASIC_STS_SBUS_COUNTERS_EXECUTE_CNT_MASK         0xFFFFull
#define WFR_ASIC_STS_SBUS_COUNTERS_EXECUTE_CNT_SMASK        0xFFFFull
/*
* Table #10 of 231_ASIC_Registers.xml - ASIC_CFG_SCRATCH
* These scratch registers are read/write and for software use only. Since these 
* scratch CSRs are in the ASIC block, they are shared by both HFIs. This can be 
* potentially used by host software to communicate software-defined 
* status/control information between the host software for HFI0 and the host 
* software for HFI1.
*/
#define WFR_ASIC_CFG_SCRATCH                                (WFR_ASIC + 0x000000000020)
#define WFR_ASIC_CFG_SCRATCH_RESETCSR                       0x0000000000000000ull
#define WFR_ASIC_CFG_SCRATCH_SCRATCH_SHIFT                  0
#define WFR_ASIC_CFG_SCRATCH_SCRATCH_MASK                   0xFFFFFFFFFFFFFFFFull
#define WFR_ASIC_CFG_SCRATCH_SCRATCH_SMASK                  0xFFFFFFFFFFFFFFFFull
/*
* Table #11 of 231_ASIC_Registers.xml - ASIC_CFG_MUTEX
* This CSR provides state and a special atomic write behavior that can be used 
* by host software to implement a mutex. It provides a single mutual exclusion 
* lock that can be used to mediate two different 'users'.
*/
#define WFR_ASIC_CFG_MUTEX                                  (WFR_ASIC + 0x000000000040)
#define WFR_ASIC_CFG_MUTEX_RESETCSR                         0x0000000000000000ull
#define WFR_ASIC_CFG_MUTEX_USER1_SHIFT                      1
#define WFR_ASIC_CFG_MUTEX_USER1_MASK                       0x1ull
#define WFR_ASIC_CFG_MUTEX_USER1_SMASK                      0x2ull
#define WFR_ASIC_CFG_MUTEX_USER0_SHIFT                      0
#define WFR_ASIC_CFG_MUTEX_USER0_MASK                       0x1ull
#define WFR_ASIC_CFG_MUTEX_USER0_SMASK                      0x1ull
