//                                                                             
// File:       fxr_rx_e2e_csrs.h                                               
// Creator:    pvesvslx                                                        
// Time:       Tuesday Sep 16, 2014 [12:29:47 am]                              
//                                                                             
// Path:       /tmp/pvesvslx/nebulon_run/28430                                 
// Arguments:  /p/com/eda/denali/blueprint/3.7.4/Linux/blueprint -chdr -I      
//             /p/slx/eda/intel/nebulon/2.05_fdo/include -I                    
//             /p/slx/pvesv/fxr_autogen/fxr fxr_rx_e2e_csrs.rdl                
//                                                                             
// Sources:    /tmp/pvesvslx/nebulon_run/28430/lib_udp.rdl                     
//             /tmp/pvesvslx/nebulon_run/28430/fxr_rx_e2e_csrs.rdlh            
//             /tmp/pvesvslx/nebulon_run/28430/fxr_rx_e2e_csrs.rdl             
//             /p/com/eda/intel/nebulon/2.05p1/generators/generator_common.pm  
//             /p/com/eda/intel/nebulon/2.05p1/generators/chdr.pm              
//                                                                             
// Blueprint:   3.7.4 (Tue Jun 23 00:17:01 PDT 2009)                           
// Machine:    scci56217                                                       
// OS:         Linux 2.6.16.60-0.58.1.3835.0.PTF.638363-smp                    
// Description:                                                                
//                                                                             
//Receive E2E address map                                                      
//                                                                             
// Copyright (C) 2014 Denali Software Inc.  All rights reserved                
// THIS FILE IS AUTOMATICALLY GENERATED BY DENALI BLUEPRINT, DO NOT EDIT       
//                                                                             



// rxe2e_psn_base_addr_tc0_p0 desc:  Host memory base address of psn state for TC0, port 0.
typedef volatile union {
    struct {
        uint64_t  Reserved_2_0         :   3;    //  Reserved
        uint64_t  address              :  51;    //  Host Memory Base Address
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_psn_base_addr_tc0_p0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_psn_base_addr_tc0_p1 desc:  Host memory base address of psn state for TC0, port 1.
typedef volatile union {
    struct {
        uint64_t  Reserved_2_0         :   3;    //  Reserved
        uint64_t  address              :  51;    //  Host Memory Base Address
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_psn_base_addr_tc0_p1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_psn_base_addr_tc1_p0 desc:  Host memory base address of psn state for TC1, port 0.
typedef volatile union {
    struct {
        uint64_t  Reserved_2_0         :   3;    //  Reserved
        uint64_t  address              :  51;    //  Host Memory Base Address
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_psn_base_addr_tc1_p0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_psn_base_addr_tc1_p1 desc:  Host memory base address of psn state for TC1, port 1.
typedef volatile union {
    struct {
        uint64_t  Reserved_2_0         :   3;    //  Reserved
        uint64_t  address              :  51;    //  Host Memory Base Address
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_psn_base_addr_tc1_p1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_psn_base_addr_tc2_p0 desc:  Host memory base address of psn state for TC2, port 0.
typedef volatile union {
    struct {
        uint64_t  Reserved_2_0         :   3;    //  Reserved
        uint64_t  address              :  51;    //  Host Memory Base Address
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_psn_base_addr_tc2_p0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_psn_base_addr_tc2_p1 desc:  Host memory base address of psn state for TC2, port 1.
typedef volatile union {
    struct {
        uint64_t  Reserved_2_0         :   3;    //  Reserved
        uint64_t  address              :  51;    //  Host Memory Base Address
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_psn_base_addr_tc2_p1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_psn_base_addr_tc3_p0 desc:  Host memory base address of psn state for TC3, port 0.
typedef volatile union {
    struct {
        uint64_t  Reserved_2_0         :   3;    //  Reserved
        uint64_t  address              :  51;    //  Host Memory Base Address
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_psn_base_addr_tc3_p0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_psn_base_addr_tc3_p1 desc:  Host memory base address of psn state for TC3, port 1.
typedef volatile union {
    struct {
        uint64_t  Reserved_2_0         :   3;    //  Reserved
        uint64_t  address              :  51;    //  Host Memory Base Address
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_psn_base_addr_tc3_p1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_valid_tc_slid_port desc:  Describes max slid per port, vallid TC's per port and whether to use
// port in PSN state lookup..
typedef volatile union {
    struct {
        uint64_t  max_slid_p0          :  24;    //  Port 0 max valid slid,
                                                 // incoming packets with slid >
                                                 // than this are dropped
        uint64_t  tc_valid_p0          :   4;    //  Port 0 TC valid bits, 1 bit
                                                 // per TC, invalid incoming TC
                                                 // packets are dropped
        uint64_t  max_slid_p1          :  24;    //  Port 1 max valid slid,
                                                 // incoming packets with slid >
                                                 // than this are dropped
        uint64_t  tc_valid_p1          :   4;    //  Port 1 TC valid bits, 1 bit
                                                 // per TC, invalid incoming TC
                                                 // packets are dropped
        uint64_t  use_port_in_psn_state :   1;    //  if 1, incoming linkmux port
                                                 // is part of the psn connection
                                                 // state lookup well as what is
                                                 // sent to OTR and RXHP along
                                                 // with the header flits. if 0,
                                                 // incoming linkmux port is
                                                 // forced to 0 for both psn state
                                                 // lookup as well as what is sent
                                                 // to OTR and RXHP along with the
                                                 // header flits.
        uint64_t  Reserved_63_57       :   7;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_valid_tc_slid_port_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_special_ack_ctl desc:  MC0 Special Ack Control. Periodically, a special ack is sent carrying
// the oldest expected unordered psn for source OTR to use in flow
// control. The special_ack_rate_code controls the frequency of these
// special acks. Note that a special nack is also sent if a packet was
// unscorable due to no big scoreboards available or psn offset from
// expected unordered psn is > big scoreboard size.
typedef volatile union {
    struct {
        uint64_t  small_special_ack_rate_code :   3;    //  see big_special_ack_rate_code
        uint64_t  small_max_psn_dist   :  11;    //  Max PSN distance from
                                                 // expected unordered PSN that
                                                 // OTR is allowed to transmit
                                                 // before going into flow
                                                 // control. This is sent in the
                                                 // special ack when the
                                                 // connection is not currently
                                                 // using a big scoreboard and a
                                                 // big scoreboard is not
                                                 // available.
        uint64_t  big_special_ack_rate_code :   3;    //  Formula for when to do a
                                                 // special ack:
                                                 // special_ack_rate[7:0] = 2 **
                                                 // special_ack_rate_code;
                                                 // special_ack_mask[7:0] =
                                                 // -special_ack_rate;
                                                 // do_special_ack =
                                                 // (shift_amt[9:0] +
                                                 // (expected_psn[7:0] &
                                                 // ~special_ack_mask[7:0])) >=
                                                 // special_ack_rate[7:0]; if all
                                                 // unordered packets arrived in
                                                 // order, the special ack rate
                                                 // would be every (2 **
                                                 // special_ack_rate_code)
                                                 // packets.
        uint64_t  big_max_psn_dist     :  11;    //  Max PSN distance from
                                                 // expected unordered PSN that
                                                 // OTR is allowed to transmit
                                                 // before going into flow
                                                 // control. This is sent in the
                                                 // special ack when the
                                                 // connection is either currently
                                                 // using a big scoreboard or a
                                                 // big scoreboard is available.
        uint64_t  Reserved_63_28       :  36;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_special_ack_ctl_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_cnt_cam desc:  This table is used to determine how many MC0 32B header flits to send
// to RXHP. If the following holds true for a packet:
typedef volatile union {
    struct {
        uint64_t  cnt_m1               :   3;    //  Number of header flits to
                                                 // send to RXHP - 1
        uint64_t  hd_mask              :   1;    //  hd mask (1 bits are don't
                                                 // care)
        uint64_t  l4_mask              :   8;    //  l4 mask (1 bits are don't
                                                 // care)
        uint64_t  l2_mask              :   2;    //  l2 mask (1 bits are don't
                                                 // care)
        uint64_t  hd                   :   1;    //  hd matching
        uint64_t  l4                   :   8;    //  l4 matching
        uint64_t  l2                   :   2;    //  l2 matching
        uint64_t  Reserved_63_25       :  39;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_cnt_cam_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_error_input_mbe desc: 
typedef volatile union {
    struct {
        uint64_t  syndrome             :   8;    //  Syndrome of last MBE
        uint64_t  address              :   3;    //  Address of last MBE
        uint64_t  qword                :   2;    //  QWord position of the last
                                                 // MBE
        uint64_t  tc                   :   2;    //  Traffic Class of the last MBE
        uint64_t  mc                   :   1;    //  Message Class of the last MBE
        uint64_t  cnt                  :   8;    //  Saturating counter of MBE's
                                                 // from all sources
        uint64_t  Reserved_63_24       :  40;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_error_input_mbe_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_error_psn_cache_data_mbe desc:  PSN Cache Data MBE Error register.
typedef volatile union {
    struct {
        uint64_t  syndrome             :   8;    //  Syndrome of last MBE
        uint64_t  address              :   3;    //  Address of last MBE
        uint64_t  cnt                  :   8;    //  Saturating counter of PSN
                                                 // Cache Data MBE's
        uint64_t  Reserved_63_19       :  45;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_error_psn_cache_data_mbe_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_error_psn_cache_tag_mbe desc:  PSN Cache Tag MBE Error register.
typedef volatile union {
    struct {
        uint64_t  syndrome             :   8;    //  Syndrome of last MBE
        uint64_t  way                  :   4;    //  Way of the last MBE
        uint64_t  address              :  11;    //  Address of last MBE
        uint64_t  cnt                  :   8;    //  Saturating counter of PSN
                                                 // Cache Tag MBE's
        uint64_t  Reserved_63_31       :  33;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_error_psn_cache_tag_mbe_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_error_big_scoreboard_mbe desc:  Big Scoreboard MBE Error register.
typedef volatile union {
    struct {
        uint64_t  syndrome             :   8;    //  Syndrome of last MBE
        uint64_t  address              :  10;    //  Address of last MBE
        uint64_t  qword                :  16;    //  QWord of the last MBE
        uint64_t  cnt                  :   8;    //  Saturating counter of
                                                 // Scoreboard MBE's
        uint64_t  Reserved_63_42       :  22;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_error_big_scoreboard_mbe_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_unordered_psn_offset_bin_size desc:  Unordered PSN Offset bin size.
typedef volatile union {
    struct {
        uint64_t  bin_size             :   4;    //  unordered psn offset 0: bin
                                                 // size = 16 1: bin size = 32
                                                 // 2: bin size = 64 3: bin size
                                                 // = 128 >3: bin size = 256
        uint64_t  Reserved_63_4        :  60;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_unordered_psn_offset_bin_size_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_unordered_offset desc:  Unordered PSN Offset bin size.
typedef volatile union {
    struct {
        uint64_t  cntr_index           :  54;    //  based on
                                                 // rxe2e_unordered_psn_offset_bin_size,
                                                 // the unordered psn offset from
                                                 // the expected unordered psn is
                                                 // calculated and divided by
                                                 // rxe2e_unordered_psn_offset_bin_size.
                                                 // The residual will form an
                                                 // index, 0:7, which selects one
                                                 // of the 9
                                                 // rxe2e_perf_unordered_offset
                                                 // counters to increment.
                                                 // Residuals > 7 will all go into
                                                 // bucket 8. This is to assess
                                                 // how out of order unordered
                                                 // packets get under various
                                                 // system sizes/packet size
                                                 // scenarios.
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_unordered_offset_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_perf_unavailable_big_scoreboard desc:  Count of the number of times the big scoreboard was unavailable.
typedef volatile union {
    struct {
        uint64_t  count                :  54;    //  count of times where big
                                                 // scoreboard was needed but
                                                 // unavailable.
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_perf_unavailable_big_scoreboard_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_perf_beyond_big_scoreboard desc:  Count of the number of times the offset was beyond big scoreboard
// size.
typedef volatile union {
    struct {
        uint64_t  count                :  54;    //  count of times where offset
                                                 // was beyond big scoreboard
                                                 // size.
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_perf_beyond_big_scoreboard_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_perf_repeat_packet desc:  Count of times where packet was already scored. this includes ordered
// and unordered.
typedef volatile union {
    struct {
        uint64_t  count                :  54;    //  count of times where packet
                                                 // was already scored. this
                                                 // includes ordered and
                                                 // unordered.
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_perf_repeat_packet_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_perf_psn_cache_fill desc:  Count of times where psn cache needed a fill.
typedef volatile union {
    struct {
        uint64_t  count                :  54;    //  count of times where psn
                                                 // cache needed a fill.
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_perf_psn_cache_fill_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_perf_crc_fail desc:  Count of times where packet CRC was bad, includes both MC0 and MC1
typedef volatile union {
    struct {
        uint64_t  count                :  54;    //  count of times where packet
                                                 // CRC was bad, includes both MC0
                                                 // and MC1
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_perf_crc_fail_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_mask_ctrl_0 desc:  Flit number, tail and valid for the MC0 Flit Mask. There are five of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_mask_ctrl_0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_mask_data_0 desc:  Data for the masks for mask/match counting of input packets. There
// are five sets of 4 registers. Each set has the above control register
// in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the mask

    };
    uint64_t                         val;
} rxe2e_mc0_flit_mask_data_0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_mask_ctrl_1 desc:  Flit number, tail and valid for the MC0 Flit Mask. There are five of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_mask_ctrl_1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_mask_data_1 desc:  Data for the masks for mask/match counting of input packets. There
// are five sets of 4 registers. Each set has the above control register
// in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the mask

    };
    uint64_t                         val;
} rxe2e_mc0_flit_mask_data_1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_mask_ctrl_2 desc:  Flit number, tail and valid for the MC0 Flit Mask. There are five of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_mask_ctrl_2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_mask_data_2 desc:  Data for the masks for mask/match counting of input packets. There
// are five sets of 4 registers. Each set has the above control register
// in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the mask

    };
    uint64_t                         val;
} rxe2e_mc0_flit_mask_data_2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_mask_ctrl_3 desc:  Flit number, tail and valid for the MC0 Flit Mask. There are five of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_mask_ctrl_3_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_mask_data_3 desc:  Data for the masks for mask/match counting of input packets. There
// are five sets of 4 registers. Each set has the above control register
// in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the mask

    };
    uint64_t                         val;
} rxe2e_mc0_flit_mask_data_3_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_mask_ctrl_4 desc:  Flit number, tail and valid for the MC0 Flit Mask. There are five of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_mask_ctrl_4_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_mask_data_4 desc:  Data for the masks for mask/match counting of input packets. There
// are five sets of 4 registers. Each set has the above control register
// in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the mask

    };
    uint64_t                         val;
} rxe2e_mc0_flit_mask_data_4_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_match_ctrl_0 desc:  Flit number, tail and valid for the MC0 Flit Match. There are five of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_match_ctrl_0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_match_data_0 desc:  Data for the match for mask/match counting of input packets. There
// are five sets of 4 registers. Each set has the above control register
// in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the match

    };
    uint64_t                         val;
} rxe2e_mc0_flit_match_data_0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_match_ctrl_1 desc:  Flit number, tail and valid for the MC0 Flit Match. There are five of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_match_ctrl_1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_match_data_1 desc:  Data for the match for mask/match counting of input packets. There
// are five sets of 4 registers. Each set has the above control register
// in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the match

    };
    uint64_t                         val;
} rxe2e_mc0_flit_match_data_1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_match_ctrl_2 desc:  Flit number, tail and valid for the MC0 Flit Match. There are five of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_match_ctrl_2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_match_data_2 desc:  Data for the match for mask/match counting of input packets. There
// are five sets of 4 registers. Each set has the above control register
// in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the match

    };
    uint64_t                         val;
} rxe2e_mc0_flit_match_data_2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_match_ctrl_3 desc:  Flit number, tail and valid for the MC0 Flit Match. There are five of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_match_ctrl_3_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_match_data_3 desc:  Data for the match for mask/match counting of input packets. There
// are five sets of 4 registers. Each set has the above control register
// in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the match

    };
    uint64_t                         val;
} rxe2e_mc0_flit_match_data_3_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_match_ctrl_4 desc:  Flit number, tail and valid for the MC0 Flit Match. There are five of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc0_flit_match_ctrl_4_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc0_flit_match_data_4 desc:  Data for the match for mask/match counting of input packets. There
// are five sets of 4 registers. Each set has the above control register
// in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the match

    };
    uint64_t                         val;
} rxe2e_mc0_flit_match_data_4_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_perf_mc0_trigger_ctrl desc:  Sub triggers for the performance counters.
typedef volatile union {
    struct {
        uint64_t  trig_and             :   4;    //  1 bits select which
                                                 // subtriggers to and for forming
                                                 // triggers
        uint64_t  trig_or              :   3;    //  1 bits select which
                                                 // subtriggers to or for forming
                                                 // triggers
        uint64_t  trig_polarity        :   3;    //  polarity of subtriggers for
                                                 // forming triggers
        uint64_t  end_force            :   1;    //  1 forces subtriggers true
                                                 // only when strt_condition is
                                                 // true and no persistence unless
                                                 // strt_condition persists
        uint64_t  end_and              :   5;    //  1 bits select which
                                                 // conditions to and for forming
                                                 // subtrigger
        uint64_t  end_or               :   5;    //  1 bits select which
                                                 // conditions to and for forming
                                                 // subtrigger
        uint64_t  end_polarity         :   5;    //  polarity of subtriggers for
                                                 // forming triggers
        uint64_t  strt_and             :   5;    //  1 bits select which
                                                 // conditions to and for forming
                                                 // subtrigger
        uint64_t  strt_or              :   5;    //  1 bits select which
                                                 // conditions to and for forming
                                                 // subtrigger
        uint64_t  strt_polarity        :   5;    //  polarity of subtriggers for
                                                 // forming triggers
        uint64_t  Reserved_63_41       :  23;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_perf_mc0_trigger_ctrl_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_perf_mc0_prog_pkt_cntr desc:  Allows 4 completely programmable counters of mc0 packets/flits..
typedef volatile union {
    struct {
        uint64_t  counter              :  54;    //  Counter of MC0 packets/flits
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_perf_mc0_prog_pkt_cntr_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_mask_ctrl_0 desc:  Flit number, tail and valid for the MC1 Flit Mask. There are three of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc1_flit_mask_ctrl_0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_mask_data_0 desc:  Data for the masks for mask/match counting of input packets. There
// are three sets of 4 registers. Each set has the above the control
// register in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the mask

    };
    uint64_t                         val;
} rxe2e_mc1_flit_mask_data_0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_mask_ctrl_1 desc:  Flit number, tail and valid for the MC1 Flit Mask. There are three of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc1_flit_mask_ctrl_1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_mask_data_1 desc:  Data for the masks for mask/match counting of input packets. There
// are three sets of 4 registers. Each set has the above the control
// register in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the mask

    };
    uint64_t                         val;
} rxe2e_mc1_flit_mask_data_1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_mask_ctrl_2 desc:  Flit number, tail and valid for the MC1 Flit Mask. There are three of
// these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc1_flit_mask_ctrl_2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_mask_data_2 desc:  Data for the masks for mask/match counting of input packets. There
// are three sets of 4 registers. Each set has the above the control
// register in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the mask

    };
    uint64_t                         val;
} rxe2e_mc1_flit_mask_data_2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_match_ctrl_0 desc:  Flit number, tail and valid for the MC1 Flit Match. There are three
// of these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc1_flit_match_ctrl_0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_match_data_0 desc:  Data for the match for mask/match counting of input packets. There
// are three sets of 4 registers. Each set has the above the control
// register in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the match

    };
    uint64_t                         val;
} rxe2e_mc1_flit_match_data_0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_match_ctrl_1 desc:  Flit number, tail and valid for the MC1 Flit Match. There are three
// of these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc1_flit_match_ctrl_1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_match_data_1 desc:  Data for the match for mask/match counting of input packets. There
// are three sets of 4 registers. Each set has the above the control
// register in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the match

    };
    uint64_t                         val;
} rxe2e_mc1_flit_match_data_1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_match_ctrl_2 desc:  Flit number, tail and valid for the MC1 Flit Match. There are three
// of these registers spaced by 40 bytes.
typedef volatile union {
    struct {
        uint64_t  tail                 :   1;    //  tail flit
        uint64_t  valid                :   1;    //  flit is valid
        uint64_t  flit_number          :   3;    //  saturating flit number of a
                                                 // packet flit
        uint64_t  Reserved_63_5        :  59;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_mc1_flit_match_ctrl_2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_mc1_flit_match_data_2 desc:  Data for the match for mask/match counting of input packets. There
// are three sets of 4 registers. Each set has the above the control
// register in front of it.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  data for the match

    };
    uint64_t                         val;
} rxe2e_mc1_flit_match_data_2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_perf_mc1_trigger_ctrl desc:  Sub triggers for the performance counters.
typedef volatile union {
    struct {
        uint64_t  trig_and             :   3;    //  1 bits select which
                                                 // subtriggers to and for forming
                                                 // triggers
        uint64_t  trig_or              :   3;    //  1 bits select which
                                                 // subtriggers to or for forming
                                                 // triggers
        uint64_t  trig_polarity        :   3;    //  polarity of subtriggers for
                                                 // forming triggers
        uint64_t  end_force            :   1;    //  1 forces subtriggers true
                                                 // only when strt_condition is
                                                 // true and no persistence unless
                                                 // strt_condition persists
        uint64_t  end_and              :   3;    //  1 bits select which
                                                 // conditions to and for forming
                                                 // subtrigger
        uint64_t  end_or               :   3;    //  1 bits select which
                                                 // conditions to and for forming
                                                 // subtrigger
        uint64_t  end_polarity         :   3;    //  polarity of subtriggers for
                                                 // forming triggers
        uint64_t  strt_and             :   3;    //  1 bits select which
                                                 // conditions to and for forming
                                                 // subtrigger
        uint64_t  strt_or              :   3;    //  1 bits select which
                                                 // conditions to and for forming
                                                 // subtrigger
        uint64_t  strt_polarity        :   3;    //  polarity of subtriggers for
                                                 // forming triggers
        uint64_t  Reserved_63_28       :  36;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_perf_mc1_trigger_ctrl_t;

// --------------------------------------------------------------------------------------------------------------------------------

// rxe2e_perf_mc1_prog_pkt_cntr desc:  Allows 4 completely programmable counters of mc1 packets/flits..
typedef volatile union {
    struct {
        uint64_t  counter              :  54;    //  Counter of MC1 packets/flits
        uint64_t  Reserved_63_54       :  10;    //  Reserved

    };
    uint64_t                         val;
} rxe2e_perf_mc1_prog_pkt_cntr_t;

// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    rxe2e_psn_base_addr_tc0_p0_t rxe2e_psn_base_addr_tc0_p0; // offset 4'h0, width 64
    rxe2e_psn_base_addr_tc0_p1_t rxe2e_psn_base_addr_tc0_p1; // offset 4'h8, width 64
    rxe2e_psn_base_addr_tc1_p0_t rxe2e_psn_base_addr_tc1_p0; // offset 8'h10, width 64
    rxe2e_psn_base_addr_tc1_p1_t rxe2e_psn_base_addr_tc1_p1; // offset 8'h18, width 64
    rxe2e_psn_base_addr_tc2_p0_t rxe2e_psn_base_addr_tc2_p0; // offset 8'h20, width 64
    rxe2e_psn_base_addr_tc2_p1_t rxe2e_psn_base_addr_tc2_p1; // offset 8'h28, width 64
    rxe2e_psn_base_addr_tc3_p0_t rxe2e_psn_base_addr_tc3_p0; // offset 8'h30, width 64
    rxe2e_psn_base_addr_tc3_p1_t rxe2e_psn_base_addr_tc3_p1; // offset 8'h38, width 64
    rxe2e_valid_tc_slid_port_t rxe2e_valid_tc_slid_port; // offset 8'h40, width 64
    rxe2e_mc0_special_ack_ctl_t rxe2e_mc0_special_ack_ctl; // offset 8'h48, width 64
    rxe2e_mc0_flit_cnt_cam_t   rxe2e_mc0_flit_cnt_cam[32]; // offset 8'h50, width 64
    rxe2e_error_input_mbe_t    rxe2e_error_input_mbe; // offset 12'h150, width 64
    rxe2e_error_psn_cache_data_mbe_t rxe2e_error_psn_cache_data_mbe; // offset 12'h158, width 64
    rxe2e_error_psn_cache_tag_mbe_t rxe2e_error_psn_cache_tag_mbe; // offset 12'h160, width 64
    rxe2e_error_big_scoreboard_mbe_t rxe2e_error_big_scoreboard_mbe; // offset 12'h168, width 64
    rxe2e_unordered_psn_offset_bin_size_t rxe2e_unordered_psn_offset_bin_size; // offset 12'h170, width 64
    rxe2e_unordered_offset_t   rxe2e_unordered_offset[9]; // offset 12'h178, width 64
    rxe2e_perf_unavailable_big_scoreboard_t rxe2e_perf_unavailable_big_scoreboard; // offset 12'h1C0, width 64
    rxe2e_perf_beyond_big_scoreboard_t rxe2e_perf_beyond_big_scoreboard; // offset 12'h1C8, width 64
    rxe2e_perf_repeat_packet_t rxe2e_perf_repeat_packet; // offset 12'h1D0, width 64
    rxe2e_perf_psn_cache_fill_t rxe2e_perf_psn_cache_fill; // offset 12'h1D8, width 64
    rxe2e_perf_crc_fail_t      rxe2e_perf_crc_fail; // offset 12'h1E0, width 64
    rxe2e_mc0_flit_mask_ctrl_0_t rxe2e_mc0_flit_mask_ctrl_0; // offset 12'h1E8, width 64
    rxe2e_mc0_flit_mask_data_0_t rxe2e_mc0_flit_mask_data_0[4]; // offset 12'h1F0, width 64
    rxe2e_mc0_flit_mask_ctrl_1_t rxe2e_mc0_flit_mask_ctrl_1; // offset 12'h210, width 64
    rxe2e_mc0_flit_mask_data_1_t rxe2e_mc0_flit_mask_data_1[4]; // offset 12'h218, width 64
    rxe2e_mc0_flit_mask_ctrl_2_t rxe2e_mc0_flit_mask_ctrl_2; // offset 12'h238, width 64
    rxe2e_mc0_flit_mask_data_2_t rxe2e_mc0_flit_mask_data_2[4]; // offset 12'h240, width 64
    rxe2e_mc0_flit_mask_ctrl_3_t rxe2e_mc0_flit_mask_ctrl_3; // offset 12'h260, width 64
    rxe2e_mc0_flit_mask_data_3_t rxe2e_mc0_flit_mask_data_3[4]; // offset 12'h268, width 64
    rxe2e_mc0_flit_mask_ctrl_4_t rxe2e_mc0_flit_mask_ctrl_4; // offset 12'h288, width 64
    rxe2e_mc0_flit_mask_data_4_t rxe2e_mc0_flit_mask_data_4[4]; // offset 12'h290, width 64
    rxe2e_mc0_flit_match_ctrl_0_t rxe2e_mc0_flit_match_ctrl_0; // offset 12'h2B0, width 64
    rxe2e_mc0_flit_match_data_0_t rxe2e_mc0_flit_match_data_0[4]; // offset 12'h2B8, width 64
    rxe2e_mc0_flit_match_ctrl_1_t rxe2e_mc0_flit_match_ctrl_1; // offset 12'h2D8, width 64
    rxe2e_mc0_flit_match_data_1_t rxe2e_mc0_flit_match_data_1[4]; // offset 12'h2E0, width 64
    rxe2e_mc0_flit_match_ctrl_2_t rxe2e_mc0_flit_match_ctrl_2; // offset 12'h300, width 64
    rxe2e_mc0_flit_match_data_2_t rxe2e_mc0_flit_match_data_2[4]; // offset 12'h308, width 64
    rxe2e_mc0_flit_match_ctrl_3_t rxe2e_mc0_flit_match_ctrl_3; // offset 12'h328, width 64
    rxe2e_mc0_flit_match_data_3_t rxe2e_mc0_flit_match_data_3[4]; // offset 12'h330, width 64
    rxe2e_mc0_flit_match_ctrl_4_t rxe2e_mc0_flit_match_ctrl_4; // offset 12'h350, width 64
    rxe2e_mc0_flit_match_data_4_t rxe2e_mc0_flit_match_data_4[4]; // offset 12'h358, width 64
    rxe2e_perf_mc0_trigger_ctrl_t rxe2e_perf_mc0_trigger_ctrl[5]; // offset 12'h378, width 64
    rxe2e_perf_mc0_prog_pkt_cntr_t rxe2e_perf_mc0_prog_pkt_cntr[4]; // offset 12'h3A0, width 64
    rxe2e_mc1_flit_mask_ctrl_0_t rxe2e_mc1_flit_mask_ctrl_0; // offset 12'h3C0, width 64
    rxe2e_mc1_flit_mask_data_0_t rxe2e_mc1_flit_mask_data_0[4]; // offset 12'h3C8, width 64
    rxe2e_mc1_flit_mask_ctrl_1_t rxe2e_mc1_flit_mask_ctrl_1; // offset 12'h3E8, width 64
    rxe2e_mc1_flit_mask_data_1_t rxe2e_mc1_flit_mask_data_1[4]; // offset 12'h3F0, width 64
    rxe2e_mc1_flit_mask_ctrl_2_t rxe2e_mc1_flit_mask_ctrl_2; // offset 12'h410, width 64
    rxe2e_mc1_flit_mask_data_2_t rxe2e_mc1_flit_mask_data_2[4]; // offset 12'h418, width 64
    rxe2e_mc1_flit_match_ctrl_0_t rxe2e_mc1_flit_match_ctrl_0; // offset 12'h438, width 64
    rxe2e_mc1_flit_match_data_0_t rxe2e_mc1_flit_match_data_0[4]; // offset 12'h440, width 64
    rxe2e_mc1_flit_match_ctrl_1_t rxe2e_mc1_flit_match_ctrl_1; // offset 12'h460, width 64
    rxe2e_mc1_flit_match_data_1_t rxe2e_mc1_flit_match_data_1[4]; // offset 12'h468, width 64
    rxe2e_mc1_flit_match_ctrl_2_t rxe2e_mc1_flit_match_ctrl_2; // offset 12'h488, width 64
    rxe2e_mc1_flit_match_data_2_t rxe2e_mc1_flit_match_data_2[4]; // offset 12'h490, width 64
    rxe2e_perf_mc1_trigger_ctrl_t rxe2e_perf_mc1_trigger_ctrl[3]; // offset 12'h4B0, width 64
    rxe2e_perf_mc1_prog_pkt_cntr_t rxe2e_perf_mc1_prog_pkt_cntr[3]; // offset 12'h4C8, width 64
} fxr_rx_e2e_csrs_t;                             // size:  12'h4E0
