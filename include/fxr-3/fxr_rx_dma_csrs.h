//                                                                             
// File:       fxr_rx_dma_csrs.h                                               
// Creator:    pvesvslx                                                        
// Time:       Tuesday Sep 16, 2014 [12:29:45 am]                              
//                                                                             
// Path:       /tmp/pvesvslx/nebulon_run/28430                                 
// Arguments:  /p/com/eda/denali/blueprint/3.7.4/Linux/blueprint -chdr -I      
//             /p/slx/eda/intel/nebulon/2.05_fdo/include -I                    
//             /p/slx/pvesv/fxr_autogen/fxr fxr_rx_dma_csrs.rdl                
//                                                                             
// Sources:    /tmp/pvesvslx/nebulon_run/28430/lib_udp.rdl                     
//             /tmp/pvesvslx/nebulon_run/28430/fxr_rx_dma_csrs.rdl             
//             /tmp/pvesvslx/nebulon_run/28430/fxr_rx_dma_csrs.rdlh            
//             /p/com/eda/intel/nebulon/2.05p1/generators/generator_common.pm  
//             /p/com/eda/intel/nebulon/2.05p1/generators/chdr.pm              
//                                                                             
// Blueprint:   3.7.4 (Tue Jun 23 00:17:01 PDT 2009)                           
// Machine:    scci56217                                                       
// OS:         Linux 2.6.16.60-0.58.1.3835.0.PTF.638363-smp                    
// Description:                                                                
//                                                                             
//Receive DMA address map                                                      
//                                                                             
// Copyright (C) 2014 Denali Software Inc.  All rights reserved                
// THIS FILE IS AUTOMATICALLY GENERATED BY DENALI BLUEPRINT, DO NOT EDIT       
//                                                                             



// RX_DMA_CFG_BUFFER desc:  This is an RX DMA configuration CSR. It allows adjusting the depth
// and initialization method of the DMA buffers.
typedef volatile union {
    struct {
        uint64_t  disable_auto_init    :   1;    //  Disable the automatic
                                                 // initialization of the linked
                                                 // list. Software initialization
                                                 // is required if disabled.
        uint64_t  depth_limit          :   8;    //  Limit the depth of the linked
                                                 // lists, along with the depth of
                                                 // the buffer used.
        uint64_t  RSVD_0               :  55;    // Nebulon auto filled RSVD [63:9]

    };
    uint64_t                         val;
} RX_DMA_CFG_BUFFER_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_CONTROL desc:  This is an RX DMA configuration CSR. It controls general settings for
// the RxDMA.
typedef volatile union {
    struct {
        uint64_t  ext_ack              :   1;    //  Acknowledgement type select.
                                                 // 0=Use Basic Ack, 1=Use
                                                 // Extended Ack
        uint64_t  Reserved_7_1         :   7;    //  Unused
        uint64_t  mc0_credits          :   7;    //  Credits given to the HP's for
                                                 // the MC0 DMA Cmds. There are
                                                 // physically 2 for each TC (5
                                                 // TC's) and a pool of 32 for a
                                                 // max value of 42.
        uint64_t  Reserved_15          :   1;    //  Unused
        uint64_t  mc1_credits          :   4;    //  Credits given to the OTR for
                                                 // the MC1 DMA Cmds. There are
                                                 // physically 2 for each TC and a
                                                 // pool of 4 for a max value of
                                                 // 12.
        uint64_t  Reserved_63_20       :  44;    //  Unused

    };
    uint64_t                         val;
} RX_DMA_CFG_CONTROL_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_CH_CTRL desc:  This RX DMA configuration CSR holds the Cache Hints to be used for
// the various HI commands. These are muxed to the HI for the specified
// command. Hints are 00=Non-Allocating, Non-Temporal,
// 01=Non-Allocating, Temporal LLC, 10=Allocating L1, Non-Temporal L1,
// 11=Allocating L1, Temporal L1.
typedef volatile union {
    struct {
        uint64_t  ch_put               :   2;    //  Cache Hints for a put
        uint64_t  ch_get               :   2;    //  Cache Hints for a get
        uint64_t  ch_get_small         :   2;    //  Cache Hints for a small get
        uint64_t  ch_eq                :   2;    //  Cache Hints for an Event
                                                 // Queue put
        uint64_t  ch_ct                :   2;    //  Cache Hints for a Counting
                                                 // Event Atomic
        uint64_t  ch_vector            :   2;    //  Cache Hints for a Vector
                                                 // Atomic
        uint64_t  ch_iovec             :   2;    //  Cache Hints for an IOVEC put
        uint64_t  Reserved_63_14       :  50;    //  Unused

    };
    uint64_t                         val;
} RX_DMA_CFG_CH_CTRL_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_BW_SHAPE_MAP desc:  This is an RX DMA configuration CSR. It allows adjusting the priority
// selection of MCTC buffer access to the HIArb bus. There are 8
// bandwidth meters (buckets) implemented in the RxDMA. They are mapped
// by default to one meter per MCTC. However, this mapping register
// would allow them to be mapped differently such that two could share a
// single bucket if needed..
typedef volatile union {
    struct {
        uint64_t  mctc0                :   4;    //  Bucket used by MC=0 TC = 0
        uint64_t  mctc1                :   4;    //  Bucket used by MC=0 TC = 1
        uint64_t  mctc2                :   4;    //  Bucket used by MC=0 TC = 2
        uint64_t  mctc3                :   4;    //  Bucket used by MC=0 TC = 3
        uint64_t  mctc4                :   4;    //  Bucket used by MC=1 TC = 0
        uint64_t  mctc5                :   4;    //  Bucket used by MC=1 TC = 1
        uint64_t  mctc6                :   4;    //  Bucket used by MC=1 TC = 2
        uint64_t  mctc7                :   4;    //  Bucket used by MC=1 TC = 3
        uint64_t  Reserved_63_32       :  32;    //  Reserved

    };
    uint64_t                         val;
} RX_DMA_CFG_BW_SHAPE_MAP_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_BW_SHAPE_B0 desc:  This is an RX DMA configuration CSR for a bucket used in the
// bandwidth shaping. The Bucket and the Leak_Counter values are
// controlled by Hardware, and therefore Read Only. Software can control
// the Slice which control the percentage of bandwith allowed through
// this bucket and Overage_Limit which controls how many flits are
// allowed before blocking is possible.
typedef volatile union {
    struct {
        uint64_t  overage_limit        :  16;    //  Limit to number of flits of
                                                 // data before blocking. Default
                                                 // blocks at 16K extra flits.
        uint64_t  slice                :   8;    //  Slice allocated to this
                                                 // bucket. Default takes 8 cycles
                                                 // to roll.
        uint64_t  Reserved_31_24       :   8;    //  Unused
        uint64_t  bucket               :  16;    //  Bucket Counter Value
        uint64_t  leak_counter         :   6;    //  Leak Counter Value
        uint64_t  Reserved_63_54       :  10;    //  Unused

    };
    uint64_t                         val;
} RX_DMA_CFG_BW_SHAPE_B0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_BW_SHAPE_B1 desc:  This is an RX DMA configuration CSR for a bucket used in the
// bandwidth shaping. The Bucket and the Leak_Counter values are
// controlled by Hardware, and therefore Read Only. Software can control
// the Slice which control the percentage of bandwith allowed through
// this bucket and Overage_Limit which controls how many flits are
// allowed before blocking is possible.
typedef volatile union {
    struct {
        uint64_t  overage_limit        :  16;    //  Limit to number of flits of
                                                 // data before blocking. Default
                                                 // blocks at 16K extra flits.
        uint64_t  slice                :   8;    //  Slice allocated to this
                                                 // bucket. Default takes 8 cycles
                                                 // to roll.
        uint64_t  Reserved_31_24       :   8;    //  Unused
        uint64_t  bucket               :  16;    //  Bucket Counter Value
        uint64_t  leak_counter         :   6;    //  Leak Counter Value
        uint64_t  Reserved_63_54       :  10;    //  Unused

    };
    uint64_t                         val;
} RX_DMA_CFG_BW_SHAPE_B1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_BW_SHAPE_B2 desc:  This is an RX DMA configuration CSR for a bucket used in the
// bandwidth shaping. The Bucket and the Leak_Counter values are
// controlled by Hardware, and therefore Read Only. Software can control
// the Slice which control the percentage of bandwith allowed through
// this bucket and Overage_Limit which controls how many flits are
// allowed before blocking is possible.
typedef volatile union {
    struct {
        uint64_t  overage_limit        :  16;    //  Limit to number of flits of
                                                 // data before blocking. Default
                                                 // blocks at 16K extra flits.
        uint64_t  slice                :   8;    //  Slice allocated to this
                                                 // bucket. Default takes 8 cycles
                                                 // to roll.
        uint64_t  Reserved_31_24       :   8;    //  Unused
        uint64_t  bucket               :  16;    //  Bucket Counter Value
        uint64_t  leak_counter         :   6;    //  Leak Counter Value
        uint64_t  Reserved_63_54       :  10;    //  Unused

    };
    uint64_t                         val;
} RX_DMA_CFG_BW_SHAPE_B2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_BW_SHAPE_B3 desc:  This is an RX DMA configuration CSR for a bucket used in the
// bandwidth shaping. The Bucket and the Leak_Counter values are
// controlled by Hardware, and therefore Read Only. Software can control
// the Slice which control the percentage of bandwith allowed through
// this bucket and Overage_Limit which controls how many flits are
// allowed before blocking is possible.
typedef volatile union {
    struct {
        uint64_t  overage_limit        :  16;    //  Limit to number of flits of
                                                 // data before blocking. Default
                                                 // blocks at 16K extra flits.
        uint64_t  slice                :   8;    //  Slice allocated to this
                                                 // bucket. Default takes 8 cycles
                                                 // to roll.
        uint64_t  Reserved_31_24       :   8;    //  Unused
        uint64_t  bucket               :  16;    //  Bucket Counter Value
        uint64_t  leak_counter         :   6;    //  Leak Counter Value
        uint64_t  Reserved_63_54       :  10;    //  Unused

    };
    uint64_t                         val;
} RX_DMA_CFG_BW_SHAPE_B3_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_BW_SHAPE_B4 desc:  This is an RX DMA configuration CSR for a bucket used in the
// bandwidth shaping. The Bucket and the Leak_Counter values are
// controlled by Hardware, and therefore Read Only. Software can control
// the Slice which control the percentage of bandwith allowed through
// this bucket and Overage_Limit which controls how many flits are
// allowed before blocking is possible.
typedef volatile union {
    struct {
        uint64_t  overage_limit        :  16;    //  Limit to number of flits of
                                                 // data before blocking. Default
                                                 // blocks at 16K extra flits.
        uint64_t  slice                :   8;    //  Slice allocated to this
                                                 // bucket. Default takes 8 cycles
                                                 // to roll.
        uint64_t  Reserved_31_24       :   8;    //  Unused
        uint64_t  bucket               :  16;    //  Bucket Counter Value
        uint64_t  leak_counter         :   6;    //  Leak Counter Value
        uint64_t  Reserved_63_54       :  10;    //  Unused

    };
    uint64_t                         val;
} RX_DMA_CFG_BW_SHAPE_B4_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_BW_SHAPE_B5 desc:  This is an RX DMA configuration CSR for a bucket used in the
// bandwidth shaping. The Bucket and the Leak_Counter values are
// controlled by Hardware, and therefore Read Only. Software can control
// the Slice which control the percentage of bandwith allowed through
// this bucket and Overage_Limit which controls how many flits are
// allowed before blocking is possible.
typedef volatile union {
    struct {
        uint64_t  overage_limit        :  16;    //  Limit to number of flits of
                                                 // data before blocking. Default
                                                 // blocks at 16K extra flits.
        uint64_t  slice                :   8;    //  Slice allocated to this
                                                 // bucket. Default takes 8 cycles
                                                 // to roll.
        uint64_t  Reserved_31_24       :   8;    //  Unused
        uint64_t  bucket               :  16;    //  Bucket Counter Value
        uint64_t  leak_counter         :   6;    //  Leak Counter Value
        uint64_t  Reserved_63_54       :  10;    //  Unused

    };
    uint64_t                         val;
} RX_DMA_CFG_BW_SHAPE_B5_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_BW_SHAPE_B6 desc:  This is an RX DMA configuration CSR for a bucket used in the
// bandwidth shaping. The Bucket and the Leak_Counter values are
// controlled by Hardware, and therefore Read Only. Software can control
// the Slice which control the percentage of bandwith allowed through
// this bucket and Overage_Limit which controls how many flits are
// allowed before blocking is possible.
typedef volatile union {
    struct {
        uint64_t  overage_limit        :  16;    //  Limit to number of flits of
                                                 // data before blocking. Default
                                                 // blocks at 16K extra flits.
        uint64_t  slice                :   8;    //  Slice allocated to this
                                                 // bucket. Default takes 8 cycles
                                                 // to roll.
        uint64_t  Reserved_31_24       :   8;    //  Unused
        uint64_t  bucket               :  16;    //  Bucket Counter Value
        uint64_t  leak_counter         :   6;    //  Leak Counter Value
        uint64_t  Reserved_63_54       :  10;    //  Unused

    };
    uint64_t                         val;
} RX_DMA_CFG_BW_SHAPE_B6_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_CFG_BW_SHAPE_B7 desc:  This is an RX DMA configuration CSR for a bucket used in the
// bandwidth shaping. The Bucket and the Leak_Counter values are
// controlled by Hardware, and therefore Read Only. Software can control
// the Slice which control the percentage of bandwith allowed through
// this bucket and Overage_Limit which controls how many flits are
// allowed before blocking is possible.
typedef volatile union {
    struct {
        uint64_t  overage_limit        :  16;    //  Limit to number of flits of
                                                 // data before blocking. Default
                                                 // blocks at 16K extra flits.
        uint64_t  slice                :   8;    //  Slice allocated to this
                                                 // bucket. Default takes 8 cycles
                                                 // to roll.
        uint64_t  Reserved_31_24       :   8;    //  Unused
        uint64_t  bucket               :  16;    //  Bucket Counter Value
        uint64_t  leak_counter         :   6;    //  Leak Counter Value
        uint64_t  Reserved_63_54       :  10;    //  Unused

    };
    uint64_t                         val;
} RX_DMA_CFG_BW_SHAPE_B7_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_LINKED_LIST desc:  This is an RX DMA debug CSR. It allows access to all of the linked
// list DMA queue arrays. These arrays can not be written to during
// normal operation. This register is for debug use, and for
// initialization of the linked list if needed. There is an automatic
// initialization function built in that can be disabled.
typedef volatile union {
    struct {
        uint64_t  data                 :   8;    //  Data to be written, or data
                                                 // read from access
        uint64_t  parity               :   1;    //  Parity for data being
                                                 // written, or parity read from
                                                 // access
        uint64_t  Reserved_63_9        :  55;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_LINKED_LIST_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_TAIL_LIST desc:  This is an RX DMA debug CSR. It allows access to all of the Tail
// list. These arrays can not be written to during normal operation.
// This register is for debug use only.
typedef volatile union {
    struct {
        uint64_t  full                 :   1;    //  1=tail location contains 64
                                                 // bytes, 0=tail location
                                                 // contains 32 bytes.
        uint64_t  tail                 :   8;    //  Tail pointer for the head
                                                 // location accessed.
        uint64_t  parity               :   1;    //  Parity for data being
                                                 // written, or parity read from
                                                 // access
        uint64_t  Reserved_63_10       :  54;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_TAIL_LIST_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_ADDR desc:  This is an RX DMA debug CSR. It allows indirect access to all of the
// DMA buffer arrays. These arrays can not be written to during normal
// operation. This register is for debug use only. Note that this
// register is 288 bits wide. The data for the read or write to this
// register is contained in the next five CSR's
typedef volatile union {
    struct {
        uint64_t  address              :  49;    //  Address of DMA Buffer
                                                 // location to be accessed
        uint64_t  mctc                 :   3;    //  Message Class and Traffic
                                                 // Class being accessed {MC,TC}
        uint64_t  payload_regs         :   8;    //  Constant indicating number of
                                                 // payload registers used for the
                                                 // data.
        uint64_t  Reserved_61_60       :   2;    // 
        uint64_t  write                :   1;    //  0=Read, 1=Write
        uint64_t  Valid                :   1;    //  Set by Software to start
                                                 // command, cleared by Hardware
                                                 // when complete

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_ADDR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_DATA0 desc:  This is an RX DMA debug CSR. This is the data for bits [63:0] of the
// RX DMA buffer being accessed with the RX_DMA_DBG_BUFFER_ADDR
// register. The data from this CSR is written to the DMA buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_DATA0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_DATA1 desc:  This is an RX DMA debug CSR. This is the data for bits [127:64] of
// the RX DMA buffer being accessed with the RX_DMA_DBG_BUFFER_ADDR
// register. The data from this CSR is written to the DMA buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_DATA1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_DATA2 desc:  This is an RX DMA debug CSR. This is the data for bits [191:128] of
// the RX DMA buffer being accessed with the RX_DMA_DBG_BUFFER_ADDR
// register. The data from this CSR is written to the DMA buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_DATA2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_DATA3 desc:  This is an RX DMA debug CSR. This is the data for bits [255:192] of
// the RX DMA buffer being accessed with the RX_DMA_DBG_BUFFER_ADDR
// register. The data from this CSR is written to the DMA buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_DATA3_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_BUFFER_DATA4 desc:  This is an RX DMA debug CSR. This is the data for bits [287:256] of
// the RX DMA buffer being accessed with the RX_DMA_DBG_BUFFER_ADDR
// register. The data from this CSR is written to the DMA buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active. This data is the ECC codes for
// the stored data in the buffer.
typedef volatile union {
    struct {
        uint64_t  Data                 :  32;    // 
        uint64_t  Reserved_63_32       :  32;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_BUFFER_DATA4_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_CMD_POOL_ADDR desc:  This is an RX DMA debug CSR. It allows indirect access to both of the
// DMA comand pool arrays. These arrays can not be written to during
// normal operation. This register is for debug use only. Note that this
// register is 284 bits wide. The data for the read or write to this
// register is contained in the next five CSR's. Max address for MC0 is
// 0x1f and the max address for MC1 is 0x3. Anything over that will
// mirror the lower address range data.
typedef volatile union {
    struct {
        uint64_t  address              :  51;    //  Address of DMA Buffer
                                                 // location to be accessed
        uint64_t  mc                   :   1;    //  Message Class pool being
                                                 // accessed.
        uint64_t  payload_regs         :   8;    //  Constant indicating number of
                                                 // payload registers used for the
                                                 // data.
        uint64_t  Reserved_61_60       :   2;    // 
        uint64_t  write                :   1;    //  0=Read, 1=Write
        uint64_t  Valid                :   1;    //  Set by Software to start
                                                 // command, cleared by Hardware
                                                 // when complete

    };
    uint64_t                         val;
} RX_DMA_DBG_CMD_POOL_ADDR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_CMD_POOL_DATA0 desc:  This is an RX DMA debug CSR. This is the data for bits [63:0] of the
// RX DMA CommandPool being accessed with the RX_DMA_DBG_CMD_POOL_ADDR
// register. The data from this CSR is written to the buffer if the
// write bit is active in that CSR, or this data will contain the read
// data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_CMD_POOL_DATA0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_CMD_POOL_DATA1 desc:  This is an RX DMA debug CSR. This is the data for bits [127:64] of
// the RX DMA CommandPool being accessed with the
// RX_DMA_DBG_CMD_POOL_ADDR register. The data from this CSR is written
// to the buffer if the write bit is active in that CSR, or this data
// will contain the read data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_CMD_POOL_DATA1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_CMD_POOL_DATA2 desc:  This is an RX DMA debug CSR. This is the data for bits [191:128] of
// the RX DMA CommandPool being accessed with the
// RX_DMA_DBG_CMD_POOL_ADDR register. The data from this CSR is written
// to the buffer if the write bit is active in that CSR, or this data
// will contain the read data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_CMD_POOL_DATA2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_CMD_POOL_DATA3 desc:  This is an RX DMA debug CSR. This is the data for bits [255:192] of
// the RX DMA CommandPool being accessed with the
// RX_DMA_DBG_CMD_POOL_ADDR register. The data from this CSR is written
// to the buffer if the write bit is active in that CSR, or this data
// will contain the read data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_CMD_POOL_DATA3_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_CMD_POOL_DATA4 desc:  This is an RX DMA debug CSR. This is the data for bits [283:256] of
// the RX DMA CommandPool being accessed with the
// RX_DMA_DBG_CMD_POOL_ADDR register. The data from this CSR is written
// to the buffer if the write bit is active in that CSR, or this data
// will contain the read data if the write bit is not active.
typedef volatile union {
    struct {
        uint64_t  Data                 :  64;    // 

    };
    uint64_t                         val;
} RX_DMA_DBG_CMD_POOL_DATA4_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_DBG_WAR_BUF desc:  This is an RX DMA debug CSR. It allows access to the WARRead Buffer.
// This array can not be written to during normal operation. This
// register is for debug use only.
typedef volatile union {
    struct {
        uint64_t  data                 :  64;    //  Data read or to be written to
                                                 // the WAR Read Buffer.

    };
    uint64_t                         val;
} RX_DMA_DBG_WAR_BUF_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_ERR_BUF_MBE desc:  MBE error counts from the DMA buffers in each Message Class. All
// errors from a single message class are accumulated into one register.
typedef volatile union {
    struct {
        uint64_t  syndrome             :   8;    //  Syndrome of last MBE
        uint64_t  address              :   9;    //  Address of last MBE
        uint64_t  qword                :   2;    //  QWord position of last MBE
        uint64_t  tc                   :   2;    //  Traffic class of last MBE
        uint64_t  mbe_cnt              :   8;    //  Saturating counter of MBE's
                                                 // from all sources
        uint64_t  Reserved_63_29       :  35;    //  Reserved

    };
    uint64_t                         val;
} RX_DMA_ERR_BUF_MBE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_ERR_LL_PARITY desc:  Parity error counts from the RX DMA Linked List arrays in each
// Message Class. All errors from a single message class are accumulated
// into one register.
typedef volatile union {
    struct {
        uint64_t  tc0_parity           :   1;    //  Parity error found in Linked
                                                 // List of TC0
        uint64_t  address_tc0          :   8;    //  Address of last Linked List
                                                 // Parity Error in TC0
        uint64_t  tc1_parity           :   1;    //  Parity error found in Linked
                                                 // List of TC1
        uint64_t  address_tc1          :   8;    //  Address of last Linked List
                                                 // Parity Error in TC1
        uint64_t  tc2_parity           :   1;    //  Parity error found in Linked
                                                 // List of TC2
        uint64_t  address_tc2          :   8;    //  Address of last Linked List
                                                 // Parity Error in TC2
        uint64_t  tc3_parity           :   1;    //  Parity error found in Linked
                                                 // List of TC3
        uint64_t  address_tc3          :   8;    //  Address of last Linked List
                                                 // Parity Error in TC3
        uint64_t  error_cnt            :   8;    //  Saturating counter of parity
                                                 // errors from all sources
        uint64_t  Reserved_63_44       :  20;    //  Reserved

    };
    uint64_t                         val;
} RX_DMA_ERR_LL_PARITY_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_ERR_TAIL_PARITY desc:  Parity error counts from the RX DMA Tail List arrays in each Message
// Class. All errors from a single message class are accumulated into
// one register.
typedef volatile union {
    struct {
        uint64_t  tc0_parity           :   1;    //  Parity error found in Tail
                                                 // Array of TC0
        uint64_t  address_tc0          :   8;    //  Address of last Tail Array
                                                 // Parity Error in TC0
        uint64_t  tc1_parity           :   1;    //  Parity error found in Tail
                                                 // Array of TC1
        uint64_t  address_tc1          :   8;    //  Address of last Tail Array
                                                 // Parity Error in TC1
        uint64_t  tc2_parity           :   1;    //  Parity error found in Tail
                                                 // Array of TC2
        uint64_t  address_tc2          :   8;    //  Address of last Tail Array
                                                 // Parity Error in TC2
        uint64_t  tc3_parity           :   1;    //  Parity error found in Tail
                                                 // Array of TC3
        uint64_t  address_tc3          :   8;    //  Address of last Tail Array
                                                 // Parity Error in TC3
        uint64_t  error_cnt            :   8;    //  Saturating counter of parity
                                                 // errors from all sources
        uint64_t  Reserved_63_44       :  20;    //  Reserved

    };
    uint64_t                         val;
} RX_DMA_ERR_TAIL_PARITY_t;

// --------------------------------------------------------------------------------------------------------------------------------

// RX_DMA_ERR_GENERAL desc:  Other errors not related to the above parity and error correction
// code errors.
typedef volatile union {
    struct {
        uint64_t  mc0_drop_cmd         :   1;    //  The MC0 Pool was full, and
                                                 // the HP still sent a command.
        uint64_t  mc1_drop_cmd         :   1;    //  The MC1 Pool was full, and
                                                 // the OTR still sent a command.
        uint64_t  Reserved_7_2         :   6;    //  Unused
        uint64_t  e2e_data_lost        :   8;    //  DMA Buffer was full but E2E
                                                 // send another flit of data. One
                                                 // bit for each MCTC {MC,TC}.
        uint64_t  Reserved_63_16       :  48;    //  Reserved

    };
    uint64_t                         val;
} RX_DMA_ERR_GENERAL_t;

// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    RX_DMA_CFG_BUFFER_t        RX_DMA_CFG_BUFFER[8]; // offset 4'h0, width 64
    RX_DMA_CFG_CONTROL_t       RX_DMA_CFG_CONTROL; // offset 8'h40, width 64
    RX_DMA_CFG_CH_CTRL_t       RX_DMA_CFG_CH_CTRL; // offset 8'h48, width 64
    RX_DMA_CFG_BW_SHAPE_MAP_t  RX_DMA_CFG_BW_SHAPE_MAP; // offset 8'h50, width 64
    RX_DMA_CFG_BW_SHAPE_B0_t   RX_DMA_CFG_BW_SHAPE_B0; // offset 8'h58, width 64
    RX_DMA_CFG_BW_SHAPE_B1_t   RX_DMA_CFG_BW_SHAPE_B1; // offset 8'h60, width 64
    RX_DMA_CFG_BW_SHAPE_B2_t   RX_DMA_CFG_BW_SHAPE_B2; // offset 8'h68, width 64
    RX_DMA_CFG_BW_SHAPE_B3_t   RX_DMA_CFG_BW_SHAPE_B3; // offset 8'h70, width 64
    RX_DMA_CFG_BW_SHAPE_B4_t   RX_DMA_CFG_BW_SHAPE_B4; // offset 8'h78, width 64
    RX_DMA_CFG_BW_SHAPE_B5_t   RX_DMA_CFG_BW_SHAPE_B5; // offset 8'h80, width 64
    RX_DMA_CFG_BW_SHAPE_B6_t   RX_DMA_CFG_BW_SHAPE_B6; // offset 8'h88, width 64
    RX_DMA_CFG_BW_SHAPE_B7_t   RX_DMA_CFG_BW_SHAPE_B7; // offset 8'h90, width 64
    RX_DMA_DBG_LINKED_LIST_t   RX_DMA_DBG_LINKED_LIST[256]; // offset 12'h800, width 64
    RX_DMA_DBG_TAIL_LIST_t     RX_DMA_DBG_TAIL_LIST[256]; // offset 16'h1000, width 64
    RX_DMA_DBG_BUFFER_ADDR_t   RX_DMA_DBG_BUFFER_ADDR; // offset 16'h1800, width 64
    RX_DMA_DBG_BUFFER_DATA0_t  RX_DMA_DBG_BUFFER_DATA0; // offset 16'h1808, width 64
    RX_DMA_DBG_BUFFER_DATA1_t  RX_DMA_DBG_BUFFER_DATA1; // offset 16'h1810, width 64
    RX_DMA_DBG_BUFFER_DATA2_t  RX_DMA_DBG_BUFFER_DATA2; // offset 16'h1818, width 64
    RX_DMA_DBG_BUFFER_DATA3_t  RX_DMA_DBG_BUFFER_DATA3; // offset 16'h1820, width 64
    RX_DMA_DBG_BUFFER_DATA4_t  RX_DMA_DBG_BUFFER_DATA4; // offset 16'h1828, width 64
    RX_DMA_DBG_CMD_POOL_ADDR_t RX_DMA_DBG_CMD_POOL_ADDR; // offset 16'h1830, width 64
    RX_DMA_DBG_CMD_POOL_DATA0_t RX_DMA_DBG_CMD_POOL_DATA0; // offset 16'h1838, width 64
    RX_DMA_DBG_CMD_POOL_DATA1_t RX_DMA_DBG_CMD_POOL_DATA1; // offset 16'h1840, width 64
    RX_DMA_DBG_CMD_POOL_DATA2_t RX_DMA_DBG_CMD_POOL_DATA2; // offset 16'h1848, width 64
    RX_DMA_DBG_CMD_POOL_DATA3_t RX_DMA_DBG_CMD_POOL_DATA3; // offset 16'h1850, width 64
    RX_DMA_DBG_CMD_POOL_DATA4_t RX_DMA_DBG_CMD_POOL_DATA4; // offset 16'h1858, width 64
    RX_DMA_DBG_WAR_BUF_t       RX_DMA_DBG_WAR_BUF[2048]; // offset 16'h4000, width 64
    RX_DMA_ERR_BUF_MBE_t       RX_DMA_ERR_BUF_MBE[2]; // offset 16'h8000, width 64
    RX_DMA_ERR_LL_PARITY_t     RX_DMA_ERR_LL_PARITY[2]; // offset 16'h8010, width 64
    RX_DMA_ERR_TAIL_PARITY_t   RX_DMA_ERR_TAIL_PARITY[2]; // offset 16'h8020, width 64
    RX_DMA_ERR_GENERAL_t       RX_DMA_ERR_GENERAL; // offset 16'h8030, width 64
} fxr_rx_dma_csrs_t;                             // size:  16'h8038
