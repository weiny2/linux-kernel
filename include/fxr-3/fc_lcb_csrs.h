//                                                                             
// File:       fc_lcb_csrs.h                                                   
// Creator:    pvesvslx                                                        
// Time:       Tuesday Sep 16, 2014 [12:29:28 am]                              
//                                                                             
// Path:       /tmp/pvesvslx/nebulon_run/28430                                 
// Arguments:  /p/com/eda/denali/blueprint/3.7.4/Linux/blueprint -chdr -I      
//             /p/slx/eda/intel/nebulon/2.05_fdo/include -I                    
//             /p/slx/pvesv/fxr_autogen/fxr fc_lcb_csrs.rdl                    
//                                                                             
// Sources:    /tmp/pvesvslx/nebulon_run/28430/fc_lcb_csrs.rdlh                
//             /tmp/pvesvslx/nebulon_run/28430/fc_lcb_csrs.rdl                 
//             /tmp/pvesvslx/nebulon_run/28430/lib_udp.rdl                     
//             /p/com/eda/intel/nebulon/2.05p1/generators/generator_common.pm  
//             /p/com/eda/intel/nebulon/2.05p1/generators/chdr.pm              
//                                                                             
// Blueprint:   3.7.4 (Tue Jun 23 00:17:01 PDT 2009)                           
// Machine:    scci56217                                                       
// OS:         Linux 2.6.16.60-0.58.1.3835.0.PTF.638363-smp                    
// Description:                                                                
//                                                                             
//This section described the LCB Top Level address map. Output file will be    
//fc_lcb_csrs.rdl                                                              
//                                                                             
// Copyright (C) 2014 Denali Software Inc.  All rights reserved                
// THIS FILE IS AUTOMATICALLY GENERATED BY DENALI BLUEPRINT, DO NOT EDIT       
//                                                                             



// LCB_CFG_RUN desc:  Set this to turn on the LCB.
typedef volatile union {
    struct {
        uint64_t  EN                   :   1;    // 
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_RUN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_TX_FIFOS_RESET desc:  This resets the tx fifo read and write pointers. It should be cleared
// after the lane equalization is complete and the lane fifo clocks are
// stable and at their final frequency. It is anticipated that firmware
// agents will do the reset release on both sides of the link at the end
// of the LNI process.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   1;    //  Clear after the lane clocks
                                                 // are on and prior to setting
                                                 // LCB_CFG_RUN.
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_TX_FIFOS_RESET_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_TX_FIFOS_RADR desc:  This register provides the read address reset value for the tx fifo.
typedef volatile union {
    struct {
        uint64_t  RST_VAL              :   3;    //  0 min latency, radr follows
                                                 // wadr with min delay 1 will be
                                                 // tested post Silicon for
                                                 // functionality to minimize
                                                 // latency 2 not functional 3
                                                 // not functional 4 may be
                                                 // functional, no need to prove
                                                 // functionality, leave as buffer
                                                 // between functioning and non
                                                 // functioning regions. 5 max
                                                 // latency, radr follows wadr
                                                 // with max delay 6 functional,
                                                 // less latency than 4 7
                                                 // functional, less latency than
                                                 // 5
        uint64_t  Unused_3             :   1;    //  Unused
        uint64_t  ON_REINIT            :   1;    //  Enables TX_FIFOS_RESET on neg
                                                 // edge of tx_ltp_mode
        uint64_t  Unused_63_5          :  59;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_TX_FIFOS_RADR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_RX_FIFOS_RADR desc:  This register provides the read address reset value for the rx fifo.
typedef volatile union {
    struct {
        uint64_t  RST_VAL              :   4;    //  reset value. Increase toward
                                                 // 15 to reduce latency (this
                                                 // will cause bad crcs), decrease
                                                 // to add latency. 12: will be
                                                 // tested post Silicon for
                                                 // functionality to minimize
                                                 // latency 11: min latency, radr
                                                 // follows wadr with min delay
                                                 // 10: more latency than 11 9:
                                                 // more latency than 10
                                                 // 13,14,15,0,1,2,3,4,5,6,7,8:
                                                 // Undefined
        uint64_t  OK_TO_JUMP_VAL       :   4;    //  OK to jump the read address
                                                 // at the next skip opportunity
                                                 // when <= to this value. Keep
                                                 // equal to RST_VAL
        uint64_t  DO_NOT_JUMP_VAL      :   4;    //  Not OK to jump the read
                                                 // address when >= to this value.
                                                 // Set to OK_TO_JUMP_VAL + 1
        uint64_t  Unused_63_12         :  52;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_RX_FIFOS_RADR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_IGNORE_LOST_RCLK desc:  This configures the logic to ignore a lost receive clock. Useful only
// in pre silicon validation.
typedef volatile union {
    struct {
        uint64_t  EN                   :   1;    // 
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_IGNORE_LOST_RCLK_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_REINIT_PAUSE desc:  This register controls the ability to pause the re-initialization
// recovery sequence. See also LCB_STS_LINK_PAUSE_ACTIVE,
// LCB_CFG_REINIT_AS_SLAVE and LCB_CFG_FORCE_RECOVER_SEQUENCE.
typedef volatile union {
    struct {
        uint64_t  RX_MODE              :   2;    //  0:no pause 1: reinit pause
                                                 // at 1 before align 2: reinit
                                                 // pause at 2 after lane test,
                                                 // before deskew, kill
                                                 // ready_for_deskew 3: reinit
                                                 // pause at 3 after deskew, kill
                                                 // 'framed' signal Clearing
                                                 // these should allow the reinit
                                                 // to proceed to completion or to
                                                 // the next pause location.
                                                 // After setting this register
                                                 // LCB_CFG_FORCE_RECOVER_SEQUENCE
                                                 // should be used to trigger the
                                                 // reinit.
        uint64_t  Unused_3_2           :   2;    //  Unused
        uint64_t  TX_MODE              :   1;    //  Use on gen2 HFI for OPIO
                                                 // re-center. Switch side of link
                                                 // must have CFG_REINIT_AS_SLAVE
                                                 // set. This will not activate
                                                 // until a neg edge of LTP mode
                                                 // occurs. After setting this
                                                 // register use
                                                 // LCB_CFG_FORCE_RECOVER_SEQUENCE
                                                 // to trigger the reinit. Poll
                                                 // STS_LINK_PAUSE_ACTIVE to make
                                                 // sure it is safe to start the
                                                 // OPIO re-center. After
                                                 // completion clearing this will
                                                 // release the pause. Link timer
                                                 // is still active so release
                                                 // must occur prior to
                                                 // expiration.
        uint64_t  Unused_7_5           :   3;    //  Unused
        uint64_t  ON_REINIT            :   1;    //  Level sensitive.Will pause
                                                 // during the next reinit state
                                                 // for debug on any kind of
                                                 // reinit trigger. Clearing may
                                                 // (skips could be an issue)
                                                 // allow continuation without
                                                 // errors. aka
                                                 // hold_composite_reinit
        uint64_t  Unused_63_9          :  55;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_REINIT_PAUSE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_REINIT_AS_SLAVE desc:  This register is used to allow a link pause controlled entirely from
// HFI LCB CSRs. A switch LCB connected to a HFI LCB will perform as a
// slave LCB to the HFI master LCB. This will needed for OPIO re-center
// during which the link will be paused under generation 2 HFI control
// connected to a generation 1 switch. If two HFI are connected together
// in a testing configuration only one should be the slave. The OPIO
// re-center can be performed on both simultaneously. See also
// LCB_STS_LINK_PAUSE_ACTIVE, LCB_CFG_REINIT_PAUSE_TX_MODE and
// LCB_CFG_FORCE_RECOVER_SEQUENCE.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   1;    //  Set this on the switch side.
                                                 // Do not use this in any
                                                 // internal or external loopback
                                                 // mode.
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_REINIT_AS_SLAVE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_FORCE_RECOVER_SEQUENCE desc:  This register forces a recovery re-initialization sequence.
typedef volatile union {
    struct {
        uint64_t  EN                   :   1;    //  On the Tx side write a 1 to
                                                 // force a single reinit. Auto
                                                 // clears.
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_FORCE_RECOVER_SEQUENCE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_CNT_FOR_SKIP_STALL desc:  This configures the skip stall counts for various ppm values.
typedef volatile union {
    struct {
        uint64_t  PPM_SELECT           :   2;    //  This must be the same in both
                                                 // link directions. 0: 200 ppm
                                                 // (Should be able to handle
                                                 // up/close to 244 ppm as a
                                                 // safety margin) 1: 300 ppm
                                                 // (Should be able to handle
                                                 // up/close to 312 ppm) 2: 400
                                                 // ppm (Should be able to handle
                                                 // up/close to 488 ppm) 3: 1000
                                                 // ppm (Should be able to handle
                                                 // up/close to 976 ppm)
        uint64_t  Unused_3_2           :   2;    //  Unused
        uint64_t  DISABLE_TX           :   1;    //  Might be set for gen 1
                                                 // connected to gen 2.
        uint64_t  Unused_7_5           :   3;    //  Unused
        uint64_t  DISABLE_RX           :   1;    //  Used for gen 1 DV only. Might
                                                 // be set as default on gen 2.
        uint64_t  Unused_63_9          :  55;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_CNT_FOR_SKIP_STALL_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_TX_FSS desc:  This register enables the Tx side synchronous scrambler.
typedef volatile union {
    struct {
        uint64_t  EN                   :   1;    // 
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_TX_FSS_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_RX_FSS desc:  This register enables the Rx side synchronous scrambler.
typedef volatile union {
    struct {
        uint64_t  EN                   :   1;    // 
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_RX_FSS_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_CRC_MODE desc:  This register sets the CRC mode on the Tx side of the link. The Rx
// side is informed via the initialization training pattern. Different
// CRC modes can be set for each of the two link directions. There is a
// fallback capability to use a configuration value on the Rx side
// instead of the value delivered in the training pattern.
typedef volatile union {
    struct {
        uint64_t  TX_VAL               :   2;    //  0: 16 bit CRC. 1: 14 bit
                                                 // CRC. 2: 48 bit CRC. 3: CRC
                                                 // per lane mode.
        uint64_t  Unused_3_2           :   2;    //  Unused
        uint64_t  USE_RX_CFG_VAL       :   1;    //  ignore the value delivered in
                                                 // training pattern from the Tx
                                                 // side
        uint64_t  Unused_7_5           :   3;    //  Unused
        uint64_t  RX_VAL               :   2;    //  Used only when USE_RX_CFG_VAL
                                                 // is set. 0: 16 bit CRC. 1: 14
                                                 // bit CRC. 2: 48 bit CRC. 3:
                                                 // CRC per lane mode.
        uint64_t  Unused_63_10         :  54;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_CRC_MODE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_LN_DCLK desc:  This register allows for the dclk sampling to occur on a inverted
// dclk.
typedef volatile union {
    struct {
        uint64_t  INVERT_SAMPLE        :   1;    //  A way to shift the phase of
                                                 // the sampled version of the
                                                 // selected dclk in case it is
                                                 // being sampled consistently at
                                                 // the edge and this is causing
                                                 // unexpected problems.
                                                 // Potentially required because
                                                 // dclk and cclk run off the same
                                                 // Ref Clk and are at a exact 5/4
                                                 // frequency ratio with unknown
                                                 // phase. All other versions of
                                                 // the dclk are unaffected. The
                                                 // phase of the data being
                                                 // presented to the SERDES lanes
                                                 // is unaffected.
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_LN_DCLK_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_LN_TEST_TIME_TO_PASS desc:  This register sets the time for a lane to pass testing after the
// first lane passes.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  12;    //  number of Tx side lane fifo
                                                 // clocks. Behavior is undefined
                                                 // for values other than the
                                                 // default.
        uint64_t  Unused_63_12         :  52;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_LN_TEST_TIME_TO_PASS_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_LN_TEST_REQ_PASS_CNT desc:  This register sets the number of matches (out of a total of 256)
// required for the lane to pass testing during a reinit sequence.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   3;    //  0: 0x80 1: 0xF0 (enable
                                                 // reset for failed test) 2:
                                                 // 0xFD (enable reset for failed
                                                 // test) 3: 0xFD 4: 0xFF
                                                 // (enable reset for failed test)
                                                 // 5: 0xFF 6: 0x100 (enable
                                                 // reset for failed test) 7:
                                                 // 0x100
        uint64_t  Unused_63_3          :  61;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_LN_TEST_REQ_PASS_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_LN_RE_ENABLE desc:  This register configures the ability to re-enable a lane during a
// reinit sequence.
typedef volatile union {
    struct {
        uint64_t  ON_REINIT            :   1;    //  re-enable lanes that
                                                 // previously failed reinit
                                                 // testing on all reinit
                                                 // sequences
        uint64_t  LTO_REINIT           :   1;    //  re-enable lanes that
                                                 // previously failed reinit
                                                 // testing when the link times
                                                 // out
        uint64_t  LTO_DEGRADE          :   1;    //  re-enable degraded lanes when
                                                 // the link times out
        uint64_t  Unused_63_3          :  61;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_LN_RE_ENABLE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_RX_LN_EN desc:  This register sets the Rx side enable for each physical lane.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   4;    //  Clear to disable. This is
                                                 // best used prior to setting the
                                                 // LCB_CFG_RUN CSR. Changing this
                                                 // field while the link is active
                                                 // produces undefined behavior.
        uint64_t  Unused_63_4          :  60;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_RX_LN_EN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_NULLS_REQUIRED_BASE desc:  This register sets the base value for the number of nulls that need
// to be inserted on each cycle through the replay buffer.
typedef volatile union {
    struct {
        uint64_t  VAL0                 :   4;    //  rx_num_lanes > tx_num_lanes
        uint64_t  VAL1                 :   4;    //  rx_num_lanes == tx_num_lanes
                                                 // && rx_num_lanes < 3'd4
        uint64_t  VAL2                 :   4;    //  rx_num_lanes == 3'd4 &&
                                                 // tx_num_lanes == 3'd4
        uint64_t  VAL3                 :   4;    //  rx_num_lanes == 3'd3 &&
                                                 // tx_num_lanes == 3'd4
        uint64_t  VAL4                 :   4;    //  rx_num_lanes == 3'd2 &&
                                                 // tx_num_lanes == 3'd3
        uint64_t  VAL5                 :   4;    //  rx_num_lanes == 3'd2 &&
                                                 // tx_num_lanes == 3'd4
        uint64_t  VAL6                 :   4;    //  rx_num_lanes == 3'd1 &&
                                                 // tx_num_lanes == 3'd2
        uint64_t  VAL7                 :   4;    //  rx_num_lanes == 3'd1 &&
                                                 // tx_num_lanes == 3'd3
        uint64_t  VAL8                 :   4;    //  rx_num_lanes == 3'd1 &&
                                                 // tx_num_lanes == 3'd4
        uint64_t  Unused_63_36         :  28;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_NULLS_REQUIRED_BASE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_REINITS_BEFORE_LINK_LOW desc:  This register sets the number of last ditch reinit attempts before
// the link goes down. These are triggered when the link times out or a
// incomplete round trip occurs. The corresponding error flags are set.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   2;    // 
        uint64_t  Unused_63_2          :  62;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_REINITS_BEFORE_LINK_LOW_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_REMOVE_RANDOM_NULLS desc:  This register is used to remove the random data present in the
// reserved bits of Null LTPs.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   1;    // 
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_REMOVE_RANDOM_NULLS_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_REPLAY_BUF_MAX_LTP desc:  This register sets the maximum replay buffer LTP number sent to the
// peer Rx to inform it of the replay buffer size on the Tx side of the
// link.
typedef volatile union {
    struct {
        uint64_t  NUM                  :  15;    //  This is used for DV purposes
                                                 // only. It can be used to test
                                                 // the Rx side logic to verify it
                                                 // can work with arbitrary replay
                                                 // buffer sizes from a minimum of
                                                 // 15'h10 LTPs up to the maximum
                                                 // (size in LTPs - 1) of the
                                                 // replay buffer, 15'h7f in gen
                                                 // 1.
        uint64_t  Unused_63_15         :  49;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_REPLAY_BUF_MAX_LTP_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_THROTTLE_TX_FLITS desc:  This register is used to throttle the tx flit stream by forcing idles
// in specific LTP flit locations. This can be used without the one shot
// feature to emulate 1,2,3 lanes active for L0p power reduction
// experiments.
typedef volatile union {
    struct {
        uint64_t  EN                   :   8;    //  [0] send idles in LTP flit
                                                 // locations 0,1 [1] send idles
                                                 // in LTP flit locations 2,3 [2]
                                                 // send idles in LTP flit
                                                 // locations 4,5 [3] send idles
                                                 // in LTP flit locations 6,7 [4]
                                                 // send idles in LTP flit
                                                 // locations 8,9 [5] send idles
                                                 // in LTP flit locations 10,11
                                                 // [6] send idles in LTP flit
                                                 // locations 12,13 [7] send
                                                 // idles in LTP flit locations
                                                 // 14,15
        uint64_t  ONE_SHOT             :   1;    //  Use to force one shot
                                                 // throttling. Auto clears this
                                                 // field and the EN field when
                                                 // complete.
        uint64_t  Unused_11_9          :   3;    //  Unused
        uint64_t  AFIOW_TX             :   1;    //  Do not set. For debug only.
        uint64_t  Unused_15_13         :   3;    //  Unused
        uint64_t  AFIOW_RX             :   1;    //  Do not set. For debug only.
        uint64_t  Unused_63_17         :  47;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_THROTTLE_TX_FLITS_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_TX_SWIZZLE desc:  This register is used to control lane swizzle on the Tx side.
typedef volatile union {
    struct {
        uint64_t  LN0                  :   3;    //  Use to control swizzle on Tx
                                                 // side. Packed lane 0 data can
                                                 // be directed at any of the 4
                                                 // physical lanes via [1:0] [2]
                                                 // is a disable which quiets the
                                                 // lane using all zeros. Use for
                                                 // debug and crosstalk analysis
                                                 // only.
        uint64_t  Unused_3             :   1;    //  Unused
        uint64_t  LN1                  :   3;    //  Use to control swizzle on Tx
                                                 // side. Packed lane 1 data can
                                                 // be directed at any of the 4
                                                 // physical lanes via [1:0] [2]
                                                 // is a disable which quiets the
                                                 // lane using all zeros. Use for
                                                 // debug and crosstalk analysis
                                                 // only.
        uint64_t  Unused_7             :   1;    //  Unused
        uint64_t  LN2                  :   3;    //  Use to control swizzle on Tx
                                                 // side. Packed lane 2 data can
                                                 // be directed at any of the 4
                                                 // physical lanes via [1:0] [2]
                                                 // is a disable which quiets the
                                                 // lane using all zeros. Use for
                                                 // debug and crosstalk analysis
                                                 // only.
        uint64_t  Unused_11            :   1;    //  Unused
        uint64_t  LN3                  :   3;    //  Use to control swizzle on Tx
                                                 // side. Packed lane 3 data can
                                                 // be directed at any of the 4
                                                 // physical lanes via [1:0] [2]
                                                 // is a disable which quiets the
                                                 // lane using all zeros. Use for
                                                 // debug and crosstalk analysis
                                                 // only.
        uint64_t  Unused_63_15         :  49;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_TX_SWIZZLE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_SEND_SMA_MSG desc:  This register is used by the subnet management agent (SMA) to send a
// message to the peer SMA. There is no hardware mechanism provided on
// the Tx side to indicate if the message has been sent. This must be
// accomplished by polling the LCB_STS_RCV_SMA_MSG by the peer SMA.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  48;    // 
        uint64_t  Unused_63_48         :  16;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_SEND_SMA_MSG_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_INCOMPLT_RND_TRIP_DISABLE desc:  This register can be used to disable the incomplete round trip error
// handling.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   1;    // 
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_INCOMPLT_RND_TRIP_DISABLE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_RND_TRIP_MAX desc:  This register can be used to set the value at which the
// RST_FOR_INCOMPLT_RND_TRIP error flag is triggered.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  16;    // 
        uint64_t  Unused_63_16         :  48;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_RND_TRIP_MAX_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_LINK_TIMER_DISABLE desc:  This register can be used to disable the link transfer timer.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   1;    // 
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_LINK_TIMER_DISABLE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_LINK_TIMER_MAX desc:  This register sets the link timer maximum value.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  32;    //  Number of cclks at which lack
                                                 // of forward progress will take
                                                 // down link transfer active.
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_LINK_TIMER_MAX_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_DESKEW desc:  This register can be used to disable deskew altogether or just the
// deskew timer.
typedef volatile union {
    struct {
        uint64_t  ALL_DISABLE          :   1;    // 
        uint64_t  Unused_3_1           :   3;    //  Unused
        uint64_t  TIMER_DISABLE        :   1;    // 
        uint64_t  Unused_63_5          :  59;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_DESKEW_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_LN_DEGRADE desc:  This register is used to configure the lane degrade removal
// mechanism. All fields should be configured prior to booting the LCB.
// If any fields need to be changed after a LCB boot RESET_SETTINGS
// needs to be used.
typedef volatile union {
    struct {
        uint64_t  EN                   :   1;    //  Use to enable or disable
                                                 // degrades.
        uint64_t  Unused_3_1           :   3;    //  Unused
        uint64_t  NUM_ALLOWED          :   2;    //  Number of degrade reinits
                                                 // allowed. 0 will prevent
                                                 // reinits triggered from lane
                                                 // degrades. The first degrade
                                                 // will transition from 4 lanes
                                                 // to 3. The second degrade will
                                                 // transition from 3 lanes to 2.
                                                 // The third degrade will
                                                 // transition from 2 lanes to 1.
                                                 // If only 2 lanes are active
                                                 // coming out of initialization
                                                 // than the first degrade will
                                                 // transition to a single lane.
                                                 // In this case the degrade cnt
                                                 // should never exceed 1 because
                                                 // we do not do any more
                                                 // degrades, virtual or
                                                 // otherwise, when only 1 lane
                                                 // remains active.
        uint64_t  Unused_7_6           :   2;    //  Unused
        uint64_t  DURATION_SELECT      :   3;    //  The duration (in number of
                                                 // LTPs divided by the number of
                                                 // active lanes) of the sliding
                                                 // window in which if a
                                                 // particular lane triggers
                                                 // sequential CRC errors its
                                                 // event count will increment. If
                                                 // a duration completes
                                                 // (including one that ends due
                                                 // to a sequential CRC error on a
                                                 // different lane) without a
                                                 // sequential error a lanes event
                                                 // count will decrement. If a
                                                 // lanes event count becomes
                                                 // equal to the number set in the
                                                 // EVENTS_TO_TRIGGER field it
                                                 // will be removed. 0: 0x408
                                                 // (for DV) 1: 0x1008 2:
                                                 // 0x10008 3: 0x80004 4:
                                                 // 0xFF000 5: 0x400008 6:
                                                 // 0x800004 7: 0xFFFFFC
        uint64_t  Unused_11            :   1;    //  Unused
        uint64_t  EVENTS_TO_TRIGGER    :   3;    //  The number of sequential CRC
                                                 // error events (for a particular
                                                 // lane) (within the sliding
                                                 // window duration) required to
                                                 // trigger a lane removal. Don't
                                                 // use 0, it does not imply 8.
        uint64_t  Unused_15            :   1;    //  Unused
        uint64_t  RESET_SETTINGS       :   1;    //  reset degrade control
                                                 // settings, level sensitive.
                                                 // Should be taken high (long
                                                 // enough to be seen by both
                                                 // tx_cclk and rx_cclk,11 lclks
                                                 // to be safe in 1/8 BW mode),
                                                 // then low to load a new
                                                 // duration or if the
                                                 // EVENTS_TO_TRIGGER or
                                                 // NUM_ALLOWED needs to be
                                                 // changed without rebooting.
                                                 // This is for DV convenience
                                                 // only.
        uint64_t  Unused_19_17         :   3;    //  Unused
        uint64_t  RESET_DEGRADE_LN_EN  :   1;    //  auto clears. This forces a
                                                 // reinit sequence during which
                                                 // DEGRADE_LN_EN is reset to
                                                 // 4'b1111 re enabling any
                                                 // previously degraded lanes.
                                                 // This also does everything that
                                                 // reset_settings does.
        uint64_t  Unused_63_21         :  43;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_LN_DEGRADE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_CRC_INTERRUPT desc:  This register is used to configure which CRC error counter(s) is used
// to monitor for a potential interrupt condition. The interrupt occurs
// when the monitored error counter(s) reaches the number of errors in
// the ERR_CNT field.
typedef volatile union {
    struct {
        uint64_t  ERR_CNT              :  32;    //  Error count to interrupt on
        uint64_t  MATCH_EN             :   6;    //  multiple bits can be set to
                                                 // trigger an interrupt when any
                                                 // of the enabled error cnts
                                                 // reaches (exact match only) the
                                                 // ERR_CNT field. 0: lane 0 CRC
                                                 // error cnt 1: lane 1 CRC error
                                                 // cnt 2: lane 2 CRC error cnt
                                                 // 3: lane 3 CRC error cnt 4:
                                                 // total CRC error cnt 5:
                                                 // multiple CRC error cnt (more
                                                 // than 1 culprit).
        uint64_t  Unused_63_38         :  26;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_CRC_INTERRUPT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_LOOPBACK desc:  This is use to set the loopback mode.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   2;    //  0: normal mode 1: loopback
                                                 // using i_lane*_dclk for tx_fifo
                                                 // read. Requires
                                                 // LCB_CFG_LANE_WIDTH VAL set to
                                                 // 0 or 3. 2,3: loopback using
                                                 // cclk for tx_fifo read.
                                                 // Requires LCB_CFG_LANE_WIDTH
                                                 // VAL set to 0.
                                                 // CFG_REINIT_AS_SLAVE must be
                                                 // clear in any internal or
                                                 // external loopback mode
        uint64_t  Unused_63_2          :  62;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_LOOPBACK_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_LANE_WIDTH desc:  Set the width of the interface to the lanes.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   2;    //  0: Tx 32b, Rx 32b Gen 2
                                                 // default. Used by DV to verify
                                                 // Gen 2 interop. 1: Tx 40b, Rx
                                                 // 32b Unlikely in the real world
                                                 // but good for DV. 2: Tx 32b,
                                                 // Rx 40b Unlikely in the real
                                                 // world but good for DV. 3: Tx
                                                 // 40b, Rx 40b Gen 1 default.
        uint64_t  Unused_63_2          :  62;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_LANE_WIDTH_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_MISC desc:  This register is used to set miscellaneous configuration setting that
// are unlikely to be needed. This can serve as a catch all for
// configuration needs that arise late in the design process without
// adding a completely new CSR.
typedef volatile union {
    struct {
        uint64_t  FORCE_LN_EN          :   4;    // 
        uint64_t  BCK_CH_SEL_PRIORITY  :   2;    // 
        uint64_t  Unused_7_6           :   2;    //  Unused
        uint64_t  RX_CLK_SEL_PRIORITY  :   2;    // 
        uint64_t  Unused_11_10         :   2;    //  Unused
        uint64_t  SEL_REQUIRED_TOS_CNT :   2;    //  0:19, 1:27, 2:29, 3:31
        uint64_t  Unused_63_14         :  50;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_MISC_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_CLK_CNTR desc:  This register is used to select the clk that is monitored by the
// PRF_CLK_CNTR and sent to the o_clk_observe output.
typedef volatile union {
    struct {
        uint64_t  SELECT               :   5;    //  [4:3] = 00 and [2:0] = 0:
                                                 // gated tx_cclk divby8 1: GND,
                                                 // default for o_clk_observe 2:
                                                 // raw tx fifo clk divby8 (lane
                                                 // used for tx fifo clk selected
                                                 // by 8051) 3: raw tx fifo clk
                                                 // divby8 after loopback mux
                                                 // [4:3] = 01 and [2:0] = 0: raw
                                                 // rx fifo clk0 divby8 1: raw rx
                                                 // fifo clk0 divby8 after
                                                 // loopback mux 2: raw rx fifo
                                                 // clk1 divby8 3: raw rx fifo
                                                 // clk1 divby8 after loopback mux
                                                 // 4: raw rx fifo clk2 divby8
                                                 // 5: raw rx fifo clk2 divby8
                                                 // after loopback mux 6: raw rx
                                                 // fifo clk3 divby8 7: raw rx
                                                 // fifo clk3 divby8 after
                                                 // loopback mux [4:3] = 10 and
                                                 // [2:0] = 0: gated locked2lane0
                                                 // divby8 1: gated selected
                                                 // rx_cclk0 divby8 2: gated
                                                 // locked2lane1 divby8 3: gated
                                                 // selected rx_cclk1 divby8 4:
                                                 // gated locked2lane2 divby8 5:
                                                 // gated selected rx_cclk2 divby8
                                                 // 6: gated locked2lane3 divby8
                                                 // 7: gated selected rx_cclk3
                                                 // divby8 [4:3] = 11 and [2:0] =
                                                 // * sbus clk
        uint64_t  Unused_7_5           :   3;    //  Unused
        uint64_t  STROBE_ON_CCLK_CNTR  :   1;    //  clear during performance
                                                 // monitor applications. Set for
                                                 // accurate clk count after 2**24
                                                 // cclk counts.
        uint64_t  Unused_63_9          :  55;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_CLK_CNTR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_CRC_CNTR_RESET desc:  This register is used to hold and reset the CRC error counters.
typedef volatile union {
    struct {
        uint64_t  CLR_CRC_ERR_CNTRS    :   1;    //  clears the total, lanes,
                                                 // multiple errors, replays and
                                                 // good, accepted LTP counts must
                                                 // be held high for at least a
                                                 // few clks for a reliable clear.
        uint64_t  Unused_3_1           :   3;    //  Unused
        uint64_t  HOLD_CRC_ERR_CNTRS   :   1;    //  simultaneously stops and
                                                 // holds the total, lanes,
                                                 // multiple errors, replays and
                                                 // good LTP counts
        uint64_t  Unused_63_5          :  59;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_CRC_CNTR_RESET_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_LINK_KILL_EN desc:  This register controls whether a particular error condition will take
// the link down. It has a 1:1 correspondence with the error flags.
typedef volatile union {
    struct {
        uint64_t  CSR_PARITY_ERR       :   1;    //  see error flags
        uint64_t  INVALID_CSR_ADDR     :   1;    //  see error flags
        uint64_t  RST_FOR_FAILED_DESKEW :   1;    //  see error flags
        uint64_t  ALL_LNS_FAILED_REINIT_TEST :   1;    //  see error flags
        uint64_t  LOST_REINIT_STALL_OR_TOS :   1;    //  see error flags
        uint64_t  TX_LESS_THAN_FOUR_LNS :   1;    //  see error flags
        uint64_t  RX_LESS_THAN_FOUR_LNS :   1;    //  see error flags
        uint64_t  SEQ_CRC_ERR          :   1;    //  see error flags
        uint64_t  REINIT_FROM_PEER     :   1;    //  see error flags
        uint64_t  REINIT_FOR_LN_DEGRADE :   1;    //  see error flags
        uint64_t  CRC_ERR_CNT_HIT_LIMIT :   1;    //  see error flags
        uint64_t  RCLK_STOPPED         :   1;    //  see error flags. This enable
                                                 // should not be cleared. Doing
                                                 // so would expose the design to
                                                 // the possibility of silent data
                                                 // corruption.
        uint64_t  UNEXPECTED_REPLAY_MARKER :   1;    //  see error flags
        uint64_t  UNEXPECTED_ROUND_TRIP_MARKER :   1;    //  see error flags
        uint64_t  ILLEGAL_NULL_LTP     :   1;    //  see error flags
        uint64_t  ILLEGAL_FLIT_ENCODING :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_OFLW  :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_BUF_OFLW :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_PARITY_ERR :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_WRONG_CRC_MODE :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_MBE   :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_SBE   :   1;    //  see error flags
        uint64_t  REPLAY_BUF_MBE       :   1;    //  see error flags
        uint64_t  REPLAY_BUF_SBE       :   1;    //  see error flags
        uint64_t  CREDIT_RETURN_FLIT_MBE :   1;    //  see error flags
        uint64_t  RST_FOR_LINK_TIMEOUT :   1;    //  see error flags
        uint64_t  RST_FOR_INCOMPLT_RND_TRIP :   1;    //  see error flags
        uint64_t  HOLD_REINIT          :   1;    //  see error flags
        uint64_t  NEG_EDGE_LINK_TRANSFER_ACTIVE :   1;    //  see error flags
        uint64_t  REDUNDANT_FLIT_PARITY_ERR :   1;    //  see error flags. This enable
                                                 // should not be cleared as this
                                                 // results in undefined behavior
                                                 // inconsistent with the Storm
                                                 // Lake Architecture.
        uint64_t  Unused_63_30         :  34;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_LINK_KILL_EN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_CFG_ALLOW_LINK_UP desc:  The 8051 will set this when it receives a link transfer active back
// channel idle message from the peer. This is used by the logic that
// generates the o_lcb_fpe_link_pair_active signal.
// o_lcb_fpe_link_pair_active = lcb_sts_link_transfer_active_val &&
// lcb_cfg_allow_link_up_val.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   1;    // 
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_CFG_ALLOW_LINK_UP_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_ERRINJ_CRC_0 desc:  This register is used to provide CRC error injection stimulus for
// debug.
typedef volatile union {
    struct {
        uint64_t  CRC_ERR_XFR_EN       :  34;    //  Tx, lane(s) xfr enable for
                                                 // CRC errors. This is the
                                                 // location(s) in the LTP where
                                                 // the errors will occur. Lane(s)
                                                 // selection is dependent on the
                                                 // number of active lanes.
                                                 // CRC_ERR_LN_EN also must be set
                                                 // for any particular lane to
                                                 // have errors.
        uint64_t  Unused_35_34         :   2;    //  Unused
        uint64_t  CRC_ERR_LN_EN        :   4;    //  Tx, lane(s) enable for CRC
                                                 // errors. Appropriate
                                                 // CRC_ERR_XFR_EN must also be
                                                 // set for any particular lane to
                                                 // have errors.
        uint64_t  RANDOM_XFR_ERR       :   1;    //  Tx, if random is set have
                                                 // CRC_ERR_XFR_EN all high, else
                                                 // if random clear use
                                                 // CRC_ERR_XFR_EN directly where
                                                 // only one bit should be set
                                                 // Using random set will not
                                                 // guarantee that at least one
                                                 // xfr in a LTP will have an
                                                 // error.
        uint64_t  Unused_43_41         :   3;    //  Unused
        uint64_t  LTP_CNT_MAX_SELECT   :   2;    //  LTP_CNT_MAX 0: 0x3f 1:0x3ff
                                                 // 2: 0x7fff 3: 0xfffff
        uint64_t  Unused_47_46         :   2;    //  Unused
        uint64_t  NUM_CRC_LTP_ERRS     :   4;    //  Tx, max number or LTP CRC
                                                 // errors within LTP_CNT_MAX
                                                 // LTPs. 0 disables errors.
        uint64_t  CRC_ERR_PROBABILITY  :   3;    //  Tx, probability of forcing
                                                 // any LTP to have an error. This
                                                 // is on a LTP basis, not xfr
                                                 // basis.
                                                 // 3'd7=1:1,2,4,8,16,32,64,3'd0=1:128
                                                 // 3'd7 sets sequential errors of
                                                 // num_crc_ltp_errs These
                                                 // probabilities are accurate
                                                 // only when RANDOM_XFR_ERR is
                                                 // clear and we are guaranteeing
                                                 // that a xfr in each LTP will be
                                                 // enabled for an error via
                                                 // CRC_ERR_XFR_EN
        uint64_t  Unused_55            :   1;    //  Unused
        uint64_t  DISABLE_SEQUENTIAL_ERR :   1;    //  Use to prevent sequential
                                                 // errors and the reinits they
                                                 // trigger.
        uint64_t  Unused_63_57         :   7;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_ERRINJ_CRC_0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_ERRINJ_CRC_1 desc:  This register is used to provide CRC error injection stimulus for
// debug.
typedef volatile union {
    struct {
        uint64_t  CRC_ERR_BIT_EN       :  32;    // 
        uint64_t  SEED                 :  12;    // 
        uint64_t  Unused_63_44         :  20;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_ERRINJ_CRC_1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_ERRINJ_ECC desc:  This register is used to provide ECC error injection stimulus for
// debug.
typedef volatile union {
    struct {
        uint64_t  EN                   :   1;    //  Enable Error Injection
        uint64_t  Unused_3_1           :   3;    //  Unused
        uint64_t  MODE                 :   2;    //  Mode 0: Inject error once,
                                                 // clear enable to rearm Mode 1:
                                                 // Inject error always Mode 2:
                                                 // Inject error once if address
                                                 // matches, clear enable to rearm
                                                 // Mode 3: Inject error always
                                                 // if address matches Mode 0,2
                                                 // will wait until the replay
                                                 // buffer is being used.
        uint64_t  Unused_7_6           :   2;    //  Unused
        uint64_t  RAMSELECT            :   7;    //  [9:8]: Enable errinj for
                                                 // Replay Buffer 0 hgh,low
                                                 // [11:10]: Enable errinj for
                                                 // Replay Buffer 1 hgh,low [12]
                                                 // Enable errinj for Replay
                                                 // Buffer side RAM [13]: Enable
                                                 // errinj for input Buf0 [14]:
                                                 // Enable errinj for input Buf1
        uint64_t  Unused_19_15         :   5;    //  Unused
        uint64_t  CHECKBYTE            :   8;    //  When an error is injected,
                                                 // each bit that is set to one in
                                                 // this field causes the
                                                 // corresponding bit of the error
                                                 // detection syndrome for the
                                                 // memory address read to be
                                                 // inverted.
        uint64_t  INPUT_BUF_ADDRESS    :   4;    //  This field indicates the
                                                 // address within the input
                                                 // buffer for which error
                                                 // injection is to occur. This
                                                 // field is used only when the
                                                 // error injection mode is 2 or
                                                 // 3.
        uint64_t  Unused_35_32         :   4;    //  Unused
        uint64_t  REPLAY_BUF_ADDRESS   :   9;    //  This field indicates the
                                                 // address within the replay
                                                 // buffer rams for which error
                                                 // injection is to occur. This
                                                 // field is used only when the
                                                 // error injection mode is 2 or
                                                 // 3. For replay buffer:
                                                 // {ltp[6:0],flit[1:0]} (use
                                                 // flits 0,1,2,3)
        uint64_t  CLR_ECC_ERR_CNTS     :   1;    //  Clear all ECC error counts
        uint64_t  Unused_63_46         :  18;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_ERRINJ_ECC_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_ERRINJ_MISC desc:  This register is used to provide miscellaneous error injection
// stimulus for debug.
typedef volatile union {
    struct {
        uint64_t  FORCE_MISCOMPARE     :   1;    //  On the Rx side write a 1 to
                                                 // force a single bad CRC to a
                                                 // good CRC. auto clears.
        uint64_t  Unused_3_1           :   3;    //  Unused
        uint64_t  FORCE_EXTRA_FLIT_ACK :   1;    //  On the Rx side write a 1 to
                                                 // force a single extra flit ack.
                                                 // auto clears.
        uint64_t  Unused_7_5           :   3;    //  Unused
        uint64_t  FORCE_LOST_FLIT_ACK  :   1;    //  On the Rx side write a 1 to
                                                 // force a single lost flit ack.
                                                 // auto clears.
        uint64_t  Unused_11_9          :   3;    //  Unused
        uint64_t  FORCE_BAD_CRC_REINIT :   1;    //  On the Rx side write a 1 to
                                                 // force continuous bad crcs
                                                 // until a single sequential bad
                                                 // CRC reinit is triggered. auto
                                                 // clears.
        uint64_t  Unused_15_13         :   3;    //  Unused
        uint64_t  FORCE_REPLAY         :   1;    //  On the Rx side write a 1 to
                                                 // force a single replay request.
                                                 // auto clears.
        uint64_t  Unused_19_17         :   3;    //  Unused
        uint64_t  FORCE_VL_ACK_INPUT_PBE :   1;    //  write a 1 to force a single
                                                 // parity error on the
                                                 // fpe_lcb_vl_ack bus. auto
                                                 // clears.
        uint64_t  Unused_63_21         :  43;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_ERRINJ_MISC_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_INIT_STATE_0 desc:  This register is used to report various initialization status
// indications.
typedef volatile union {
    struct {
        uint64_t  ALIGN_COMPLETE       :   4;    //  1 for each lane
        uint64_t  POLARITY_COMPLETE    :   4;    //  1 for each lane
        uint64_t  POLARITY             :   4;    //  1 = true. 1 for each lane
        uint64_t  LOGICAL_ID_COMPLETE  :   4;    //  1 for each lane
        uint64_t  FRAMING1_COMPLETE    :   4;    //  1 for each lane
        uint64_t  CORSE_ALIGN_PTR0     :   2;    //  lane 0
        uint64_t  Unused_23_22         :   2;    //  Unused
        uint64_t  FINE_ALIGN_PTR0      :   3;    //  lane 0
        uint64_t  Unused_27            :   1;    //  Unused
        uint64_t  CORSE_ALIGN_PTR1     :   2;    //  lane 1
        uint64_t  Unused_31_30         :   2;    //  Unused
        uint64_t  FINE_ALIGN_PTR1      :   3;    //  lane 1
        uint64_t  Unused_35            :   1;    //  Unused
        uint64_t  CORSE_ALIGN_PTR2     :   2;    //  lane 2
        uint64_t  Unused_39_38         :   2;    //  Unused
        uint64_t  FINE_ALIGN_PTR2      :   3;    //  lane 2
        uint64_t  Unused_43            :   1;    //  Unused
        uint64_t  CORSE_ALIGN_PTR3     :   2;    //  lane 3
        uint64_t  Unused_47_46         :   2;    //  Unused
        uint64_t  FINE_ALIGN_PTR3      :   3;    //  lane 3
        uint64_t  Unused_51            :   1;    //  Unused
        uint64_t  Unused_63_52         :  12;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_INIT_STATE_0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_INIT_STATE_1 desc:  This register is used to report various initialization status
// indications.
typedef volatile union {
    struct {
        uint64_t  LN_TESTING_COMPLETE  :   4;    //  1 for each lane
        uint64_t  PASS_CNT_LN0         :   9;    //  lane testing compare pass
                                                 // count, out of 256 pass if >
                                                 // LN_TEST_REQ_MATCH_CNT. Read
                                                 // after LN_TESTING_COMPLETE
        uint64_t  Unused_15_13         :   3;    //  Unused
        uint64_t  PASS_CNT_LN1         :   9;    //  lane testing compare pass
                                                 // count, out of 256 pass if >
                                                 // LN_TEST_REQ_MATCH_CNT. Read
                                                 // after LN_TESTING_COMPLETE
        uint64_t  Unused_27_25         :   3;    //  Unused
        uint64_t  PASS_CNT_LN2         :   9;    //  lane testing compare pass
                                                 // count, out of 256 pass if >
                                                 // LN_TEST_REQ_MATCH_CNT. Read
                                                 // after LN_TESTING_COMPLETE
        uint64_t  Unused_39_37         :   3;    //  Unused
        uint64_t  PASS_CNT_LN3         :   9;    //  lane testing compare pass
                                                 // count, out of 256 pass if >
                                                 // LN_TEST_REQ_MATCH_CNT. Read
                                                 // after LN_TESTING_COMPLETE
        uint64_t  Unused_51_49         :   3;    //  Unused
        uint64_t  LN_PASSED_TESTING    :   4;    //  First lane to pass starts
                                                 // LN_TEST_TIMER
        uint64_t  LN_TEST_TIMER_COMPLETE :   1;    //  Time for other lanes to pass
                                                 // has expired
        uint64_t  Unused_63_57         :   7;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_INIT_STATE_1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_INIT_STATE_2 desc:  This register is used to report various initialization status
// indications.
typedef volatile union {
    struct {
        uint64_t  DESKEW_COMPLETE      :   1;    //  deskew complete.
        uint64_t  Unused_3_1           :   3;    //  Unused
        uint64_t  FAILED_TEST_CNT_LN0  :   3;    //  The number of resets back to
                                                 // align triggered when lane 0
                                                 // does not pass testing. Read
                                                 // after RX_FRAMED
        uint64_t  Unused_7             :   1;    //  Unused
        uint64_t  FAILED_TEST_CNT_LN1  :   3;    //  The number of resets back to
                                                 // align triggered when lane 1
                                                 // does not pass testing. Read
                                                 // after RX_FRAMED
        uint64_t  Unused_11            :   1;    //  Unused
        uint64_t  FAILED_TEST_CNT_LN2  :   3;    //  The number of resets back to
                                                 // align triggered when lane 2
                                                 // does not pass testing. Read
                                                 // after RX_FRAMED
        uint64_t  Unused_15            :   1;    //  Unused
        uint64_t  FAILED_TEST_CNT_LN3  :   3;    //  The number of resets back to
                                                 // align triggered when lane 3
                                                 // does not pass testing. Read
                                                 // after RX_FRAMED
        uint64_t  Unused_19            :   1;    //  Unused
        uint64_t  RADR_SKIP4DESKEW_CNT_LN0 :   4;    //  rx fifo read pointer skips
                                                 // for deskew Read after
                                                 // RX_FRAMED
        uint64_t  RADR_SKIP4DESKEW_CNT_LN1 :   4;    //  rx fifo read pointer skips
                                                 // for deskew Read after
                                                 // RX_FRAMED
        uint64_t  RADR_SKIP4DESKEW_CNT_LN2 :   4;    //  rx fifo read pointer skips
                                                 // for deskew Read after
                                                 // RX_FRAMED
        uint64_t  RADR_SKIP4DESKEW_CNT_LN3 :   4;    //  rx fifo read pointer skips
                                                 // for deskew Read after
                                                 // RX_FRAMED
        uint64_t  BACK_CHAN_REPORTING_LN :   2;    //  lane being used for back
                                                 // channel reporting. Read after
                                                 // RX_FRAMED
        uint64_t  Unused_39_38         :   2;    //  Unused
        uint64_t  RCLK_SAMPLING_LN     :   2;    //  lane being used for Rclk
                                                 // sampling Read after RX_FRAMED
        uint64_t  Unused_43_42         :   2;    //  Unused
        uint64_t  PEER_LN_EN_DETECTED  :   1;    //  peer lane enable detected,
                                                 // helps trigger tx_ltp_mode
                                                 // start
        uint64_t  Unused_47_45         :   3;    //  Unused
        uint64_t  TX_TON_SIG           :   1;    //  Tx sending the tos to peer,
                                                 // triggers tx_ltp_mode start.
                                                 // After PEER_LN_EN_DETECTED and
                                                 // min_f_eq1_cnt
        uint64_t  Unused_63_49         :  15;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_INIT_STATE_2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_CFG_GOOD_BAD_DATA desc:  This register is used to control the good, bad and scrambled LTP
// data.
typedef volatile union {
    struct {
        uint64_t  ARM                  :   1;    //  level sensitive, must set
                                                 // first and then clear to arm
        uint64_t  Unused_3_1           :   3;    //  Unused
        uint64_t  SELECT               :   2;    //  0: raw good unscrambled LTP
                                                 // data buffer 1: raw bad
                                                 // unscrambled LTP data buffer
                                                 // 2: raw bad scrambled LTP data
                                                 // buffer
        uint64_t  Unused_7_6           :   2;    //  Unused
        uint64_t  ADDR                 :   4;    //  Address within the buffer.
                                                 // First clock of data is at
                                                 // address 0.
        uint64_t  SAVE_MULTIPLE_ONLY   :   1;    //  Only save data when there is
                                                 // a multiple lane error.
                                                 // Supersedes SAVE_ESCAPE_ONLY.
        uint64_t  Unused_15_13         :   3;    //  Unused
        uint64_t  SAVE_ESCAPE_ONLY     :   3;    //  0: disable 1: 1 bad 3 good
                                                 // (probably a bad CRC bit) 2: 2
                                                 // bad 2 good (probably 2 bad CRC
                                                 // bits) 3: 3 bad 1 good (3 bad
                                                 // CRC bits or a escape) 4: set
                                                 // ignore_crc_bits_for_culprits
                                                 // only 5: set
                                                 // ignore_crc_bits_for_culprits,
                                                 // escape_0_only 6: set
                                                 // ignore_crc_bits_for_culprits,
                                                 // escape_0_plus1 7: set
                                                 // ignore_crc_bits_for_culprits,
                                                 // escape_0_plus2
                                                 // SAVE_MULTIPLE_ONLY must be
                                                 // clear to use all of the above.
        uint64_t  Unused_19            :   1;    //  Unused
        uint64_t  SAVE_ALL             :   1;    //  This will turn off escape
                                                 // counting if enabled. This is
                                                 // needed only when crc_mode is 2
                                                 // and you want to prevent
                                                 // rearming for escape counting
                                                 // so you can look at routine
                                                 // failing patterns.
        uint64_t  Unused_23_21         :   3;    //  Unused
        uint64_t  ERR_STAT_MODE        :   1;    //  if set the bad/data is not
                                                 // saved as it is being used to
                                                 // generate the xfr err cnts
        uint64_t  Unused_27_25         :   3;    //  Unused
        uint64_t  SHIFTED_LN_ERR_CNT_EN :   4;    //  This should only be used when
                                                 // 4 lanes are active.The enabled
                                                 // shifted lane(s) participate in
                                                 // the required error cnt and in
                                                 // the STS_XFR_ERR_STATS
        uint64_t  RAW_REQUIRED_ERR_CNT :   5;    //  If the xfr err cnt is less
                                                 // than this value the LP will
                                                 // not be saved.
        uint64_t  Unused_63_37         :  27;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_CFG_GOOD_BAD_DATA_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_STS_GOOD_BAD_DATA desc:  This register is used to observe status associated with the good, bad
// and scrambled LTP data.
typedef volatile union {
    struct {
        uint64_t  READY                :   1;    // 
        uint64_t  Unused_3_1           :   3;    //  Unused
        uint64_t  LTP_CNT_GOOD         :   3;    // 
        uint64_t  Unused_7             :   1;    //  Unused
        uint64_t  LTP_CNT_BAD          :   3;    // 
        uint64_t  Unused_11            :   1;    //  Unused
        uint64_t  TOT_BAD_XFR          :   5;    //  total number of bad XFRs, for
                                                 // debug of error stat logic.
        uint64_t  Unused_63_17         :  47;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_STS_GOOD_BAD_DATA_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_STS_GOOD_BAD_DAT0 desc:  This register is used to observe the good, bad and scrambled LTP
// data.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  32;    // 
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_STS_GOOD_BAD_DAT0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_STS_GOOD_BAD_DAT1 desc:  This register is used to observe the good, bad and scrambled LTP
// data.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  32;    // 
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_STS_GOOD_BAD_DAT1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_STS_GOOD_BAD_DAT2 desc:  This register is used to observe the good, bad and scrambled LTP
// data.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  32;    // 
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_STS_GOOD_BAD_DAT2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_STS_GOOD_BAD_DAT3 desc:  This register is used to observe the good, bad and scrambled LTP
// data.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  32;    // 
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_DBG_STS_GOOD_BAD_DAT3_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_DBG_STS_XFR_ERR_STATS desc:  This register is used to cnt LTPs with xfr errs within a LTP with a
// bad CRC.
typedef volatile union {
    struct {
        uint64_t  XFR_1BAD             :  32;    //  clear by turning error stat
                                                 // mode off
        uint64_t  XFR_2BAD             :  16;    //  clear by turning error stat
                                                 // mode off
        uint64_t  XFR_3BAD             :  10;    //  clear by turning error stat
                                                 // mode off
        uint64_t  XFR_4BAD             :   6;    //  four or more. clear by
                                                 // turning error stat mode off

    };
    uint64_t                         val;
} LCB_DBG_STS_XFR_ERR_STATS_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_FLG desc:  This is the error flag CSR.
typedef volatile union {
    struct {
        uint64_t  CSR_PARITY_ERR       :   1;    //  self explanatory
        uint64_t  INVALID_CSR_ADDR     :   1;    //  self explanatory
        uint64_t  RST_FOR_FAILED_DESKEW :   1;    //  self explanatory
        uint64_t  ALL_LNS_FAILED_REINIT_TEST :   1;    //  All four lanes failed testing
                                                 // during reinit, triggers a
                                                 // reset.
        uint64_t  LOST_REINIT_STALL_OR_TOS :   1;    //  lost clock stall or turn on
                                                 // signal during reinit. This is
                                                 // catastrophic and will take
                                                 // down the link.
        uint64_t  TX_LESS_THAN_FOUR_LNS :   1;    //  self explanatory
        uint64_t  RX_LESS_THAN_FOUR_LNS :   1;    //  self explanatory
        uint64_t  SEQ_CRC_ERR          :   1;    //  A sequential CRC error was
                                                 // encountered. This triggers a
                                                 // reinit sequence.
        uint64_t  REINIT_FROM_PEER     :   1;    //  A reinit sequence was
                                                 // triggered by the peer.
        uint64_t  REINIT_FOR_LN_DEGRADE :   1;    //  A reinit sequence was
                                                 // triggered during which a lane
                                                 // was removed from operation.
        uint64_t  CRC_ERR_CNT_HIT_LIMIT :   1;    //  Programmed using the
                                                 // LCB_CFG_CRC_INTERRUPT CSR.
        uint64_t  RCLK_STOPPED         :   1;    //  The (1 of 4) lane receive
                                                 // clock that is being used on
                                                 // the Rx side/pipe during LTP
                                                 // mode stopped toggling.This is
                                                 // catastrophic and will take
                                                 // down the link.
        uint64_t  UNEXPECTED_REPLAY_MARKER :   1;    //  self explanatory
        uint64_t  UNEXPECTED_ROUND_TRIP_MARKER :   1;    //  self explanatory
        uint64_t  ILLEGAL_NULL_LTP     :   1;    //  link transfer LTPs
        uint64_t  ILLEGAL_FLIT_ENCODING :   1;    //  The only legal flits from the
                                                 // FPE are head, body, tail,
                                                 // Idle, CrdtRet, HeadBadPkt,
                                                 // BodyBadPkt, TailBadPkt and the
                                                 // architecturally hidden
                                                 // ForceIdle ([64:56] = 9'h002).
        uint64_t  FLIT_INPUT_BUF_OFLW  :   1;    //  self explanatory
        uint64_t  VL_ACK_INPUT_BUF_OFLW :   1;    //  self explanatory
        uint64_t  VL_ACK_INPUT_PARITY_ERR :   1;    //  self explanatory
        uint64_t  VL_ACK_INPUT_WRONG_CRC_MODE :   1;    //  VC ack input valid and not in
                                                 // 14 bit CRC mode
        uint64_t  FLIT_INPUT_BUF_MBE   :   1;    //  self explanatory
        uint64_t  FLIT_INPUT_BUF_SBE   :   1;    //  self explanatory
        uint64_t  REPLAY_BUF_MBE       :   1;    //  self explanatory
        uint64_t  REPLAY_BUF_SBE       :   1;    //  self explanatory
        uint64_t  CREDIT_RETURN_FLIT_MBE :   1;    //  A credit return control flit
                                                 // had a MBE.
        uint64_t  RST_FOR_LINK_TIMEOUT :   1;    //  A reinit sequence is
                                                 // triggered in a last ditch
                                                 // attempt at keeping the link up
                                                 // when the timer expires. If
                                                 // this succeeds the
                                                 // NEG_EDGE_LINK_TRANSFER_ACTIVE
                                                 // and HOLD_REINIT flags will
                                                 // remain clear.
        uint64_t  RST_FOR_INCOMPLT_RND_TRIP :   1;    //  A reinit sequence is
                                                 // triggered in a last ditch
                                                 // attempt at keeping the link up
                                                 // when a round trip marker fails
                                                 // to return. If this succeeds
                                                 // the
                                                 // NEG_EDGE_LINK_TRANSFER_ACTIVE
                                                 // and HOLD_REINIT flags will
                                                 // remain clear.
        uint64_t  HOLD_REINIT          :   1;    //  This indicates the link will
                                                 // not come up. Useful when the
                                                 // link has never been up and the
                                                 // NEG_EDGE_LINK_TRANSFER_ACTIVE
                                                 // flag will be clear.
        uint64_t  NEG_EDGE_LINK_TRANSFER_ACTIVE :   1;    //  self explanatory
        uint64_t  REDUNDANT_FLIT_PARITY_ERR :   1;    //  The redundant flit info had a
                                                 // parity error.
        uint64_t  Unused_63_30         :  34;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_FLG_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_CLR desc:  This is the error clear CSR.
typedef volatile union {
    struct {
        uint64_t  CSR_PARITY_ERR       :   1;    //  see error flags
        uint64_t  INVALID_CSR_ADDR     :   1;    //  see error flags
        uint64_t  RST_FOR_FAILED_DESKEW :   1;    //  see error flags
        uint64_t  ALL_LNS_FAILED_REINIT_TEST :   1;    //  see error flags
        uint64_t  LOST_REINIT_STALL_OR_TOS :   1;    //  see error flags
        uint64_t  TX_LESS_THAN_FOUR_LNS :   1;    //  see error flags
        uint64_t  RX_LESS_THAN_FOUR_LNS :   1;    //  see error flags
        uint64_t  SEQ_CRC_ERR          :   1;    //  see error flags
        uint64_t  REINIT_FROM_PEER     :   1;    //  see error flags
        uint64_t  REINIT_FOR_LN_DEGRADE :   1;    //  see error flags
        uint64_t  CRC_ERR_CNT_HIT_LIMIT :   1;    //  see error flags
        uint64_t  RCLK_STOPPED         :   1;    //  see error flags
        uint64_t  UNEXPECTED_REPLAY_MARKER :   1;    //  see error flags
        uint64_t  UNEXPECTED_ROUND_TRIP_MARKER :   1;    //  see error flags
        uint64_t  ILLEGAL_NULL_LTP     :   1;    //  see error flags
        uint64_t  ILLEGAL_FLIT_ENCODING :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_OFLW  :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_BUF_OFLW :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_PARITY_ERR :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_WRONG_CRC_MODE :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_MBE   :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_SBE   :   1;    //  see error flags
        uint64_t  REPLAY_BUF_MBE       :   1;    //  see error flags
        uint64_t  REPLAY_BUF_SBE       :   1;    //  see error flags
        uint64_t  CREDIT_RETURN_FLIT_MBE :   1;    //  see error flags
        uint64_t  RST_FOR_LINK_TIMEOUT :   1;    //  see error flags
        uint64_t  RST_FOR_INCOMPLT_RND_TRIP :   1;    //  see error flags
        uint64_t  HOLD_REINIT          :   1;    //  see error flags
        uint64_t  NEG_EDGE_LINK_TRANSFER_ACTIVE :   1;    //  see error flags
        uint64_t  REDUNDANT_FLIT_PARITY_ERR :   1;    //  see error flags
        uint64_t  Unused_63_30         :  34;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_CLR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_EN desc:  This register is used to enable interrupts for the associated error
// flag.
typedef volatile union {
    struct {
        uint64_t  CSR_PARITY_ERR       :   1;    //  see error flags
        uint64_t  INVALID_CSR_ADDR     :   1;    //  see error flags
        uint64_t  RST_FOR_FAILED_DESKEW :   1;    //  see error flags
        uint64_t  ALL_LNS_FAILED_REINIT_TEST :   1;    //  see error flags
        uint64_t  LOST_REINIT_STALL_OR_TOS :   1;    //  see error flags
        uint64_t  TX_LESS_THAN_FOUR_LNS :   1;    //  see error flags
        uint64_t  RX_LESS_THAN_FOUR_LNS :   1;    //  see error flags
        uint64_t  SEQ_CRC_ERR          :   1;    //  see error flags
        uint64_t  REINIT_FROM_PEER     :   1;    //  see error flags
        uint64_t  REINIT_FOR_LN_DEGRADE :   1;    //  see error flags
        uint64_t  CRC_ERR_CNT_HIT_LIMIT :   1;    //  see error flags
        uint64_t  RCLK_STOPPED         :   1;    //  see error flags
        uint64_t  UNEXPECTED_REPLAY_MARKER :   1;    //  see error flags
        uint64_t  UNEXPECTED_ROUND_TRIP_MARKER :   1;    //  see error flags
        uint64_t  ILLEGAL_NULL_LTP     :   1;    //  see error flags
        uint64_t  ILLEGAL_FLIT_ENCODING :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_OFLW  :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_BUF_OFLW :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_PARITY_ERR :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_WRONG_CRC_MODE :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_MBE   :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_SBE   :   1;    //  see error flags
        uint64_t  REPLAY_BUF_MBE       :   1;    //  see error flags
        uint64_t  REPLAY_BUF_SBE       :   1;    //  see error flags
        uint64_t  CREDIT_RETURN_FLIT_MBE :   1;    //  see error flags
        uint64_t  RST_FOR_LINK_TIMEOUT :   1;    //  see error flags
        uint64_t  RST_FOR_INCOMPLT_RND_TRIP :   1;    //  see error flags
        uint64_t  HOLD_REINIT          :   1;    //  see error flags
        uint64_t  NEG_EDGE_LINK_TRANSFER_ACTIVE :   1;    //  see error flags
        uint64_t  REDUNDANT_FLIT_PARITY_ERR :   1;    //  see error flags
        uint64_t  Unused_63_30         :  34;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_EN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_FIRST_FLG desc:  This is a CSR description.
typedef volatile union {
    struct {
        uint64_t  CSR_PARITY_ERR       :   1;    //  see error flags
        uint64_t  INVALID_CSR_ADDR     :   1;    //  see error flags
        uint64_t  RST_FOR_FAILED_DESKEW :   1;    //  see error flags
        uint64_t  ALL_LNS_FAILED_REINIT_TEST :   1;    //  see error flags
        uint64_t  LOST_REINIT_STALL_OR_TOS :   1;    //  see error flags
        uint64_t  TX_LESS_THAN_FOUR_LNS :   1;    //  see error flags
        uint64_t  RX_LESS_THAN_FOUR_LNS :   1;    //  see error flags
        uint64_t  SEQ_CRC_ERR          :   1;    //  see error flags
        uint64_t  REINIT_FROM_PEER     :   1;    //  see error flags
        uint64_t  REINIT_FOR_LN_DEGRADE :   1;    //  see error flags
        uint64_t  CRC_ERR_CNT_HIT_LIMIT :   1;    //  see error flags
        uint64_t  RCLK_STOPPED         :   1;    //  see error flags
        uint64_t  UNEXPECTED_REPLAY_MARKER :   1;    //  see error flags
        uint64_t  UNEXPECTED_ROUND_TRIP_MARKER :   1;    //  see error flags
        uint64_t  ILLEGAL_NULL_LTP     :   1;    //  see error flags
        uint64_t  ILLEGAL_FLIT_ENCODING :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_OFLW  :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_BUF_OFLW :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_PARITY_ERR :   1;    //  see error flags
        uint64_t  VL_ACK_INPUT_WRONG_CRC_MODE :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_MBE   :   1;    //  see error flags
        uint64_t  FLIT_INPUT_BUF_SBE   :   1;    //  see error flags
        uint64_t  REPLAY_BUF_MBE       :   1;    //  see error flags
        uint64_t  REPLAY_BUF_SBE       :   1;    //  see error flags
        uint64_t  CREDIT_RETURN_FLIT_MBE :   1;    //  see error flags
        uint64_t  RST_FOR_LINK_TIMEOUT :   1;    //  see error flags
        uint64_t  RST_FOR_INCOMPLT_RND_TRIP :   1;    //  see error flags
        uint64_t  HOLD_REINIT          :   1;    //  see error flags
        uint64_t  NEG_EDGE_LINK_TRANSFER_ACTIVE :   1;    //  see error flags
        uint64_t  REDUNDANT_FLIT_PARITY_ERR :   1;    //  see error flags
        uint64_t  Unused_63_30         :  34;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_FIRST_FLG_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_TOTAL_CRC_ERR desc:  This register is used to report the total number of Rx side LTPs with
// a CRC error.
typedef volatile union {
    struct {
        uint64_t  CNT                  :  64;    // 

    };
    uint64_t                         val;
} LCB_ERR_INFO_TOTAL_CRC_ERR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_CRC_ERR_LN0 desc:  This register is used to report the total number of Rx side LTPs with
// a CRC error with lane 0 identified as the culprit.
typedef volatile union {
    struct {
        uint64_t  CNT                  :  64;    //  Rx physical lane 0. Cleared
                                                 // with CLR_CRC_ERR_CNTRS.

    };
    uint64_t                         val;
} LCB_ERR_INFO_CRC_ERR_LN0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_CRC_ERR_LN1 desc:  This register is used to report the total number of Rx side LTPs with
// a CRC error with lane 1 identified as the culprit.
typedef volatile union {
    struct {
        uint64_t  CNT                  :  64;    //  Rx physical lane 1. Cleared
                                                 // with CLR_CRC_ERR_CNTRS.

    };
    uint64_t                         val;
} LCB_ERR_INFO_CRC_ERR_LN1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_CRC_ERR_LN2 desc:  This register is used to report the total number of Rx side LTPs with
// a CRC error with lane 2 identified as the culprit.
typedef volatile union {
    struct {
        uint64_t  CNT                  :  64;    //  Rx physical lane 2. Cleared
                                                 // with CLR_CRC_ERR_CNTRS.

    };
    uint64_t                         val;
} LCB_ERR_INFO_CRC_ERR_LN2_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_CRC_ERR_LN3 desc:  This register is used to report the total number of Rx side LTPs with
// a CRC error with lane 3 identified as the culprit.
typedef volatile union {
    struct {
        uint64_t  CNT                  :  64;    //  Rx physical lane 3. Cleared
                                                 // with CLR_CRC_ERR_CNTRS.

    };
    uint64_t                         val;
} LCB_ERR_INFO_CRC_ERR_LN3_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_CRC_ERR_MULTI_LN desc:  This register is used to report the total number of Rx side LTPs with
// a CRC error with more than one lane identified as the culprit.
typedef volatile union {
    struct {
        uint64_t  CNT                  :  20;    //  Cleared with
                                                 // CLR_CRC_ERR_CNTRS.
        uint64_t  Unused_63_20         :  44;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_CRC_ERR_MULTI_LN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_TX_REPLAY_CNT desc:  This register is used to report the total number of Tx side
// retransmission sequences.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  64;    //  Cleared with
                                                 // CLR_CRC_ERR_CNTRS.

    };
    uint64_t                         val;
} LCB_ERR_INFO_TX_REPLAY_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_RX_REPLAY_CNT desc:  This register is used to report the total number of Rx side
// retransmission sequences.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  64;    //  Cleared with
                                                 // CLR_CRC_ERR_CNTRS.

    };
    uint64_t                         val;
} LCB_ERR_INFO_RX_REPLAY_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_SEQ_CRC_CNT desc:  This register is used to report the total number of Rx side
// sequential CRC error count.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  32;    // 
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_SEQ_CRC_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_ESCAPE_0_ONLY_CNT desc:  This register is used to report the total number of poly 0 only false
// positive 12 bit CRC checks in 48 bit CRC mode when four lanes are
// active.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  32;    //  Cleared with
                                                 // CLR_CRC_ERR_CNTRS.
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_ESCAPE_0_ONLY_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_ESCAPE_0_PLUS1_CNT desc:  This register is used to report the total number of simultaneous poly
// 0 and any of the other 3 polys (just 1) false positive 12 bit CRC
// checks in 48 bit CRC mode when four lanes are active.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  32;    //  Cleared with
                                                 // CLR_CRC_ERR_CNTRS.
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_ESCAPE_0_PLUS1_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_ESCAPE_0_PLUS2_CNT desc:  This register is used to report the total number of simultaneous poly
// 0 and any two of the other 3 polys (just 2) false positive 12 bit CRC
// checks in 48 bit CRC mode when four lanes are active.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  16;    //  Cleared with
                                                 // CLR_CRC_ERR_CNTRS.
        uint64_t  Unused_63_16         :  48;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_ESCAPE_0_PLUS2_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_REINIT_FROM_PEER_CNT desc:  This register is used to report the total number of reinit sequences
// triggered from the peer.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  32;    // 
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_REINIT_FROM_PEER_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_SBE_CNT desc:  This register is used to count ECC SBE errors in the input buffer and
// replay buffer.
typedef volatile union {
    struct {
        uint64_t  INPUT_BUFFER         :   8;    //  Number of Single Bit Errors
                                                 // that have occurred in input
                                                 // buffer RAM. Does not roll.
                                                 // Cleared with
                                                 // LCB_DBG_ERRINJ_ECC_CLR_ECC_ERR_CNTS.
        uint64_t  REPLAY_BUFFER0       :   8;    //  Number of Single Bit Errors
                                                 // that have occurred in replay
                                                 // RAM0. Does not roll. Cleared
                                                 // with
                                                 // LCB_DBG_ERRINJ_ECC_CLR_ECC_ERR_CNTS
        uint64_t  REPLAY_BUFFER1       :   8;    //  Number of Single Bit Errors
                                                 // that have occurred in replay
                                                 // RAM1. Does not roll. Cleared
                                                 // with
                                                 // LCB_DBG_ERRINJ_ECC_CLR_ECC_ERR_CNTS
        uint64_t  REPLAY_BUFFER_SIDE   :   8;    //  Number of Single Bit Errors
                                                 // that have occurred in replay
                                                 // side data RAM. Does not roll.
                                                 // Cleared with
                                                 // LCB_DBG_ERRINJ_ECC_CLR_ECC_ERR_CNTS
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_SBE_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_MISC_FLG_CNT desc:  This register is used to count error flag events that are
// informational and not necessarily catastrophic and would tend to
// occur only at very high BER. The logic attempts to ride through these
// events.
typedef volatile union {
    struct {
        uint64_t  RST_FOR_FAILED_DESKEW :   8;    //  see ERR_FLG register
        uint64_t  ALL_LNS_FAILED_REINIT_TEST :   8;    //  see ERR_FLG register
        uint64_t  RST_FOR_LINK_TIMEOUT :   8;    //  see ERR_FLG register
        uint64_t  RST_FOR_INCOMPLT_RND_TRIP :   8;    //  see ERR_FLG register
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_MISC_FLG_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_ECC_INPUT_BUF_HGH desc:  This register is used to report ECC errors in the input buffer RAMs.
typedef volatile union {
    struct {
        uint64_t  DATA                 :  33;    //  The content of an ERR_INFO
                                                 // CSR is updated when the
                                                 // corresponding error flag in
                                                 // the ERR_FLG CSR transitions
                                                 // from 0 to 1 due to a hardware
                                                 // detected event. The ERR_INFO
                                                 // CSR is not modified when the
                                                 // corresponding error flag
                                                 // becomes set due to a software
                                                 // write to the ERR_FLG CSR.
        uint64_t  Unused_35_33         :   3;    //  Unused
        uint64_t  CHK                  :   8;    //  The content of an ERR_INFO
                                                 // CSR is updated when the
                                                 // corresponding error flag in
                                                 // the ERR_FLG CSR transitions
                                                 // from 0 to 1 due to a hardware
                                                 // detected event. The ERR_INFO
                                                 // CSR is not modified when the
                                                 // corresponding error flag
                                                 // becomes set due to a software
                                                 // write to the ERR_FLG CSR.
        uint64_t  SYNDROME             :   8;    //  The content of an ERR_INFO
                                                 // CSR is updated when the
                                                 // corresponding error flag in
                                                 // the ERR_FLG CSR transitions
                                                 // from 0 to 1 due to a hardware
                                                 // detected event. The ERR_INFO
                                                 // CSR is not modified when the
                                                 // corresponding error flag
                                                 // becomes set due to a software
                                                 // write to the ERR_FLG CSR.
        uint64_t  LOCATION             :   2;    //  0: MBE ram low 1: MBE ram
                                                 // high 2: SBE ram low 3: SBE
                                                 // ram high
        uint64_t  Unused_55_54         :   2;    //  Unused
        uint64_t  CSR_CREATED          :   1;    //  Injected via CSR
        uint64_t  Unused_63_57         :   7;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_ECC_INPUT_BUF_HGH_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_ECC_INPUT_BUF_LOW desc:  This register is used to report ECC errors in the input buffer RAMs.
typedef volatile union {
    struct {
        uint64_t  DATA                 :  32;    //  The content of an ERR_INFO
                                                 // CSR is updated when the
                                                 // corresponding error flag in
                                                 // the ERR_FLG CSR transitions
                                                 // from 0 to 1 due to a hardware
                                                 // detected event. The ERR_INFO
                                                 // CSR is not modified when the
                                                 // corresponding error flag
                                                 // becomes set due to a software
                                                 // write to the ERR_FLG CSR.
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_ECC_INPUT_BUF_LOW_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_ECC_REPLAY_BUF_HGH desc:  This register is used to report ECC errors in the replay buffer RAMs.
typedef volatile union {
    struct {
        uint64_t  DATA                 :  33;    //  The content of an ERR_INFO
                                                 // CSR is updated when the
                                                 // corresponding error flag in
                                                 // the ERR_FLG CSR transitions
                                                 // from 0 to 1 due to a hardware
                                                 // detected event. The ERR_INFO
                                                 // CSR is not modified when the
                                                 // corresponding error flag
                                                 // becomes set due to a software
                                                 // write to the ERR_FLG CSR.
        uint64_t  Unused_35_33         :   3;    //  Unused
        uint64_t  CHK                  :   8;    //  The content of an ERR_INFO
                                                 // CSR is updated when the
                                                 // corresponding error flag in
                                                 // the ERR_FLG CSR transitions
                                                 // from 0 to 1 due to a hardware
                                                 // detected event. The ERR_INFO
                                                 // CSR is not modified when the
                                                 // corresponding error flag
                                                 // becomes set due to a software
                                                 // write to the ERR_FLG CSR.
        uint64_t  SYNDROME             :   8;    //  The content of an ERR_INFO
                                                 // CSR is updated when the
                                                 // corresponding error flag in
                                                 // the ERR_FLG CSR transitions
                                                 // from 0 to 1 due to a hardware
                                                 // detected event. The ERR_INFO
                                                 // CSR is not modified when the
                                                 // corresponding error flag
                                                 // becomes set due to a software
                                                 // write to the ERR_FLG CSR.
        uint64_t  LOCATION             :   4;    //  0: MBE ram 0 low 1: MBE ram
                                                 // 0 high 2: MBE ram 1 low 3:
                                                 // MBE ram 1 high 4: SBE ram 0
                                                 // low 5: SBE ram 0 high 6: SBE
                                                 // ram 1 low 7: SBE ram 1 high
                                                 // 8: MBE side 9: SBE side
        uint64_t  CSR_CREATED          :   1;    //  Injected via CSR
        uint64_t  Unused_63_57         :   7;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_ECC_REPLAY_BUF_HGH_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_ERR_INFO_ECC_REPLAY_BUF_LOW desc:  This register is used to report ECC errors in the replay buffer RAMs.
typedef volatile union {
    struct {
        uint64_t  DATA                 :  32;    //  The content of an ERR_INFO
                                                 // CSR is updated when the
                                                 // corresponding error flag in
                                                 // the ERR_FLG CSR transitions
                                                 // from 0 to 1 due to a hardware
                                                 // detected event. The ERR_INFO
                                                 // CSR is not modified when the
                                                 // corresponding error flag
                                                 // becomes set due to a software
                                                 // write to the ERR_FLG CSR.
        uint64_t  Unused_63_32         :  32;    //  Unused

    };
    uint64_t                         val;
} LCB_ERR_INFO_ECC_REPLAY_BUF_LOW_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PRF_GOOD_LTP_CNT desc:  This register is used to report the LTP count with a good CRC. This
// will assist with BER calculations. The TOTAL_CRC_ERR_CNT /
// (GOOD_LTP_CNT + TOTAL_CRC_ERR_CNT) is the event error rate (EER). The
// BER will equal the EER/1056 if there is only one bit error per event
// (CRC error), otherwise it is larger.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  64;    //  Counts LTPs with a good CRC,
                                                 // rx_ltp_mode only. Cleared with
                                                 // CLR_CRC_ERR_CNTRS.

    };
    uint64_t                         val;
} LCB_PRF_GOOD_LTP_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PRF_ACCEPTED_LTP_CNT desc:  This register is used to report the LTP count with a good CRC
// accepted into the receive buffer. This will assist with performance
// monitor calculations. GOOD_LTP_CNT + TOTAL_CRC_ERR_CNT is the total
// LTP count. The ACCEPTED_LTP_CNT is the number that carry real payload
// delivered to the core. Null LTPs (replay buffer full due to a too long
// of a round trip time), LTPs with CRC errors, and good but tossed
// (waiting for a retransmission to begin) LTPs are not accepted.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  64;    //  Counts LTPs accepted into the
                                                 // receive buffer. Nulls and
                                                 // tossed good LTPs don't add to
                                                 // the count. Cleared with
                                                 // CLR_CRC_ERR_CNTRS.

    };
    uint64_t                         val;
} LCB_PRF_ACCEPTED_LTP_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PRF_RX_FLIT_CNT desc:  This register counts the flits on the lower side of the output bus.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  52;    // 
        uint64_t  Unused_63_52         :  12;    //  Unused

    };
    uint64_t                         val;
} LCB_PRF_RX_FLIT_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PRF_TX_FLIT_CNT desc:  This register counts the flits on the lower side of the input bus.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  52;    // 
        uint64_t  Unused_63_52         :  12;    //  Unused

    };
    uint64_t                         val;
} LCB_PRF_TX_FLIT_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PRF_CLK_CNTR desc:  This register is used to report various clk counts. The clk being
// monitored is set by CFG_CLK_CNTR.
typedef volatile union {
    struct {
        uint64_t  CNT                  :  48;    //  If STROBE_ON_LCLK_CNTR is set
                                                 // strobe triggered after lclk
                                                 // cnt of 2**24 lclks, This cntr
                                                 // is also used in performance
                                                 // monitoring and is held if
                                                 // hold_crc_error counters is
                                                 // active. This counter is
                                                 // cleared by both the strobe
                                                 // (after the value is saved in
                                                 // this CSR) and
                                                 // clr_crc_error_counters as well
                                                 // as anytime the select is
                                                 // altered.
        uint64_t  NEW_VAL_WAS_STROBED  :   1;    //  Set with strobe of new cnt,
                                                 // cleared with clear of cnt.
        uint64_t  Unused_63_49         :  15;    //  Unused

    };
    uint64_t                         val;
} LCB_PRF_CLK_CNTR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_LINK_PAUSE_ACTIVE desc:  This will be set after a LCB_CFG_REINIT_PAUSE_TX_MODE and
// LCB_CFG_FORCE_RECOVER_SEQUENCE is used. See also
// LCB_CFG_REINIT_AS_SLAVE. This does not report anything when using only
// LCB_CFG_REINIT_PAUSE_RX_MODE.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   1;    //  It is safe to start the OPIO
                                                 // re-center when this is set.
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_LINK_PAUSE_ACTIVE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_LINK_TRANSFER_ACTIVE desc:  This will be set if the link is up.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   1;    // 
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_LINK_TRANSFER_ACTIVE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_LN_DEGRADE desc:  This is used to monitor the lane degrade logic.
typedef volatile union {
    struct {
        uint64_t  EXHAUSTED            :   1;    //  CNT >=
                                                 // CFG_LN_DEGRADE_NUM_ALLOWED
        uint64_t  CNT                  :   2;    //  The number of lane degrade
                                                 // events. This still operates
                                                 // with degrades disabled so it
                                                 // can be used for diagnostic
                                                 // purposes.
        uint64_t  Unused_3             :   1;    //  Unused
        uint64_t  LN_012_RACES_WON     :   3;    //  These are the shifted lane
                                                 // numbers, not the physical lane
                                                 // numbers. This is the number of
                                                 // races won by the proposed team
                                                 // of shifted lanes 0/1/2 with
                                                 // lane 3 disabled.This cnt will
                                                 // not have meaning if less than
                                                 // 4 lanes are active. This still
                                                 // operates with degrades
                                                 // disabled so it can be used for
                                                 // diagnostic purposes.
        uint64_t  LN_013_RACES_WON     :   3;    //  These are the shifted lane
                                                 // numbers, not the physical lane
                                                 // numbers. This is the number of
                                                 // races won by the proposed team
                                                 // of shifted lanes 0/1/3 with
                                                 // lane 2 disabled. If only three
                                                 // lanes are active this is the
                                                 // number of races won by the
                                                 // proposed cfg of shifted lane 0
                                                 // and 1. This cnt will not have
                                                 // meaning if only 2 lanes are
                                                 // active. This still operates
                                                 // with degrades disabled so it
                                                 // can be used for diagnostic
                                                 // purposes.
        uint64_t  LN_023_RACES_WON     :   3;    //  These are the shifted lane
                                                 // numbers, not the physical lane
                                                 // numbers. This is the number of
                                                 // races won by the proposed team
                                                 // of shifted lanes 0/2/3 with
                                                 // lane 1 disabled. If only three
                                                 // lanes are active this is the
                                                 // number of races won by the
                                                 // proposed cfg of shifted lane 0
                                                 // and 2. If only two lanes are
                                                 // active this is the number of
                                                 // races won by the proposed cfg
                                                 // of shifted lane 0. This still
                                                 // operates with degrades
                                                 // disabled so it can be used for
                                                 // diagnostic purposes.
        uint64_t  LN_123_RACES_WON     :   3;    //  These are the shifted lane
                                                 // numbers, not the physical lane
                                                 // numbers. This is the number of
                                                 // races won by the proposed team
                                                 // of shifted lanes 1/2/3 with
                                                 // lane 0 disabled. If only three
                                                 // lanes are active this is the
                                                 // number of races won by the
                                                 // proposed cfg of shifted lane
                                                 // 1and 2. If only two lanes are
                                                 // active this is the number of
                                                 // races won by the proposed cfg
                                                 // of shifted lane 1. This still
                                                 // operates with degrades
                                                 // disabled so it can be used for
                                                 // diagnostic purposes.
        uint64_t  CURRENT_CFG_RACES_WON :  48;    //  number of races won by the
                                                 // current lane configuration.
                                                 // Sticks at 48'hffffffffffff.
                                                 // Cleared by a degrade reinit or
                                                 // CLR_CRC_ERR_CNTRS. This still
                                                 // operates with degrades
                                                 // disabled so it can be used for
                                                 // diagnostic purposes.

    };
    uint64_t                         val;
} LCB_STS_LN_DEGRADE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_TX_LTP_MODE desc:  This register is used to monitor the status of the Tx side LTP mode.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   1;    //  When set LTPs are being
                                                 // transmitted, when clear a
                                                 // reinit sequence is underway.
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_TX_LTP_MODE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_RX_LTP_MODE desc:  This register is used to monitor the status of the Rx side LTP mode.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   1;    //  When set LTPs are being
                                                 // received, when clear a reinit
                                                 // sequence is underway.
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_RX_LTP_MODE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_RX_CRC_MODE desc:  This register is used to monitor the status of the Rx side CRC mode.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   2;    // 
        uint64_t  Unused_63_2          :  62;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_RX_CRC_MODE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_RX_LOGICAL_ID desc:  This register reports the Rx logical ID (Peers Tx physical ID) for
// each lane.
typedef volatile union {
    struct {
        uint64_t  LN0                  :   3;    //  > 3 indicates this lane is
                                                 // disabled.
        uint64_t  Unused_3             :   1;    //  Unused
        uint64_t  LN1                  :   3;    //  > 3 indicates this lane is
                                                 // disabled.
        uint64_t  Unused_7             :   1;    //  Unused
        uint64_t  LN2                  :   3;    //  > 3 indicates this lane is
                                                 // disabled.
        uint64_t  Unused_11            :   1;    //  Unused
        uint64_t  LN3                  :   3;    //  > 3 indicates this lane is
                                                 // disabled.
        uint64_t  Unused_63_15         :  49;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_RX_LOGICAL_ID_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_RX_SHIFTED_LN_NUM desc:  This register reports the Rx logical ID (Peers Tx physical ID) for
// each lane.
typedef volatile union {
    struct {
        uint64_t  LN0                  :   3;    //  > 3 indicates this lane is
                                                 // disabled.
        uint64_t  Unused_3             :   1;    //  Unused
        uint64_t  LN1                  :   3;    //  > 3 indicates this lane is
                                                 // disabled.
        uint64_t  Unused_7             :   1;    //  Unused
        uint64_t  LN2                  :   3;    //  > 3 indicates this lane is
                                                 // disabled.
        uint64_t  Unused_11            :   1;    //  Unused
        uint64_t  LN3                  :   3;    //  > 3 indicates this lane is
                                                 // disabled.
        uint64_t  Unused_63_15         :  49;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_RX_SHIFTED_LN_NUM_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_RX_PHY_LN_EN desc:  This register reports the Rx side physical lane enable.
typedef volatile union {
    struct {
        uint64_t  COMBINED             :   4;    //  Combined lane enable =
                                                 // CFG_LN_EN & INIT & DEGRADE
        uint64_t  INIT                 :   4;    //  Initialization lane enable.
                                                 // (some lanes fail the training
                                                 // sequence)
        uint64_t  DEGRADE              :   4;    //  Degrade lane enable. (lanes
                                                 // are removed for high BER etc.)
                                                 // After a degrade occurs this
                                                 // field takes on the value of
                                                 // the new combined field. By
                                                 // observing the INIT field one
                                                 // can deduce why each lane was
                                                 // removed. If INIT is clear it
                                                 // was removed during
                                                 // initialization, otherwise it
                                                 // was removed by a degrade
                                                 // during LTP mode.
        uint64_t  Unused_63_12         :  52;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_RX_PHY_LN_EN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_TX_PHY_LN_EN desc:  This register reports the Tx side physical lane enable.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   4;    //  {lane3,lane2,lane1,lane0}
        uint64_t  Unused_63_4          :  60;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_TX_PHY_LN_EN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_ROUND_TRIP_LTP_CNT desc:  This register reports the link round trip time in terms of a LTP
// transmit time.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  16;    // 
        uint64_t  Unused_63_16         :  48;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_ROUND_TRIP_LTP_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_NULLS_REQUIRED desc:  This register reports the number of null LTPs that are required
// before reusing a replay buffer location. This is necessary to prevent
// replay buffer overrun when the link round trip is larger than the
// depth of the replay buffer.
typedef volatile union {
    struct {
        uint64_t  CNT                  :  16;    // 
        uint64_t  Unused_63_16         :  48;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_NULLS_REQUIRED_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_FLIT_QUIET_CNTR desc:  This register reports the number of replay buffer cycles that have
// transpired since the last valid flit was passed up to the core.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   3;    //  Rx side count. 3'd7 means
                                                 // quiet.
        uint64_t  Unused_63_3          :  61;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_FLIT_QUIET_CNTR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_STS_RCV_SMA_MSG desc:  This register is used by the subnet management agent (SMA) to receive
// a message from the peer SMA. The SMA software protocol must provide a
// means to indicate a new message has been received.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  48;    // 
        uint64_t  Unused_63_48         :  16;    //  Unused

    };
    uint64_t                         val;
} LCB_STS_RCV_SMA_MSG_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_RUN desc:  This register steers the LCB input mux between the BIST pattern
// generator and the real mission mode inputs.
typedef volatile union {
    struct {
        uint64_t  EN                   :   1;    //  Set high to give PG control
                                                 // of the inputs.
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_RUN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_RX_RUN desc:  The receive run enable register is the control for starting and
// stopping receive side flit and virtual channel acknowledge
// generation. This bit must be enabled whenever the transmit run bit is
// enabled in the pattern generator at the other end of the link,
// otherwise miss compares will occur.
typedef volatile union {
    struct {
        uint64_t  EN                   :   1;    //  Receive side run enable.
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_RX_RUN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_TX_RUN desc:  The transmit run enable register is the control for starting and
// stopping transmit side flit and virtual channel acknowledge
// verification. This bit must be enabled only when the receive run bit
// is enabled in the pattern generator at the other end of the link,
// otherwise miss compares will occur.
typedef volatile union {
    struct {
        uint64_t  EN                   :   1;    //  Transmit side run enable.
        uint64_t  Unused_63_1          :  63;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_TX_RUN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_CAPTURE_DELAY desc:  The capture delay register sets the length in flits between the
// occurrence of a the miscompare error flag and the hold of the capture
// buffer.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   4;    //  Delay time in cclks between
                                                 // the trigger event and the hold
                                                 // of the capture buffers.
        uint64_t  Unused_63_4          :  60;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_CAPTURE_DELAY_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_CAPTURE_RADR desc:  The register controls the capture RAMs read address.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   4;    // 
        uint64_t  EN                   :   1;    //  enable the RAM read port,
                                                 // currently not needed/used for
                                                 // the capture RAMs, leave in
                                                 // case the RAMs change
        uint64_t  Unused_63_5          :  59;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_CAPTURE_RADR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_CRDTS_LCB desc:  The initial LCB credits register sets the number of LCB flit credits
// assumed by the flit generator at reset. The LCB credits represents
// the space available in the LCB input buffer. This value may be
// decreased to throttle the flit generation rate or increased to
// explore LCB input buffer overflow.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   8;    //  Maximum outstanding LCB input
                                                 // buffer flits.
        uint64_t  Unused_63_8          :  56;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_CRDTS_LCB_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_LEN desc:  This register controls how long testing occurs.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  52;    //  Length in number of flits. A
                                                 // value of 0 is treated as
                                                 // infinite so the test never
                                                 // ends.
        uint64_t  PAUSE_MSK            :   6;    //  Flit transmission will pause
                                                 // every 2^pause_mask flits.
                                                 // Default is 1 pause per minute
                                                 // at 1Gflit/sec. 0x3f will
                                                 // prevent pauses.
        uint64_t  Unused_63_58         :   6;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_LEN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_SEED desc:  The random seed register sets the initial value of all PG LFSRs. Each
// individual LFSR uniquely alters the seed value such that each LFSR
// creates a unique sequence. The seed itself need not be random, this
// determines where in the LFSR sequence the test starts. This is most
// useful during pre silicon validation.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  55;    //  Random seed
        uint64_t  Unused_63_55         :   9;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_SEED_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_FLIT desc:  The flit parameters register controls the random selection of flit
// type and content.
typedef volatile union {
    struct {
        uint64_t  CONTENT              :   2;    //  Flit data: 0=random,
                                                 // 1=non-idle flit count,
                                                 // 2=canned pattern, 3=alternate
                                                 // between canned pattern and
                                                 // inverted canned pattern.
        uint64_t  Unused_3_2           :   2;    //  Unused
        uint64_t  ALLOW_UNEXP_TOSSED_FLITS :   1;    // 
        uint64_t  Unused_63_5          :  59;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_FLIT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_IDLE_INJECT desc:  The idle injection register controls the rate at which idles are
// injected into the transmitted flit stream. These idles are inserted
// before flit throttling is taken into consideration. These idles are
// also the idles that can contain single and double bit errors.
typedef volatile union {
    struct {
        uint64_t  THRESHOLD            :  16;    //  Random 15-bit numbers less
                                                 // than or equal to this value
                                                 // select idle flits. Setting
                                                 // equal to 0 disables idle flits
                                                 // for maximum throughput. Random
                                                 // 15-bit numbers greater than or
                                                 // equal to this value select
                                                 // non-idle flits. Setting
                                                 // greater than or equal to 32768
                                                 // disables non-idle flits.
        uint64_t  Unused_63_16         :  48;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_IDLE_INJECT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_ERR desc:  The error parameters register controls the rate of SBEs and MBEs
// injected into flits.
typedef volatile union {
    struct {
        uint64_t  SBE_THRESHOLD        :  32;    //  Random 31-bit numbers less
                                                 // than this value select flits
                                                 // for errors, either single or
                                                 // double bit errors. Setting to
                                                 // 0 disables all errors.
        uint64_t  MBE_THRESHOLD        :  16;    //  Random 15-bit numbers less
                                                 // than this value select error
                                                 // flits for double bit errors.
                                                 // Otherwise, error flits are
                                                 // single bit errors.
        uint64_t  REALISTIC            :   1;    //  0=never corrupt flit type
                                                 // encoding bits 48-46, 1=allow
                                                 // corruption of any flit bits
        uint64_t  Unused_63_49         :  15;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_ERR_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_MISCOMPARE desc:  This register controls the enables for each miscompare type.
typedef volatile union {
    struct {
        uint64_t  EN                   :   3;    //  {VL_ACK,FLIT1,FLIT0}
        uint64_t  Unused_63_3          :  61;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_MISCOMPARE_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_CFG_PATTERN desc:  The transmit canned flit pattern register supplies the data pattern
// used when canned data content is selected in the flit configuration
// register.
typedef volatile union {
    struct {
        uint64_t  DATA                 :  56;    //  Used when
                                                 // LCB_PG_CFG_FLIT_CONTENT set at
                                                 // 2.
        uint64_t  Unused_63_56         :   8;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_CFG_PATTERN_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_DBG_FLIT_CRDTS_CNT desc:  This The LCB credit debug register contains the current number of LCB
// credits in use waiting for acknowledgement. This represents the
// amount of the LCB input FIFO in use.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   8;    // 
        uint64_t  Unused_63_8          :  56;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_DBG_FLIT_CRDTS_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_ERR_INFO_MISCOMPARE_CNT desc:  The miscompare count register reports the number of flits received
// that do not match the expected flit.
typedef volatile union {
    struct {
        uint64_t  VAL                  :   8;    //  Miscompare count
        uint64_t  Unused_63_8          :  56;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_ERR_INFO_MISCOMPARE_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_STS_CAPTURE_ACTUAL_DAT0 desc:  This register is used to retrieve the data from the actual capture
// RAM.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  64;    //  flit0

    };
    uint64_t                         val;
} LCB_PG_STS_CAPTURE_ACTUAL_DAT0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_STS_CAPTURE_ACTUAL_DAT1 desc:  This register is used to retrieve the data from the actual capture
// RAM.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  64;    //  flit1

    };
    uint64_t                         val;
} LCB_PG_STS_CAPTURE_ACTUAL_DAT1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_STS_CAPTURE_ACTUAL_MISC desc:  This register is used to retrieve the data from the actual capture
// RAM.
typedef volatile union {
    struct {
        uint64_t  B64_0                :   1;    //  flit 0 bit 64
        uint64_t  B64_1                :   1;    //  flit 1 bit 64
        uint64_t  Unused_3_2           :   2;    //  Unused
        uint64_t  VL_ACK               :  10;    //  [9]: valid, [8]: odd parity,
                                                 // [7:0]: ack data
        uint64_t  Unused_15_14         :   2;    //  Unused
        uint64_t  MISCOMPARE           :   3;    //  {ack miscompare, flit 1
                                                 // miscompare, flit 0 miscompare}
        uint64_t  Unused_19            :   1;    //  Unused
        uint64_t  WADR                 :   4;    //  next address to be written,
                                                 // start read of RAM at this
                                                 // address.
        uint64_t  Unused_63_24         :  40;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_STS_CAPTURE_ACTUAL_MISC_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_STS_CAPTURE_EXPECT_DAT0 desc:  This register is used to retrieve the data from the expect capture
// RAM.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  64;    //  flit0

    };
    uint64_t                         val;
} LCB_PG_STS_CAPTURE_EXPECT_DAT0_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_STS_CAPTURE_EXPECT_DAT1 desc:  This register is used to retrieve the data from the expect capture
// RAM.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  64;    //  flit1

    };
    uint64_t                         val;
} LCB_PG_STS_CAPTURE_EXPECT_DAT1_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_STS_CAPTURE_EXPECT_MISC desc:  This register is used to retrieve the data from the expect capture
// RAM.
typedef volatile union {
    struct {
        uint64_t  B64_0                :   1;    //  flit 0 bit 64
        uint64_t  B64_1                :   1;    //  flit 1 bit 64
        uint64_t  Unused_3_2           :   2;    //  Unused
        uint64_t  VL_ACK               :   8;    //  ack expect data
        uint64_t  Unused_63_12         :  52;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_STS_CAPTURE_EXPECT_MISC_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_STS_FLG desc:  The PG status flags register monitors for errors and the first
// occurrence of some interesting conditions.
typedef volatile union {
    struct {
        uint64_t  Unused_3_0           :   4;    //  Unused
        uint64_t  TX_RX_COMPLETE       :   1;    //  Both Tx and Rx flit counts
                                                 // greater than test length
        uint64_t  Unused_7_5           :   3;    //  Unused
        uint64_t  TX_END_OF_TEST       :   1;    //  Length of test reached.
        uint64_t  Unused_11_9          :   3;    //  Unused
        uint64_t  OUT_OF_FLIT_CRDTS    :   1;    //  Lack of flit credits
        uint64_t  Unused_15_13         :   3;    //  Unused
        uint64_t  MISCOMPARE           :   3;    //  [0]: lower flit bus, [1]:
                                                 // upper flit bus, [2]: sideband
                                                 // VL ack
        uint64_t  Unused_19            :   1;    //  Unused
        uint64_t  LOST_FLIT_ACK        :   1;    //  Flit acks pending at tx pause
                                                 // or end of test
        uint64_t  Unused_23_21         :   3;    //  Unused
        uint64_t  EXTRA_FLIT_ACK       :   1;    //  Unexpected flit ack detected.
        uint64_t  Unused_63_25         :  39;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_STS_FLG_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_STS_PAUSE_COMPLETE_CNT desc:  The transmit pause complete count register reports the number of
// successful pause cycles.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  16;    //  Pause Complete count
        uint64_t  Unused_63_16         :  48;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_STS_PAUSE_COMPLETE_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_STS_TX_SBE_CNT desc:  The transmit single bit error count register reports the number of
// flits sent to the LCB with a single bit error.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  16;    //  Single bit error count
        uint64_t  Unused_63_16         :  48;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_STS_TX_SBE_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// LCB_PG_STS_TX_MBE_CNT desc:  The transmit multiple bit error count register reports the number of
// flits sent to the LCB with a multiple bit error.
typedef volatile union {
    struct {
        uint64_t  VAL                  :  16;    //  multiple bit error count
        uint64_t  Unused_63_16         :  48;    //  Unused

    };
    uint64_t                         val;
} LCB_PG_STS_TX_MBE_CNT_t;

// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    LCB_CFG_RUN_t              LCB_CFG_RUN;      // offset 4'h0, width 64
    LCB_CFG_TX_FIFOS_RESET_t   LCB_CFG_TX_FIFOS_RESET; // offset 4'h8, width 64
    LCB_CFG_TX_FIFOS_RADR_t    LCB_CFG_TX_FIFOS_RADR; // offset 8'h10, width 64
    LCB_CFG_RX_FIFOS_RADR_t    LCB_CFG_RX_FIFOS_RADR; // offset 8'h18, width 64
    LCB_CFG_IGNORE_LOST_RCLK_t LCB_CFG_IGNORE_LOST_RCLK; // offset 8'h20, width 64
    LCB_CFG_REINIT_PAUSE_t     LCB_CFG_REINIT_PAUSE; // offset 8'h28, width 64
    LCB_CFG_REINIT_AS_SLAVE_t  LCB_CFG_REINIT_AS_SLAVE; // offset 8'h30, width 64
    LCB_CFG_FORCE_RECOVER_SEQUENCE_t LCB_CFG_FORCE_RECOVER_SEQUENCE; // offset 8'h38, width 64
    LCB_CFG_CNT_FOR_SKIP_STALL_t LCB_CFG_CNT_FOR_SKIP_STALL; // offset 8'h40, width 64
    LCB_CFG_TX_FSS_t           LCB_CFG_TX_FSS;   // offset 8'h48, width 64
    LCB_CFG_RX_FSS_t           LCB_CFG_RX_FSS;   // offset 8'h50, width 64
    LCB_CFG_CRC_MODE_t         LCB_CFG_CRC_MODE; // offset 8'h58, width 64
    LCB_CFG_LN_DCLK_t          LCB_CFG_LN_DCLK;  // offset 8'h60, width 64
    LCB_CFG_LN_TEST_TIME_TO_PASS_t LCB_CFG_LN_TEST_TIME_TO_PASS; // offset 8'h68, width 64
    LCB_CFG_LN_TEST_REQ_PASS_CNT_t LCB_CFG_LN_TEST_REQ_PASS_CNT; // offset 8'h70, width 64
    LCB_CFG_LN_RE_ENABLE_t     LCB_CFG_LN_RE_ENABLE; // offset 8'h78, width 64
    LCB_CFG_RX_LN_EN_t         LCB_CFG_RX_LN_EN; // offset 8'h80, width 64
    LCB_CFG_NULLS_REQUIRED_BASE_t LCB_CFG_NULLS_REQUIRED_BASE; // offset 8'h88, width 64
    LCB_CFG_REINITS_BEFORE_LINK_LOW_t LCB_CFG_REINITS_BEFORE_LINK_LOW; // offset 8'h90, width 64
    LCB_CFG_REMOVE_RANDOM_NULLS_t LCB_CFG_REMOVE_RANDOM_NULLS; // offset 8'h98, width 64
    LCB_CFG_REPLAY_BUF_MAX_LTP_t LCB_CFG_REPLAY_BUF_MAX_LTP; // offset 12'h0A0, width 64
    LCB_CFG_THROTTLE_TX_FLITS_t LCB_CFG_THROTTLE_TX_FLITS; // offset 12'h0A8, width 64
    LCB_CFG_TX_SWIZZLE_t       LCB_CFG_TX_SWIZZLE; // offset 12'h0B0, width 64
    LCB_CFG_SEND_SMA_MSG_t     LCB_CFG_SEND_SMA_MSG; // offset 12'h0B8, width 64
    LCB_CFG_INCOMPLT_RND_TRIP_DISABLE_t LCB_CFG_INCOMPLT_RND_TRIP_DISABLE; // offset 12'h0C0, width 64
    LCB_CFG_RND_TRIP_MAX_t     LCB_CFG_RND_TRIP_MAX; // offset 12'h0C8, width 64
    LCB_CFG_LINK_TIMER_DISABLE_t LCB_CFG_LINK_TIMER_DISABLE; // offset 12'h0D0, width 64
    LCB_CFG_LINK_TIMER_MAX_t   LCB_CFG_LINK_TIMER_MAX; // offset 12'h0D8, width 64
    LCB_CFG_DESKEW_t           LCB_CFG_DESKEW;   // offset 12'h0E0, width 64
    LCB_CFG_LN_DEGRADE_t       LCB_CFG_LN_DEGRADE; // offset 12'h0E8, width 64
    LCB_CFG_CRC_INTERRUPT_t    LCB_CFG_CRC_INTERRUPT; // offset 12'h0F0, width 64
    LCB_CFG_LOOPBACK_t         LCB_CFG_LOOPBACK; // offset 12'h0F8, width 64
    LCB_CFG_LANE_WIDTH_t       LCB_CFG_LANE_WIDTH; // offset 12'h100, width 64
    LCB_CFG_MISC_t             LCB_CFG_MISC;     // offset 12'h108, width 64
    LCB_CFG_CLK_CNTR_t         LCB_CFG_CLK_CNTR; // offset 12'h110, width 64
    LCB_CFG_CRC_CNTR_RESET_t   LCB_CFG_CRC_CNTR_RESET; // offset 12'h118, width 64
    LCB_CFG_LINK_KILL_EN_t     LCB_CFG_LINK_KILL_EN; // offset 12'h120, width 64
    LCB_CFG_ALLOW_LINK_UP_t    LCB_CFG_ALLOW_LINK_UP; // offset 12'h128, width 64
    LCB_DBG_ERRINJ_CRC_0_t     LCB_DBG_ERRINJ_CRC_0; // offset 12'h200, width 64
    LCB_DBG_ERRINJ_CRC_1_t     LCB_DBG_ERRINJ_CRC_1; // offset 12'h208, width 64
    LCB_DBG_ERRINJ_ECC_t       LCB_DBG_ERRINJ_ECC; // offset 12'h210, width 64
    LCB_DBG_ERRINJ_MISC_t      LCB_DBG_ERRINJ_MISC; // offset 12'h218, width 64
    LCB_DBG_INIT_STATE_0_t     LCB_DBG_INIT_STATE_0; // offset 12'h240, width 64
    LCB_DBG_INIT_STATE_1_t     LCB_DBG_INIT_STATE_1; // offset 12'h248, width 64
    LCB_DBG_INIT_STATE_2_t     LCB_DBG_INIT_STATE_2; // offset 12'h250, width 64
    LCB_DBG_CFG_GOOD_BAD_DATA_t LCB_DBG_CFG_GOOD_BAD_DATA; // offset 12'h258, width 64
    LCB_DBG_STS_GOOD_BAD_DATA_t LCB_DBG_STS_GOOD_BAD_DATA; // offset 12'h260, width 64
    LCB_DBG_STS_GOOD_BAD_DAT0_t LCB_DBG_STS_GOOD_BAD_DAT0; // offset 12'h268, width 64
    LCB_DBG_STS_GOOD_BAD_DAT1_t LCB_DBG_STS_GOOD_BAD_DAT1; // offset 12'h270, width 64
    LCB_DBG_STS_GOOD_BAD_DAT2_t LCB_DBG_STS_GOOD_BAD_DAT2; // offset 12'h278, width 64
    LCB_DBG_STS_GOOD_BAD_DAT3_t LCB_DBG_STS_GOOD_BAD_DAT3; // offset 12'h280, width 64
    LCB_DBG_STS_XFR_ERR_STATS_t LCB_DBG_STS_XFR_ERR_STATS; // offset 12'h288, width 64
    LCB_ERR_FLG_t              LCB_ERR_FLG;      // offset 12'h300, width 64
    LCB_ERR_CLR_t              LCB_ERR_CLR;      // offset 12'h308, width 64
    LCB_ERR_EN_t               LCB_ERR_EN;       // offset 12'h310, width 64
    LCB_ERR_FIRST_FLG_t        LCB_ERR_FIRST_FLG; // offset 12'h318, width 64
    LCB_ERR_INFO_TOTAL_CRC_ERR_t LCB_ERR_INFO_TOTAL_CRC_ERR; // offset 12'h320, width 64
    LCB_ERR_INFO_CRC_ERR_LN0_t LCB_ERR_INFO_CRC_ERR_LN0; // offset 12'h328, width 64
    LCB_ERR_INFO_CRC_ERR_LN1_t LCB_ERR_INFO_CRC_ERR_LN1; // offset 12'h330, width 64
    LCB_ERR_INFO_CRC_ERR_LN2_t LCB_ERR_INFO_CRC_ERR_LN2; // offset 12'h338, width 64
    LCB_ERR_INFO_CRC_ERR_LN3_t LCB_ERR_INFO_CRC_ERR_LN3; // offset 12'h340, width 64
    LCB_ERR_INFO_CRC_ERR_MULTI_LN_t LCB_ERR_INFO_CRC_ERR_MULTI_LN; // offset 12'h348, width 64
    LCB_ERR_INFO_TX_REPLAY_CNT_t LCB_ERR_INFO_TX_REPLAY_CNT; // offset 12'h350, width 64
    LCB_ERR_INFO_RX_REPLAY_CNT_t LCB_ERR_INFO_RX_REPLAY_CNT; // offset 12'h358, width 64
    LCB_ERR_INFO_SEQ_CRC_CNT_t LCB_ERR_INFO_SEQ_CRC_CNT; // offset 12'h360, width 64
    LCB_ERR_INFO_ESCAPE_0_ONLY_CNT_t LCB_ERR_INFO_ESCAPE_0_ONLY_CNT; // offset 12'h368, width 64
    LCB_ERR_INFO_ESCAPE_0_PLUS1_CNT_t LCB_ERR_INFO_ESCAPE_0_PLUS1_CNT; // offset 12'h370, width 64
    LCB_ERR_INFO_ESCAPE_0_PLUS2_CNT_t LCB_ERR_INFO_ESCAPE_0_PLUS2_CNT; // offset 12'h378, width 64
    LCB_ERR_INFO_REINIT_FROM_PEER_CNT_t LCB_ERR_INFO_REINIT_FROM_PEER_CNT; // offset 12'h380, width 64
    LCB_ERR_INFO_SBE_CNT_t     LCB_ERR_INFO_SBE_CNT; // offset 12'h388, width 64
    LCB_ERR_INFO_MISC_FLG_CNT_t LCB_ERR_INFO_MISC_FLG_CNT; // offset 12'h390, width 64
    LCB_ERR_INFO_ECC_INPUT_BUF_HGH_t LCB_ERR_INFO_ECC_INPUT_BUF_HGH; // offset 12'h398, width 64
    LCB_ERR_INFO_ECC_INPUT_BUF_LOW_t LCB_ERR_INFO_ECC_INPUT_BUF_LOW; // offset 12'h3A0, width 64
    LCB_ERR_INFO_ECC_REPLAY_BUF_HGH_t LCB_ERR_INFO_ECC_REPLAY_BUF_HGH; // offset 12'h3A8, width 64
    LCB_ERR_INFO_ECC_REPLAY_BUF_LOW_t LCB_ERR_INFO_ECC_REPLAY_BUF_LOW; // offset 12'h3B0, width 64
    LCB_PRF_GOOD_LTP_CNT_t     LCB_PRF_GOOD_LTP_CNT; // offset 12'h400, width 64
    LCB_PRF_ACCEPTED_LTP_CNT_t LCB_PRF_ACCEPTED_LTP_CNT; // offset 12'h408, width 64
    LCB_PRF_RX_FLIT_CNT_t      LCB_PRF_RX_FLIT_CNT; // offset 12'h410, width 64
    LCB_PRF_TX_FLIT_CNT_t      LCB_PRF_TX_FLIT_CNT; // offset 12'h418, width 64
    LCB_PRF_CLK_CNTR_t         LCB_PRF_CLK_CNTR; // offset 12'h420, width 64
    LCB_STS_LINK_PAUSE_ACTIVE_t LCB_STS_LINK_PAUSE_ACTIVE; // offset 12'h460, width 64
    LCB_STS_LINK_TRANSFER_ACTIVE_t LCB_STS_LINK_TRANSFER_ACTIVE; // offset 12'h468, width 64
    LCB_STS_LN_DEGRADE_t       LCB_STS_LN_DEGRADE; // offset 12'h470, width 64
    LCB_STS_TX_LTP_MODE_t      LCB_STS_TX_LTP_MODE; // offset 12'h478, width 64
    LCB_STS_RX_LTP_MODE_t      LCB_STS_RX_LTP_MODE; // offset 12'h480, width 64
    LCB_STS_RX_CRC_MODE_t      LCB_STS_RX_CRC_MODE; // offset 12'h488, width 64
    LCB_STS_RX_LOGICAL_ID_t    LCB_STS_RX_LOGICAL_ID; // offset 12'h490, width 64
    LCB_STS_RX_SHIFTED_LN_NUM_t LCB_STS_RX_SHIFTED_LN_NUM; // offset 12'h498, width 64
    LCB_STS_RX_PHY_LN_EN_t     LCB_STS_RX_PHY_LN_EN; // offset 12'h4A0, width 64
    LCB_STS_TX_PHY_LN_EN_t     LCB_STS_TX_PHY_LN_EN; // offset 12'h4A8, width 64
    LCB_STS_ROUND_TRIP_LTP_CNT_t LCB_STS_ROUND_TRIP_LTP_CNT; // offset 12'h4B0, width 64
    LCB_STS_NULLS_REQUIRED_t   LCB_STS_NULLS_REQUIRED; // offset 12'h4B8, width 64
    LCB_STS_FLIT_QUIET_CNTR_t  LCB_STS_FLIT_QUIET_CNTR; // offset 12'h4C0, width 64
    LCB_STS_RCV_SMA_MSG_t      LCB_STS_RCV_SMA_MSG; // offset 12'h4C8, width 64
    LCB_PG_CFG_RUN_t           LCB_PG_CFG_RUN;   // offset 12'h500, width 64
    LCB_PG_CFG_RX_RUN_t        LCB_PG_CFG_RX_RUN; // offset 12'h508, width 64
    LCB_PG_CFG_TX_RUN_t        LCB_PG_CFG_TX_RUN; // offset 12'h510, width 64
    LCB_PG_CFG_CAPTURE_DELAY_t LCB_PG_CFG_CAPTURE_DELAY; // offset 12'h518, width 64
    LCB_PG_CFG_CAPTURE_RADR_t  LCB_PG_CFG_CAPTURE_RADR; // offset 12'h520, width 64
    LCB_PG_CFG_CRDTS_LCB_t     LCB_PG_CFG_CRDTS_LCB; // offset 12'h528, width 64
    LCB_PG_CFG_LEN_t           LCB_PG_CFG_LEN;   // offset 12'h530, width 64
    LCB_PG_CFG_SEED_t          LCB_PG_CFG_SEED;  // offset 12'h538, width 64
    LCB_PG_CFG_FLIT_t          LCB_PG_CFG_FLIT;  // offset 12'h540, width 64
    LCB_PG_CFG_IDLE_INJECT_t   LCB_PG_CFG_IDLE_INJECT; // offset 12'h548, width 64
    LCB_PG_CFG_ERR_t           LCB_PG_CFG_ERR;   // offset 12'h550, width 64
    LCB_PG_CFG_MISCOMPARE_t    LCB_PG_CFG_MISCOMPARE; // offset 12'h558, width 64
    LCB_PG_CFG_PATTERN_t       LCB_PG_CFG_PATTERN; // offset 12'h560, width 64
    LCB_PG_DBG_FLIT_CRDTS_CNT_t LCB_PG_DBG_FLIT_CRDTS_CNT; // offset 12'h580, width 64
    LCB_PG_ERR_INFO_MISCOMPARE_CNT_t LCB_PG_ERR_INFO_MISCOMPARE_CNT; // offset 12'h588, width 64
    LCB_PG_STS_CAPTURE_ACTUAL_DAT0_t LCB_PG_STS_CAPTURE_ACTUAL_DAT0; // offset 12'h5C0, width 64
    LCB_PG_STS_CAPTURE_ACTUAL_DAT1_t LCB_PG_STS_CAPTURE_ACTUAL_DAT1; // offset 12'h5C8, width 64
    LCB_PG_STS_CAPTURE_ACTUAL_MISC_t LCB_PG_STS_CAPTURE_ACTUAL_MISC; // offset 12'h5D0, width 64
    LCB_PG_STS_CAPTURE_EXPECT_DAT0_t LCB_PG_STS_CAPTURE_EXPECT_DAT0; // offset 12'h5D8, width 64
    LCB_PG_STS_CAPTURE_EXPECT_DAT1_t LCB_PG_STS_CAPTURE_EXPECT_DAT1; // offset 12'h5E0, width 64
    LCB_PG_STS_CAPTURE_EXPECT_MISC_t LCB_PG_STS_CAPTURE_EXPECT_MISC; // offset 12'h5E8, width 64
    LCB_PG_STS_FLG_t           LCB_PG_STS_FLG;   // offset 12'h5F0, width 64
    LCB_PG_STS_PAUSE_COMPLETE_CNT_t LCB_PG_STS_PAUSE_COMPLETE_CNT; // offset 12'h5F8, width 64
    LCB_PG_STS_TX_SBE_CNT_t    LCB_PG_STS_TX_SBE_CNT; // offset 12'h600, width 64
    LCB_PG_STS_TX_MBE_CNT_t    LCB_PG_STS_TX_MBE_CNT; // offset 12'h608, width 64
} fc_lcb_csrs_t;                                 // size:  12'h610
