// SPDX-License-Identifier: GPL-2.0
/*
 * Copyright (C) 2018 Intel Corporation
 * Author: Fenghua Yu <fenghua.yu@intel.com>
 *
 * Pre-request:
 * Run the test as root.
 *
 * Usage:
 * Run the test alone and it should show:
 *
 * Or launch the test from perf and watch "sq_misc.split_lock" event count.
 * #/perf stat -e sq_misc.split_lock /root/split_lock_user_test_64
 *
 * Performance counter stats for 'tools/testing/selftests/x86/
 * split_lock_user_test_64':
 *		1      sq_misc.split_lock
 *
 *	1.001507372 seconds time elapsed
 */
#define _GNU_SOURCE

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <stdlib.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>

int split_lock_exception;

void catch_sigbus(int sig)
{
	split_lock_exception = 1;
	printf("Caught SIGBUS/#AC due to split locked access\n");

	exit(-1);
}

/*
 * Atomically add 1 to *iptr using "lock addl" instruction.
 * Since *iptr crosses two cache lines, #AC is generated by the split lock.
 */
void do_split_locked_inst(int *iptr)
{
	/*
	 * The distance between iptr and next cache line is 3 bytes.
	 * Operand size in "addl" is 4 bytes. So iptr will span two cache
	 * lines. "lock addl" instruction will trigger #AC in hardware
	 * and kernel either delivers SIGBUS to this process or re-execute
	 * the instruction depending on
	 * /sys/kernel/debug/x86/split_lock/user_mode setting.
	 */
	asm volatile ("lock addl $1, %0\n\t"
		      : "=m" (*iptr));
}

/*
 * Test SIGBUS delivered after a lock instruction generates #AC for split lock
 * operand *iptr.
 */
void test_sigbus(int *iptr)
{
	pid_t pid;

	pid = fork();
	if (pid)
		return;

	/*
	 * The locked instruction will trigger #AC and kernel will deliver
	 * SIGBUS to this process. The SIGBUS handler in this process will
	 * verify that the signal is delivered and the process is killed then.
	 */
	do_split_locked_inst(iptr);
}

int main(int argc, char **argv)
{
	int *iptr;
	char *cptr;

	signal(SIGBUS, catch_sigbus);

	/*
	 * Enable Alignment Checking on x86_64.
	 * This will generate alignment check on not only split lock but also
	 * on any misalignment.
	 * Turn on this for reference only.
	 */
	/* __asm__("pushf\norl $0x40000,(%rsp)\npopf"); */

	/* aligned_alloc() provides 64-byte aligned memory */
	cptr = (char *)aligned_alloc(64, 128);

	/*
	 * Increment the pointer by 61, making it 3 bytes away from the next
	 * cache line and 4-byte *iptr across two cache line.
	 */
	iptr = (int *)(cptr + 61);

	test_sigbus(iptr);

	free(cptr);

	return 0;
}
