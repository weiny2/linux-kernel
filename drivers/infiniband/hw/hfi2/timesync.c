/*
 * Intel Omni-Path Architecture (OPA) Host Fabric Software
 *
 * This file is provided under a dual BSD/GPLv2 license.  When using or
 * redistributing this file, you may do so under either license.
 *
 * GPL LICENSE SUMMARY
 *
 * Copyright (c) 2015 Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2, as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * BSD LICENSE
 *
 * Copyright (c) 2015 Intel Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *  * Neither the name of Intel Corporation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <linux/ptp_clock_kernel.h>
#include <linux/ptp_classify.h>
#include <linux/mutex.h>
#include "hfi2.h"
#include "link.h"
#include "timesync.h"

#define HACK_TIMESYNC_1 (FXR_CRK_LCB_CSRS + 0x70)

#define TS_FAILOVER_0	(FXR_CRK_LCB_CSRS + 0x78)
#define TS_FAILOVER_1	(FXR_CRK_LCB_CSRS + 0x80)
#define TS_FAILOVER_2	(FXR_CRK_LCB_CSRS + 0x88)
#define TS_FAILOVER_3	(FXR_CRK_LCB_CSRS + 0x90)

static int last_clock_id = -1;
static u64 saved_hack_timesync;

static void simics_update_hack_timesync(struct hfi_pportdata *ppd,
					u8 enable,
					u8 clock_id,
					u8 time_inc_shift,
					u16 snap_freq);
static void simics_decode(u32 *enable, u32 *time_inc_shift, u32 *snap_freq);

/**
 * hfi_read_local_time - Read the PHC time from the device
 * @ppd: Board private structure
 * @ts: timespec structure to hold the current time value
 *
 * This function reads the local time register and stores it in a
 * timespec. However, since the register is 64 bits of nanoseconds, we must
 * convert the result to a timespec before we can return.
 **/
static void hfi_read_local_time(struct hfi_pportdata *ppd,
				struct timespec64 *ts)
{
	u64 ns;

	ns = read_csr(ppd->dd, OC_LCB_STS_UPPER_LOCAL_TIME);
	*ts = ns_to_timespec64(ns);
}

/**
 * hfi_write_local_time - Write the PHC time to the device
 * @ppd: Board private structure
 * @ts: timespec structure that holds the new time value
 *
 * This function writes the local time register with the user value. Since
 * we receive a timespec from the stack, we must convert that timespec into
 * nanoseconds before programming the register.
 **/
static void hfi_write_local_time(struct hfi_pportdata *ppd,
				 const struct timespec64 *ts)
{
	u64 ns = timespec64_to_ns(ts);

	write_csr(ppd->dd, OC_LCB_STS_UPPER_LOCAL_TIME, ns);
}

/*
 * Convert a 38 bit binary fixed point number to a decimal fixedpoint number.
 * The integer part is 6 bits.  The fraction is 32 bits.
 */
static u64 fixedpoint_to_decimal_fixedpoint(u64 num)
{
	u64 result = 0;
	u64 num1 = num;
	int i;
	int j = 1;

	result = ((num1 >> 32) & 0x3fUL) * 10000000000ULL;
	num1 &= 0xffffffff;

	for (i = 31; i >= 0; i--) {
		if ((1 << i) & num1)
			result += 10000000000ULL / (1ULL << j);
		j++;
	}
	return result;
}

#define HFI_DEC_FIX_FMT "%lld.%010lld"
#define HFI_DEC_FIX_DIV(num) (fixedpoint_to_decimal_fixedpoint(num) / \
			      10000000000ULL)
#define HFI_DEC_FIX_MOD(num) (fixedpoint_to_decimal_fixedpoint(num) % \
			      10000000000ULL)

/* This table is generated by fixedpoint.c, found in fxr-timesync_tools */
static const u64 adjfreq[] = {
/*      binary fixedpt     index   freq  decimal representation */
	0x3ffffffffaULL,	/* i=0     63	 63.999999999 */
	0x3eff529fd0ULL,	/* i=1     62	 62.997354496 */
	0x3dfea53fa4ULL,	/* i=2     61	 61.994708994 */
	0x3cfdf7df78ULL,	/* i=3     60	 60.992063491 */
	0x3bfd4a7f4eULL,	/* i=4     59	 59.989417988 */
	0x3afc9d1f22ULL,	/* i=5     58	 58.986772486 */
	0x39fbefbef6ULL,	/* i=6     57	 57.984126983 */
	0x38fb425eccULL,	/* i=7     56	 56.981481481 */
	0x37fa94fea0ULL,	/* i=8     55	 55.978835978 */
	0x36f9e79e76ULL,	/* i=9     54	 54.976190475 */
	0x35f93a3e4aULL,	/* i=10    53	 53.973544973 */
	0x34f88cde1eULL,	/* i=11    52	 52.970899470 */
	0x33f7df7df4ULL,	/* i=12    51	 51.968253967 */
	0x32f7321dc8ULL,	/* i=13    50	 50.965608465 */
	0x31f684bd9cULL,	/* i=14    49	 49.962962962 */
	0x30f5d75d72ULL,	/* i=15    48	 48.960317459 */
	0x2ff529fd46ULL,	/* i=16    47	 47.957671957 */
	0x2ef47c9d1aULL,	/* i=17    46	 46.955026454 */
	0x2df3cf3cf0ULL,	/* i=18    45	 45.952380952 */
	0x2cf321dcc4ULL,	/* i=19    44	 44.949735449 */
	0x2bf2747c98ULL,	/* i=20    43	 43.947089946 */
	0x2af1c71c6eULL,	/* i=21    42	 42.944444444 */
	0x29f119bc42ULL,	/* i=22    41	 41.941798941 */
	0x28f06c5c16ULL,	/* i=23    40	 40.939153438 */
	0x27efbefbecULL,	/* i=24    39	 39.936507936 */
	0x26ef119bc0ULL,	/* i=25    38	 38.933862433 */
	0x25ee643b94ULL,	/* i=26    37	 37.931216930 */
	0x24edb6db6aULL,	/* i=27    36	 36.928571428 */
	0x23ed097b3eULL,	/* i=28    35	 35.925925925 */
	0x22ec5c1b14ULL,	/* i=29    34	 34.923280423 */
	0x21ebaebae8ULL,	/* i=30    33	 33.920634920 */
	0x20eb015abcULL,	/* i=31    32	 32.917989417 */
	0x1fea53fa92ULL,	/* i=32    31	 31.915343915 */
	0x1ee9a69a66ULL,	/* i=33    30	 30.912698412 */
	0x1de8f93a3aULL,	/* i=34    29	 29.910052909 */
	0x1ce84bda10ULL,	/* i=35    28	 28.907407407 */
	0x1be79e79e4ULL,	/* i=36    27	 27.904761904 */
	0x1ae6f119b8ULL,	/* i=37    26	 26.902116402 */
	0x19e643b98eULL,	/* i=38    25	 25.899470899 */
	0x18e5965962ULL,	/* i=39    24	 24.896825396 */
	0x17e4e8f936ULL,	/* i=40    23	 23.894179894 */
	0x16e43b990cULL,	/* i=41    22	 22.891534391 */
	0x15e38e38e0ULL,	/* i=42    21	 21.888888888 */
	0x14e2e0d8b4ULL,	/* i=43    20	 20.886243386 */
	0x13e233788aULL,	/* i=44    19	 19.883597883 */
	0x12e186185eULL,	/* i=45    18	 18.880952380 */
	0x11e0d8b832ULL,	/* i=46    17	 17.878306878 */
	0x10e02b5808ULL,	/* i=47    16	 16.875661375 */
	0xfdf7df7dcULL,	/* i=48    15	 15.873015873 */
	0xeded097b2ULL,	/* i=49    14	 14.870370370 */
	0xdde233786ULL,	/* i=50    13	 13.867724867 */
	0xcdd75d75aULL,	/* i=51    12	 12.865079365 */
	0xbdcc87730ULL,	/* i=52    11	 11.862433862 */
	0xadc1b1704ULL,	/* i=53    10	 10.859788359 */
	0x9db6db6d8ULL,	/* i=54     9	  9.857142857 */
	0x8dac056aeULL,	/* i=55     8	  8.854497354 */
	0x7da12f682ULL,	/* i=56     7	  7.851851851 */
	0x6d9659656ULL,	/* i=57     6	  6.849206349 */
	0x5d8b8362cULL,	/* i=58     5	  5.846560846 */
	0x4d80ad600ULL,	/* i=59     4	  4.843915344 */
	0x3d75d75d4ULL,	/* i=60     3	  3.841269841 */
	0x2d6b015aaULL,	/* i=61     2	  2.838624338 */
	0x1d602b57eULL,	/* i=62     1	  1.835978836 */
	0xd5555554ULL,	/* i=63     0	  0.833333333 */
	0xd1fffffeULL,	/* i=64    -1	  0.820312500 */
	0xceaaaaaaULL,	/* i=65    -2	  0.807291667 */
	0xcb555554ULL,	/* i=66    -3	  0.794270833 */
	0xc7fffffeULL,	/* i=67    -4	  0.781250000 */
	0xc4aaaaaaULL,	/* i=68    -5	  0.768229167 */
	0xc1555554ULL,	/* i=69    -6	  0.755208333 */
	0xbdfffffeULL,	/* i=70    -7	  0.742187500 */
	0xbaaaaaaaULL,	/* i=71    -8	  0.729166667 */
	0xb7555554ULL,	/* i=72    -9	  0.716145833 */
	0xb3fffffeULL,	/* i=73   -10	  0.703125000 */
	0xb0aaaaaaULL,	/* i=74   -11	  0.690104167 */
	0xad555554ULL,	/* i=75   -12	  0.677083333 */
	0xa9fffffeULL,	/* i=76   -13	  0.664062500 */
	0xa6aaaaaaULL,	/* i=77   -14	  0.651041667 */
	0xa3555554ULL,	/* i=78   -15	  0.638020833 */
	0x9ffffffeULL,	/* i=79   -16	  0.625000000 */
	0x9caaaaaaULL,	/* i=80   -17	  0.611979167 */
	0x99555554ULL,	/* i=81   -18	  0.598958333 */
	0x95fffffeULL,	/* i=82   -19	  0.585937500 */
	0x92aaaaaaULL,	/* i=83   -20	  0.572916667 */
	0x8f555554ULL,	/* i=84   -21	  0.559895833 */
	0x8bfffffeULL,	/* i=85   -22	  0.546875000 */
	0x88aaaaaaULL,	/* i=86   -23	  0.533854167 */
	0x85555554ULL,	/* i=87   -24	  0.520833333 */
	0x81fffffeULL,	/* i=88   -25	  0.507812500 */
	0x7eaaaaaaULL,	/* i=89   -26	  0.494791667 */
	0x7b555554ULL,	/* i=90   -27	  0.481770833 */
	0x77fffffeULL,	/* i=91   -28	  0.468750000 */
	0x74aaaaaaULL,	/* i=92   -29	  0.455729167 */
	0x71555554ULL,	/* i=93   -30	  0.442708333 */
	0x6dfffffeULL,	/* i=94   -31	  0.429687500 */
	0x6aaaaaaaULL,	/* i=95   -32	  0.416666667 */
	0x67555554ULL,	/* i=96   -33	  0.403645833 */
	0x63fffffeULL,	/* i=97   -34	  0.390625000 */
	0x60aaaaaaULL,	/* i=98   -35	  0.377604167 */
	0x5d555554ULL,	/* i=99   -36	  0.364583333 */
	0x59fffffeULL,	/* i=100  -37	  0.351562500 */
	0x56aaaaaaULL,	/* i=101  -38	  0.338541667 */
	0x53555554ULL,	/* i=102  -39	  0.325520833 */
	0x4ffffffeULL,	/* i=103  -40	  0.312500000 */
	0x4caaaaaaULL,	/* i=104  -41	  0.299479167 */
	0x49555554ULL,	/* i=105  -42	  0.286458333 */
	0x45fffffeULL,	/* i=106  -43	  0.273437500 */
	0x42aaaaaaULL,	/* i=107  -44	  0.260416667 */
	0x3f555554ULL,	/* i=108  -45	  0.247395833 */
	0x3bfffffeULL,	/* i=109  -46	  0.234375000 */
	0x38aaaaaaULL,	/* i=110  -47	  0.221354167 */
	0x35555554ULL,	/* i=111  -48	  0.208333333 */
	0x31fffffeULL,	/* i=112  -49	  0.195312500 */
	0x2eaaaaaaULL,	/* i=113  -50	  0.182291667 */
	0x2b555554ULL,	/* i=114  -51	  0.169270833 */
	0x27fffffeULL,	/* i=115  -52	  0.156250000 */
	0x24aaaaaaULL,	/* i=116  -53	  0.143229167 */
	0x21555554ULL,	/* i=117  -54	  0.130208333 */
	0x1dfffffeULL,	/* i=118  -55	  0.117187500 */
	0x1aaaaaaaULL,	/* i=119  -56	  0.104166667 */
	0x17555554ULL,	/* i=120  -57	  0.091145833 */
	0x13fffffeULL,	/* i=121  -58	  0.078125000 */
	0x10aaaaaaULL,	/* i=122  -59	  0.065104167 */
	0xd555554ULL,	/* i=123  -60	  0.052083333 */
	0x9fffffeULL,	/* i=124  -61	  0.039062500 */
	0x6aaaaaaULL,	/* i=125  -62	  0.026041667 */
	0x3555554ULL,	/* i=126  -63	  0.013020833 */
};

/**
 * hfi_adjfreq - Adjust the PHC frequency
 * @ptp: The PTP clock structure
 * @ppb: Parts per billion adjustment from the base
 *
 * Adjust the frequency of the PHC by the indicated parts per billion from the
 * base frequency.
 **/
static int hfi_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
{
	struct hfi_pportdata *ppd = container_of(ptp, struct hfi_pportdata,
						 ptp_caps);
	u64 adj;
	int neg_adj = 0;

	ppd_dev_dbg(ppd, "adjfreq ppb %d\n", ppb);

	/* The adjfreq table contains small adjustments to the frequency.
	 * For Simics the range of values has been reduced.
	 */

	if (ppb < 0) {
		neg_adj = 1;
		ppb = -ppb;
	}

	if (neg_adj) {
		adj = adjfreq[ppb + 63];
		ppd_dev_dbg(ppd, "adjfreq ppb -%d idx %d %llx=" HFI_DEC_FIX_FMT
			    "\n", ppb, ppb + 63, adj, HFI_DEC_FIX_DIV(adj),
			    HFI_DEC_FIX_MOD(adj));
	} else {
		if (ppb == 0) {
			adj = adjfreq[63];
			ppd_dev_dbg(ppd, "adjfreq ppb %d idx %d %llx="
				    HFI_DEC_FIX_FMT "\n", ppb, 63,
				    adj, HFI_DEC_FIX_DIV(adj),
				    HFI_DEC_FIX_MOD(adj));
		} else {
			ppb = 1; /* Reduce for Simics */
			adj = adjfreq[63 - ppb];
			ppd_dev_dbg(ppd, "adjfreq ppb %d idx %d %llx="
			       HFI_DEC_FIX_FMT "\n", ppb, 63 - ppb, adj,
				    HFI_DEC_FIX_DIV(adj), HFI_DEC_FIX_MOD(adj));
		}
	}

	write_csr(ppd->dd, OC_LCB_CFG_TIME_SYNC_1, adj &
		      OC_LCB_CFG_TIME_SYNC_1_TSYN_INC_MASK);
	return 0;
}

/**
 * hfi_adjtime - Adjust the PHC time
 * @ptp: The PTP clock structure
 * @delta: Offset in nanoseconds to adjust the PHC
 *
 * Adjust the time of the PHC by the indicated delta using read/modify/write.
 **/
static int hfi_adjtime(struct ptp_clock_info *ptp, s64 delta)
{
	struct hfi_pportdata *ppd = container_of(ptp, struct hfi_pportdata,
						 ptp_caps);
	struct timespec64 now, then = ns_to_timespec64(delta);
	unsigned long flags;

	spin_lock_irqsave(&ppd->tmreg_lock, flags);

	hfi_read_local_time(ppd, &now);
	now = timespec64_add(now, then);
	hfi_write_local_time(ppd, (struct timespec64 *)&now);

	spin_unlock_irqrestore(&ppd->tmreg_lock, flags);
	return 0;
}

/**
 * hfi_gettime - Get the time of the PHC
 * @ptp: The PTP clock structure
 * @ts: timespec structure to hold the current time value
 *
 * Read the device clock and return the correct value on ns, after converting it
 * into a timespec struct.
 **/
static int hfi_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)
{
	struct hfi_pportdata *ppd = container_of(ptp, struct hfi_pportdata,
						 ptp_caps);
	unsigned long flags;

	spin_lock_irqsave(&ppd->tmreg_lock, flags);
	hfi_read_local_time(ppd, ts);
	spin_unlock_irqrestore(&ppd->tmreg_lock, flags);

	return 0;
}

/**
 * hfi_settime - Set the time of the PHC
 * @ptp: The PTP clock structure
 * @ts: timespec structure that holds the new time value
 *
 * Set the device clock to the user input value. The conversion from timespec
 * to ns happens in the write function.
 **/
static int hfi_settime(struct ptp_clock_info *ptp,
		       const struct timespec64 *ts)
{
	struct hfi_pportdata *ppd = container_of(ptp, struct hfi_pportdata,
						 ptp_caps);
	unsigned long flags;

	spin_lock_irqsave(&ppd->tmreg_lock, flags);
	hfi_write_local_time(ppd, ts);
	spin_unlock_irqrestore(&ppd->tmreg_lock, flags);

	return 0;
}

/**
 * hfi_feature_enable - Enable/disable ancillary features of the PHC
 * subsystem
 * @ptp: The PTP clock structure
 * @rq: The requested feature to change
 * @on: Enable/disable flag
 *
 * The XL710 does not support any of the ancillary features of the PHC
 * subsystem, so this function may just return.
 **/
static int hfi_feature_enable(struct ptp_clock_info *ptp,
			      struct ptp_clock_request *rq, int on)
{
	return -EOPNOTSUPP;
}

/**
 * hfi_create_clock - Create PTP clock device for userspace
 * @ppd: Board private structure
 *
 * This function creates a new PTP clock device. It only creates one if we
 * don't already have one, so it is safe to call. Will return error if it
 * can't create one, but success if we already have a device. Should be used
 * by hfi_timesync_init to create clock initially, and prevent global resets
 * from creating new clock devices.
 **/
static long hfi_create_clock(struct hfi_pportdata *ppd)
{
	/* no need to create a clock device if we already have one */
	if (!IS_ERR_OR_NULL(ppd->ptp_clock))
		return 0;

	strncpy(ppd->ptp_caps.name, KBUILD_MODNAME, sizeof(ppd->ptp_caps.name));
	ppd->ptp_caps.owner = THIS_MODULE;
	ppd->ptp_caps.max_adj = 63;
	ppd->ptp_caps.n_ext_ts = 0;
	ppd->ptp_caps.pps = 0;
	ppd->ptp_caps.adjfreq = hfi_adjfreq;
	ppd->ptp_caps.adjtime = hfi_adjtime;
	ppd->ptp_caps.gettime64 = hfi_gettime;
	ppd->ptp_caps.settime64 = hfi_settime;
	ppd->ptp_caps.enable = hfi_feature_enable;

	/* Attempt to register the clock */
	ppd->ptp_clock = ptp_clock_register(&ppd->ptp_caps,
					    &ppd->dd->pdev->dev);

	return PTR_ERR_OR_ZERO(ppd->ptp_clock);
}

/**
 * hfi_timesync_init - Initialize timesync support after link training
 * @ppd: Port specific structure
 *
 * Initialize support for timesync in the Intel OPA fabic. The first time it
 * is run, it will create a PHC clock device. It does not create a clock
 * device if one already exists. It also reconfigures the device after a reset.
 **/
void hfi_timesync_init(struct hfi_pportdata *ppd)
{
	long err;

	/* Skip if already initialized */
	if (ppd->ptp_clock)
		return;

	/* we have to initialize the lock first, since we can't control
	 * when the user will enter the PHC device entry points
	 */
	spin_lock_init(&ppd->tmreg_lock);

	/* Mutex to separate init and stop */
	mutex_init(&ppd->timesync_mutex);
	mutex_lock(&ppd->timesync_mutex);

	/* ensure we have a clock device */
	err = hfi_create_clock(ppd);

	if (err) {
		ppd->ptp_clock = NULL;
		dd_dev_err(ppd->dd, "Timesync initialization failed");
	} else {
		ppd->ptp_index = ptp_clock_index(ppd->ptp_clock);
#if 0
		/* FXRTODO: complete this for FXR timesync when registers
		 * are functional
		 */
		struct timespec64 ts;
		u32 regval;
#endif
		ppd_dev_info(ppd, "%s: added PHC on /dev/ptp%d\n", __func__,
			     ppd->ptp_index);

		/* Indicate that no MAD containing a clock_id has arrrived. */
		ppd->current_clock_id = -1;
#if 0
		/* FXRTODO - Check for flits on each clockid and report */

		/* Set the clock value. */
		ts = ktime_to_timespec64(ktime_get_real());
		hfi_settime(&pf->ptp_caps, &ts);
#endif
	}

	/*
	 * Start up timesync in Simics using a typical default value.
	 * FXRTODO - Perhaps read registers here.
	 */
	write_csr(ppd->dd, HACK_TIMESYNC_1, 0x10f000001);

	mutex_unlock(&ppd->timesync_mutex);
}

/**
 * hfi_timesync_stop - Disable the driver/hardware support and unregister
 *                     the PHC
 * @ppd: Port specific structure
 *
 * This function handles the cleanup work required from the initialization by
 * clearing out the important information and unregistering the PHC.
 **/
void hfi_timesync_stop(struct hfi_pportdata *ppd)
{
	if (ppd->ptp_clock) {
		mutex_lock(&ppd->timesync_mutex);
		ptp_clock_unregister(ppd->ptp_clock);
		ppd->ptp_clock = NULL;
		ppd_dev_dbg(ppd, "%s: removed PHC on %s\n", __func__,
			    "device TBD");
		mutex_unlock(&ppd->timesync_mutex);
	}
}

static int hfi_read_one_master_reg(struct hfi_pportdata *ppd,
				   struct hfi_ts_master_regs *master_ts)
{
	u64 master_low;		/* 40 bits with 8 bits of overlap */
	u64 master_high;
	u64 reg;
	int ret = -EAGAIN;
	int ctr = 2;
	u32 enable, time_inc_shift, snap_freq;

	do {
		/*
		 * Disable_snaps here to ensure atomic reads.  Registers here
		 * are indexed by clock id.  Master_low is 5 bytes and contains
		 * a copy of the low byte of master_high.  A check is performed
		 * below to verify that master_low and master_high are from the
		 * same sample.
		 */
		reg = read_csr(ppd->dd, OC_LCB_CFG_TIME_SYNC_0);
		reg |= 0x1LL << (OC_LCB_CFG_TIME_SYNC_0_DISABLE_SNAPS_SHIFT +
				 master_ts->clkid);
		write_csr(ppd->dd, OC_LCB_CFG_TIME_SYNC_0, reg);

		master_low = read_csr(ppd->dd, OC_LCB_STS_MASTER_TIME_LOW_0 +
				      0x18 * master_ts->clkid) &
			OC_LCB_STS_MASTER_TIME_LOW_0_VAL_SMASK;
		master_high = read_csr(ppd->dd, OC_LCB_STS_MASTER_TIME_HIGH_0 +
				       0x18 * master_ts->clkid) &
			OC_LCB_STS_MASTER_TIME_HIGH_0_VAL_SMASK;
		master_ts->timestamp = read_csr(ppd->dd,
					      OC_LCB_STS_SNAPPED_LOCAL_TIME_0 +
					      0x18 * master_ts->clkid);
		/* Enable snaps again */
		reg &= ~OC_LCB_CFG_TIME_SYNC_0_DISABLE_SNAPS_SMASK;
		write_csr(ppd->dd, OC_LCB_CFG_TIME_SYNC_0, reg);
		/* Tell Simics to restart this clock_id */
		simics_decode(&enable, &time_inc_shift, &snap_freq);
		simics_update_hack_timesync(ppd, enable, master_ts->clkid,
					    time_inc_shift, snap_freq);
		/* See if low and high are from the same sample */
		if ((master_high & 0xff) == (master_low >> 32)) {
			master_ts->master = (master_high << 32) |
				(master_low & 0xffffffff);
			if (!master_ts->master) {
				ret = -EAGAIN;
			} else {
				/* Simics hack to fake propagation delay */
				master_ts->timestamp += ppd->clock_delay;
				return 0;
			}
		}
		ret = -EAGAIN;
		msleep(500);    /* Simics only -- revisit for silicon */
	} while (ret && ctr--);

	return ret;
}

/*
 * Common code for hfi_use_fabric_time_offset and
 * hfi_compute_fabric_time_offset.
 */
static int hfi_fabric_time_common(struct hfi_pportdata *ppd,
				  struct hfi_ts_master_regs *master_ts)
{
	u32 enable, time_inc_shift, snap_freq;

	/* Nothing to do for first clock id */
	if (last_clock_id < 0) {
		last_clock_id = ppd->current_clock_id;
		return 0;
	}

	/* Nothing to do if clock id is unchanged */
	if (last_clock_id == ppd->current_clock_id)
		return 0;

	/* Tell Simics we changed clock_id */
	simics_decode(&enable, &time_inc_shift, &snap_freq);
	simics_update_hack_timesync(ppd, enable, ppd->current_clock_id,
				    time_inc_shift, snap_freq);

	/* Read a flit from the new clock id */
	master_ts->clkid = ppd->current_clock_id;

	return hfi_read_one_master_reg(ppd, master_ts);
}

/*
 * Use new fabric time.  Called with timesync_mutex held.  Make sure
 * a new master time flit from the new clock tree is read.
 */
void hfi_use_fabric_time_offset(struct hfi_pportdata *ppd)
{
	struct hfi_ts_master_regs master_ts = {0};

	hfi_fabric_time_common(ppd, &master_ts);

	/* TODO: Do or say something if master time is unchanged? */
	last_clock_id = ppd->current_clock_id;
}

/*
 * Compute new fabric time.  Called with timesync_mutex held.  The current
 * time from local time and a new master time flit from the new clock tree
 * are combined to produce the new fabric time.
 */
void hfi_compute_fabric_time_offset(struct hfi_pportdata *ppd)
{
	struct hfi_ts_master_regs master_ts = {0};
	int ret;

	ret = hfi_fabric_time_common(ppd, &master_ts);

	/*
	 * If a new flit did not arrive on the new clock id above, keep
	 * current clock offset.
	 */
	if (!ret && master_ts.master)
		ppd->clock_offset = -(master_ts.timestamp - master_ts.master +
				      ppd->clock_delay);

	last_clock_id = ppd->current_clock_id;
}

/**
 * hfi_get_ts_master_regs - Capture master low and high, check 8 bit overlap.
 * If mismatch, return EAGAIN.  Fill structure master_ts with the decoded
 * master time and the timestamp.
 * @ctx: Context struct
 * @master_ts: Struct containing master time and timestamp
 **/
int hfi_get_ts_master_regs(struct hfi_ibcontext *uc,
			   struct hfi_ts_master_regs *master_ts)
{
	struct hfi_pportdata *ppd = to_hfi_ppd(uc->priv, master_ts->port);
	int ret;

	if (!ppd)
		return -ENOENT;

	if (ppd->current_clock_id == -1)
		return -EAGAIN;

	mutex_lock(&ppd->timesync_mutex);
	ret = hfi_read_one_master_reg(ppd, master_ts);
	mutex_unlock(&ppd->timesync_mutex);
	return ret;
}

static void simics_hack_write_local_time(struct hfi_pportdata *ppd, u64 ns)
{
	write_csr(ppd->dd, OC_LCB_STS_UPPER_LOCAL_TIME, ns);
}

/*
 * Temporary hack to update Simics timesync values.  Used primarily for
 * clock_id.
 */
static void simics_update_hack_timesync(struct hfi_pportdata *ppd,
					u8 enable,
					u8 clock_id,
					u8 time_inc_shift,
					u16 snap_freq)
{
	saved_hack_timesync = (u64)(enable & 0x1) << 32 |
		(clock_id & 0x3) << 30 | (time_inc_shift & 0x3f) << 24 |
		(snap_freq & 0xffffff);
	write_csr(ppd->dd, HACK_TIMESYNC_1, saved_hack_timesync);
}

/*
 * Decode fields in saved_hack_timesync,
 */
static void simics_decode(u32 *enable, u32 *time_inc_shift, u32 *snap_freq)
{
	*enable = (saved_hack_timesync & 0x100000000ULL) >> 32;
	*time_inc_shift = (saved_hack_timesync & 0x3f000000) >> 24;
	*snap_freq = saved_hack_timesync & 0xffffff;
}

/*
 * Temporary hack to configure Simics for timesync.  Override clock id in
 * hack_timesync with parameter clock_id.
 */
static void simics_hack_timesync(struct hfi_pportdata *ppd, u64 hack_timesync,
				 u8 clock_id)
{
/*
 * abbccccccdddddddddddddddddddddddd
 * 210987654321098765432109876543210
 *   3         2         1
 *          111111111111111111111111
 *    111111
 *  11
 * 1
 *             f   f   f   f   f   f  0xffffff  shift 0   snap_freq
 *     3   f   0   0   0   0   0   0  0x3f      shift 24  time_inc_shift
 *     c   0   0   0   0   0   0   0  0x3       shift 30  clock_id
 * 1   0   0   0   0   0   0   0   0  0x1       shift 32  enable
 */
	u32 enable, time_inc_shift, snap_freq;
	struct hfi_ts_master_regs master_ts = {0};

	saved_hack_timesync = hack_timesync;
	simics_decode(&enable, &time_inc_shift, &snap_freq);
	simics_update_hack_timesync(ppd, enable, clock_id, time_inc_shift,
				    snap_freq);
	master_ts.clkid = clock_id;

	/*
	 * write_csr(ppd->dd, OC_LCB_CFG_TIME_SYNC_1, 0xd5555555);
	 * Don't reset freq register here as ptp subsystem tracks it.
	 * Use clock_adjtime call.
	 */

	/*
	 * Start with local time set to zero only when high bit is set.
	 */
	if (hack_timesync & (1UL << 63)) {
		ppd_dev_info(ppd, "Starting local clock\n");
		simics_hack_write_local_time(ppd, 0);
	}
}

/**
 * hfi_get_ts_fm_data - Returns data collected from FM MAD interface for
 * timesync parameters needed to ensure accurate synchronization on the fabric.
 * @ctx: Context struct
 * @fm_data: Struct containing data collected from FM MAD interface
 **/
int hfi_get_ts_fm_data(struct hfi_ibcontext *uc,
		       struct hfi_ts_fm_data *fm_data)
{
	struct hfi_pportdata *ppd = to_hfi_ppd(uc->priv, fm_data->port);

	if (!ppd)
		return -ENOENT;

	if (ppd->current_clock_id == -1)
		return -EAGAIN;

	mutex_lock(&ppd->timesync_mutex);

	fm_data->clock_offset = ppd->clock_offset;
	fm_data->clock_delay = ppd->clock_delay;
	fm_data->periodicity = ppd->periodicity;
	fm_data->current_clock_id = ppd->current_clock_id;
	fm_data->ptp_index = ppd->ptp_index;
	fm_data->is_active_master = ppd->is_active_master;

	simics_hack_timesync(ppd, fm_data->hack_timesync,
			     ppd->current_clock_id);
	mutex_unlock(&ppd->timesync_mutex);
	return 0;
}

/*
 * Debugfs function to reset some driver variables.  Write
 * any value.
 *
 * echo 1 > /sys/kernel/debug/hfi2/0/timesync/reset
 */
void hfi_ts_dbg_failover_reset(struct hfi_pportdata *ppd)
{
	mutex_lock(&ppd->timesync_mutex);
	last_clock_id = 0;
	ppd->current_clock_id = 0;
	mutex_unlock(&ppd->timesync_mutex);
}

/*
 * Debugfs function to write failover offset values.  Write zero to clear.
 *
 * echo 0x1234 > /sys/kernel/debug/hfi2/0/timesync/failover_3
 */
void hfi_ts_dbg_failover_reg(struct hfi_pportdata *ppd, u64 val, u8 clkid)
{
	mutex_lock(&ppd->timesync_mutex);
	write_csr(ppd->dd, TS_FAILOVER_0 + clkid * 8, val);
	mutex_unlock(&ppd->timesync_mutex);
}

/*
 * Debugfs function to control Simics support for timesync.  Write zero to
 * clear.
 *
 * echo 0x10f000001 > /sys/kernel/debug/hfi2/0/timesync/control
 */
void hfi_ts_dbg_control_reg(struct hfi_pportdata *ppd, u64 val)
{
	mutex_lock(&ppd->timesync_mutex);
	write_csr(ppd->dd, HACK_TIMESYNC_1, val);
	mutex_unlock(&ppd->timesync_mutex);
}
