/*
*------------------------------------------------------------------------------
*                                                                              
*  INTEL CONFIDENTIAL                                                          
*                                                                              
*  Copyright 2018 Intel Corporation All Rights Reserved.                 
*                                                                              
*  The source code contained or described herein and all documents related     
*  to the source code ("Material") are owned by Intel Corporation or its    
*  suppliers or licensors. Title to the Material remains with Intel            
*  Corporation or its suppliers and licensors. The Material contains trade     
*  secrets and proprietary and confidential information of Intel or its        
*  suppliers and licensors. The Material is protected by worldwide copyright   
*  and trade secret laws and treaty provisions. No part of the Material may    
*  be used, copied, reproduced, modified, published, uploaded, posted,         
*  transmitted, distributed, or disclosed in any way without Intel's prior     
*  express written permission.                                                 
*                                                                              
*  No license under any patent, copyright, trade secret or other intellectual  
*  property right is granted to or conferred upon you by disclosure or         
*  delivery of the Materials, either expressly, by implication, inducement,    
*  estoppel or otherwise. Any license under such intellectual property rights  
*  must be express and approved by Intel in writing.                           
*                                                                              
*------------------------------------------------------------------------------
*  Auto-generated by /p/hdk/rtl/proj_tools/sl2_tools/sl2_tools-srvr10nm-18ww19b/scripts/i_csrs/i_csrs.pl
*  i_csrs.pl Version 1.5 last modified on Friday 5/11/18 13:59:26
*  /p/hdk/rtl/proj_tools/sl2_tools/sl2_tools-srvr10nm-18ww19b/scripts/i_csrs/i_csrs.pl -C -RVREGS -ST fxr_at_iommu -o /nfs/sc/disks/slx_0108/pvesv/fxr_autogen/fxr /nfs/sc/disks/slx_0108/pvesv/fxr_autogen/repo_xml/300_Memory_Map.xml /nfs/sc/disks/slx_0108/pvesv/fxr_autogen/repo_xml/361_Memory_Map_AT_IOMMU.xml
*------------------------------------------------------------------------------
*/

#ifndef DEF_FXR_AT_IOMMU_SW_DEF
#define DEF_FXR_AT_IOMMU_SW_DEF

#ifndef FXR_AT_IOMMU_CSRS
#define FXR_AT_IOMMU_CSRS					0x000000000000
#endif
#define FXR_NUM_CONTEXTS					256
#define FXR_NUM_PIDS						4096
#define FXR_MAX_CONTEXT						255
#define FXR_TX_CONTEXT_ENTRIES					128
#define FXR_TX_CONTEXT_MAX					127
#define FXR_RX_CONTEXT_ENTRIES					16
#define FXR_RX_CONTEXT_MAX					15
#define FXR_NUM_SL						32
#define FXR_MAX_SL						31
#define FXR_AT_IOMMU_BASE					0
/*
* Table #4 of fxr_top - FXR_AT_IOMMU_CFG_MAW
* 
*/
#define FXR_AT_IOMMU_CFG_MAW					(FXR_AT_IOMMU_CSRS + 0x000000000000)
#define FXR_AT_IOMMU_CFG_MAW_RESETCSR				0x0000000000000000ull
#define FXR_AT_IOMMU_CFG_MAW_RESERVED_63_1_SHIFT		1
#define FXR_AT_IOMMU_CFG_MAW_RESERVED_63_1_MASK			0x7FFFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_CFG_MAW_RESERVED_63_1_SMASK		0xFFFFFFFFFFFFFFFEull
#define FXR_AT_IOMMU_CFG_MAW_MAW_SHIFT				0
#define FXR_AT_IOMMU_CFG_MAW_MAW_MASK				0x1ull
#define FXR_AT_IOMMU_CFG_MAW_MAW_SMASK				0x1ull
/*
* Table #5 of fxr_top - FXR_AT_IOMMU_CFG_DEFEATURE
* This allows access to the IOMMU Defeature registers as an array of four 64 bit 
* registers. These arrays CANNOT be written to during normal operation. This 
* will corrupt the Address Translation state, and possibly lock up the Address 
* Translation block. Each 64 bit register contains two 32 bit Defeature 
* Registers. This requires a Read-Modify-Write, to establish the current 
* defeature settings, for two 32 bit registers, and to modify to new settings. 
* This should only be modified by a knowledgeable BIOS Agent.
*/
#define FXR_AT_IOMMU_CFG_DEFEATURE				(FXR_AT_IOMMU_CSRS + 0x000000000100)
#define FXR_AT_IOMMU_CFG_DEFEATURE_RESETCSR			0x0000000000000000ull
#define FXR_AT_IOMMU_CFG_DEFEATURE_IOMMU_DEFEATURES_SHIFT	0
#define FXR_AT_IOMMU_CFG_DEFEATURE_IOMMU_DEFEATURES_MASK	0xFFFFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_CFG_DEFEATURE_IOMMU_DEFEATURES_SMASK	0xFFFFFFFFFFFFFFFFull
/*
* Table #6 of fxr_top - FXR_AT_IOMMU_ERR_STS_1
* This is the Error Status CSR. Bits are set by hardware or by writing to the 
* #%%#FXR_AT_IOMMU_ERR_FRC_1#%%# CSR. Bits are cleared by writing to the 
* #%%#FXR_AT_IOMMU_ERR_CLR_1#%%# CSR.
*/
#define FXR_AT_IOMMU_ERR_STS_1					(FXR_AT_IOMMU_CSRS + 0x000000000200)
#define FXR_AT_IOMMU_ERR_STS_1_RESETCSR				0x0000000000000000ull
#define FXR_AT_IOMMU_ERR_STS_1_RESERVED_63_5_SHIFT		5
#define FXR_AT_IOMMU_ERR_STS_1_RESERVED_63_5_MASK		0x7FFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_ERR_STS_1_RESERVED_63_5_SMASK		0xFFFFFFFFFFFFFFE0ull
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_MSI_MSG_ERR_SHIFT		4
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_MSI_MSG_ERR_MASK		0x1ull
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_MSI_MSG_ERR_SMASK		0x10ull
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_SEQ_MSG_ERR_SHIFT		3
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_SEQ_MSG_ERR_MASK		0x1ull
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_SEQ_MSG_ERR_SMASK		0x8ull
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_PWT_PARITY_ERR_SHIFT	2
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_PWT_PARITY_ERR_MASK	0x1ull
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_PWT_PARITY_ERR_SMASK	0x4ull
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_DATA_PARITY_ERR_SHIFT	1
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_DATA_PARITY_ERR_MASK	0x1ull
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_DATA_PARITY_ERR_SMASK	0x2ull
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_TAG_PARITY_ERR_SHIFT	0
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_TAG_PARITY_ERR_MASK	0x1ull
#define FXR_AT_IOMMU_ERR_STS_1_IOMMU_TAG_PARITY_ERR_SMASK	0x1ull
/*
* Table #7 of fxr_top - FXR_AT_IOMMU_ERR_CLR_1
* This is the Error Clear CSR. Writing a 1 to a valid bit will clear the 
* corresponding bit in the #%%#FXR_AT_IOMMU_ERR_STS_1#%%# CSR.
*/
#define FXR_AT_IOMMU_ERR_CLR_1					(FXR_AT_IOMMU_CSRS + 0x000000000208)
#define FXR_AT_IOMMU_ERR_CLR_1_RESETCSR				0x0000000000000000ull
#define FXR_AT_IOMMU_ERR_CLR_1_RESERVED_63_5_SHIFT		5
#define FXR_AT_IOMMU_ERR_CLR_1_RESERVED_63_5_MASK		0x7FFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_ERR_CLR_1_RESERVED_63_5_SMASK		0xFFFFFFFFFFFFFFE0ull
#define FXR_AT_IOMMU_ERR_CLR_1_EVENTS_SHIFT			0
#define FXR_AT_IOMMU_ERR_CLR_1_EVENTS_MASK			0x1Full
#define FXR_AT_IOMMU_ERR_CLR_1_EVENTS_SMASK			0x1Full
/*
* Table #8 of fxr_top - FXR_AT_IOMMU_ERR_FRC_1
* This is the Error Force CSR. Writing a 1 to a valid bit will set the 
* corresponding bit in the #%%#FXR_AT_IOMMU_ERR_STS_1#%%# CSR.
*/
#define FXR_AT_IOMMU_ERR_FRC_1					(FXR_AT_IOMMU_CSRS + 0x000000000210)
#define FXR_AT_IOMMU_ERR_FRC_1_RESETCSR				0x0000000000000000ull
#define FXR_AT_IOMMU_ERR_FRC_1_RESERVED_63_5_SHIFT		5
#define FXR_AT_IOMMU_ERR_FRC_1_RESERVED_63_5_MASK		0x7FFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_ERR_FRC_1_RESERVED_63_5_SMASK		0xFFFFFFFFFFFFFFE0ull
#define FXR_AT_IOMMU_ERR_FRC_1_EVENTS_SHIFT			0
#define FXR_AT_IOMMU_ERR_FRC_1_EVENTS_MASK			0x1Full
#define FXR_AT_IOMMU_ERR_FRC_1_EVENTS_SMASK			0x1Full
/*
* Table #9 of fxr_top - FXR_AT_IOMMU_ERR_EN_HOST_1
* This is the Error Enable for the Host Interrupt. If a bit is set, the 
* corresponding error bit in #%%#FXR_AT_IOMMU_ERR_STS_1#%%# will cause an 
* interrupt on the HOST interrupt signal.
*/
#define FXR_AT_IOMMU_ERR_EN_HOST_1				(FXR_AT_IOMMU_CSRS + 0x000000000218)
#define FXR_AT_IOMMU_ERR_EN_HOST_1_RESETCSR			0x0000000000000000ull
#define FXR_AT_IOMMU_ERR_EN_HOST_1_RESERVED_63_5_SHIFT		5
#define FXR_AT_IOMMU_ERR_EN_HOST_1_RESERVED_63_5_MASK		0x7FFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_ERR_EN_HOST_1_RESERVED_63_5_SMASK		0xFFFFFFFFFFFFFFE0ull
#define FXR_AT_IOMMU_ERR_EN_HOST_1_EVENTS_SHIFT			0
#define FXR_AT_IOMMU_ERR_EN_HOST_1_EVENTS_MASK			0x1Full
#define FXR_AT_IOMMU_ERR_EN_HOST_1_EVENTS_SMASK			0x1Full
/*
* Table #10 of fxr_top - FXR_AT_IOMMU_ERR_FIRST_HOST_1
* This is the First Error CSR for the Host Interrupt. When this CSR is clear, it 
* will capture the next #%%#FXR_AT_IOMMU_ERR_STS_1#%%# value when a new HOST 
* Interrupt occurs.
*/
#define FXR_AT_IOMMU_ERR_FIRST_HOST_1				(FXR_AT_IOMMU_CSRS + 0x000000000220)
#define FXR_AT_IOMMU_ERR_FIRST_HOST_1_RESETCSR			0x0000000000000000ull
#define FXR_AT_IOMMU_ERR_FIRST_HOST_1_RESERVED_63_5_SHIFT	5
#define FXR_AT_IOMMU_ERR_FIRST_HOST_1_RESERVED_63_5_MASK	0x7FFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_ERR_FIRST_HOST_1_RESERVED_63_5_SMASK	0xFFFFFFFFFFFFFFE0ull
#define FXR_AT_IOMMU_ERR_FIRST_HOST_1_EVENTS_SHIFT		0
#define FXR_AT_IOMMU_ERR_FIRST_HOST_1_EVENTS_MASK		0x1Full
#define FXR_AT_IOMMU_ERR_FIRST_HOST_1_EVENTS_SMASK		0x1Full
/*
* Table #11 of fxr_top - FXR_AT_IOMMU_ERR_EN_BMC_1
* This is the Error Enable for the BMC Interrupt. If a bit is set, the 
* corresponding error bit in #%%#FXR_AT_IOMMU_ERR_STS_1#%%# will cause an 
* interrupt on the BMC interrupt signal.
*/
#define FXR_AT_IOMMU_ERR_EN_BMC_1				(FXR_AT_IOMMU_CSRS + 0x000000000228)
#define FXR_AT_IOMMU_ERR_EN_BMC_1_RESETCSR			0x0000000000000000ull
#define FXR_AT_IOMMU_ERR_EN_BMC_1_RESERVED_63_5_SHIFT		5
#define FXR_AT_IOMMU_ERR_EN_BMC_1_RESERVED_63_5_MASK		0x7FFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_ERR_EN_BMC_1_RESERVED_63_5_SMASK		0xFFFFFFFFFFFFFFE0ull
#define FXR_AT_IOMMU_ERR_EN_BMC_1_EVENTS_SHIFT			0
#define FXR_AT_IOMMU_ERR_EN_BMC_1_EVENTS_MASK			0x1Full
#define FXR_AT_IOMMU_ERR_EN_BMC_1_EVENTS_SMASK			0x1Full
/*
* Table #12 of fxr_top - FXR_AT_IOMMU_ERR_FIRST_BMC_1
* This is the First Error CSR for the BMC Interrupt. When this CSR is clear, it 
* will capture the next #%%#FXR_AT_IOMMU_ERR_STS_1#%%# value when a new BMC 
* Interrupt occurs.
*/
#define FXR_AT_IOMMU_ERR_FIRST_BMC_1				(FXR_AT_IOMMU_CSRS + 0x000000000230)
#define FXR_AT_IOMMU_ERR_FIRST_BMC_1_RESETCSR			0x0000000000000000ull
#define FXR_AT_IOMMU_ERR_FIRST_BMC_1_RESERVED_63_5_SHIFT	5
#define FXR_AT_IOMMU_ERR_FIRST_BMC_1_RESERVED_63_5_MASK		0x7FFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_ERR_FIRST_BMC_1_RESERVED_63_5_SMASK	0xFFFFFFFFFFFFFFE0ull
#define FXR_AT_IOMMU_ERR_FIRST_BMC_1_EVENTS_SHIFT		0
#define FXR_AT_IOMMU_ERR_FIRST_BMC_1_EVENTS_MASK		0x1Full
#define FXR_AT_IOMMU_ERR_FIRST_BMC_1_EVENTS_SMASK		0x1Full
/*
* Table #13 of fxr_top - FXR_AT_IOMMU_ERR_EN_QUAR_1
* This is the Error Enable for the Quarantine Interrupt. If a bit is set, the 
* corresponding error bit in #%%#FXR_AT_IOMMU_ERR_STS_1#%%# will cause an 
* interrupt on the QUAR interrupt signal.
*/
#define FXR_AT_IOMMU_ERR_EN_QUAR_1				(FXR_AT_IOMMU_CSRS + 0x000000000238)
#define FXR_AT_IOMMU_ERR_EN_QUAR_1_RESETCSR			0x0000000000000000ull
#define FXR_AT_IOMMU_ERR_EN_QUAR_1_RESERVED_63_5_SHIFT		5
#define FXR_AT_IOMMU_ERR_EN_QUAR_1_RESERVED_63_5_MASK		0x7FFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_ERR_EN_QUAR_1_RESERVED_63_5_SMASK		0xFFFFFFFFFFFFFFE0ull
#define FXR_AT_IOMMU_ERR_EN_QUAR_1_EVENTS_SHIFT			0
#define FXR_AT_IOMMU_ERR_EN_QUAR_1_EVENTS_MASK			0x1Full
#define FXR_AT_IOMMU_ERR_EN_QUAR_1_EVENTS_SMASK			0x1Full
/*
* Table #14 of fxr_top - FXR_AT_IOMMU_ERR_FIRST_QUAR_1
* This is the First Error CSR for the Quarantine Interrupt. When this CSR is 
* clear, it will capture the next #%%#FXR_AT_IOMMU_ERR_STS_1#%%# value when a 
* new QUAR Interrupt occurs.
*/
#define FXR_AT_IOMMU_ERR_FIRST_QUAR_1				(FXR_AT_IOMMU_CSRS + 0x000000000240)
#define FXR_AT_IOMMU_ERR_FIRST_QUAR_1_RESETCSR			0x0000000000000000ull
#define FXR_AT_IOMMU_ERR_FIRST_QUAR_1_RESERVED_63_5_SHIFT	5
#define FXR_AT_IOMMU_ERR_FIRST_QUAR_1_RESERVED_63_5_MASK	0x7FFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_ERR_FIRST_QUAR_1_RESERVED_63_5_SMASK	0xFFFFFFFFFFFFFFE0ull
#define FXR_AT_IOMMU_ERR_FIRST_QUAR_1_EVENTS_SHIFT		0
#define FXR_AT_IOMMU_ERR_FIRST_QUAR_1_EVENTS_MASK		0x1Full
#define FXR_AT_IOMMU_ERR_FIRST_QUAR_1_EVENTS_SMASK		0x1Full
/*
* Table #15 of fxr_top - FXR_AT_IOMMU_ERR_INFO_1A
* Error Info for the IOMMU Parity Error events. 
*/
#define FXR_AT_IOMMU_ERR_INFO_1A				(FXR_AT_IOMMU_CSRS + 0x000000000248)
#define FXR_AT_IOMMU_ERR_INFO_1A_RESETCSR			0x0000000000000000ull
#define FXR_AT_IOMMU_ERR_INFO_1A_RESERVED_63_3_SHIFT		3
#define FXR_AT_IOMMU_ERR_INFO_1A_RESERVED_63_3_MASK		0x1FFFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_ERR_INFO_1A_RESERVED_63_3_SMASK		0xFFFFFFFFFFFFFFF8ull
#define FXR_AT_IOMMU_ERR_INFO_1A_IOMMU_PE0_2_SHIFT		2
#define FXR_AT_IOMMU_ERR_INFO_1A_IOMMU_PE0_2_MASK		0x1ull
#define FXR_AT_IOMMU_ERR_INFO_1A_IOMMU_PE0_2_SMASK		0x4ull
#define FXR_AT_IOMMU_ERR_INFO_1A_IOMMU_PE0_1_SHIFT		1
#define FXR_AT_IOMMU_ERR_INFO_1A_IOMMU_PE0_1_MASK		0x1ull
#define FXR_AT_IOMMU_ERR_INFO_1A_IOMMU_PE0_1_SMASK		0x2ull
#define FXR_AT_IOMMU_ERR_INFO_1A_IOMMU_PE0_SHIFT		0
#define FXR_AT_IOMMU_ERR_INFO_1A_IOMMU_PE0_MASK			0x1ull
#define FXR_AT_IOMMU_ERR_INFO_1A_IOMMU_PE0_SMASK		0x1ull
/*
* Table #16 of fxr_top - FXR_AT_IOMMU_STS_GENERAL_1
* FXR_AT_IOMMU General status of important state(i.e. misc errors, FSM states, 
* etc.)
*/
#define FXR_AT_IOMMU_STS_GENERAL_1				(FXR_AT_IOMMU_CSRS + 0x000000000300)
#define FXR_AT_IOMMU_STS_GENERAL_1_RESETCSR			0x0000000000000000ull
#define FXR_AT_IOMMU_STS_GENERAL_1_RESERVED_63_1_SHIFT		1
#define FXR_AT_IOMMU_STS_GENERAL_1_RESERVED_63_1_MASK		0x7FFFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_STS_GENERAL_1_RESERVED_63_1_SMASK		0xFFFFFFFFFFFFFFFEull
#define FXR_AT_IOMMU_STS_GENERAL_1_DTLB_ID_ERR_SHIFT		0
#define FXR_AT_IOMMU_STS_GENERAL_1_DTLB_ID_ERR_MASK		0x1ull
#define FXR_AT_IOMMU_STS_GENERAL_1_DTLB_ID_ERR_SMASK		0x1ull
/*
* Table #17 of fxr_top - FXR_AT_IOMMU_DBG_GENERAL_1
* This is an AT IOMMU debug CSR. It provides information for recoverable errors, 
* etc.
*/
#define FXR_AT_IOMMU_DBG_GENERAL_1				(FXR_AT_IOMMU_CSRS + 0x000000000400)
#define FXR_AT_IOMMU_DBG_GENERAL_1_RESETCSR			0x0000000000000000ull
#define FXR_AT_IOMMU_DBG_GENERAL_1_RESERVED_63_1_SHIFT		1
#define FXR_AT_IOMMU_DBG_GENERAL_1_RESERVED_63_1_MASK		0x7FFFFFFFFFFFFFFFull
#define FXR_AT_IOMMU_DBG_GENERAL_1_RESERVED_63_1_SMASK		0xFFFFFFFFFFFFFFFEull
#define FXR_AT_IOMMU_DBG_GENERAL_1_MEM_REQ_ABORT_SHIFT		0
#define FXR_AT_IOMMU_DBG_GENERAL_1_MEM_REQ_ABORT_MASK		0x1ull
#define FXR_AT_IOMMU_DBG_GENERAL_1_MEM_REQ_ABORT_SMASK		0x1ull

#endif 		/* DEF_FXR_AT_IOMMU_SW_DEF */
