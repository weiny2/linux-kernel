/*
*------------------------------------------------------------------------------
*                                                                              
*  INTEL CONFIDENTIAL                                                          
*                                                                              
*  Copyright 2018 Intel Corporation All Rights Reserved.                 
*                                                                              
*  The source code contained or described herein and all documents related     
*  to the source code ("Material") are owned by Intel Corporation or its    
*  suppliers or licensors. Title to the Material remains with Intel            
*  Corporation or its suppliers and licensors. The Material contains trade     
*  secrets and proprietary and confidential information of Intel or its        
*  suppliers and licensors. The Material is protected by worldwide copyright   
*  and trade secret laws and treaty provisions. No part of the Material may    
*  be used, copied, reproduced, modified, published, uploaded, posted,         
*  transmitted, distributed, or disclosed in any way without Intel's prior     
*  express written permission.                                                 
*                                                                              
*  No license under any patent, copyright, trade secret or other intellectual  
*  property right is granted to or conferred upon you by disclosure or         
*  delivery of the Materials, either expressly, by implication, inducement,    
*  estoppel or otherwise. Any license under such intellectual property rights  
*  must be express and approved by Intel in writing.                           
*                                                                              
*------------------------------------------------------------------------------
*  Auto-generated by /p/hdk/rtl/proj_tools/sl2_tools/sl2_tools-srvr10nm-18ww26b/scripts/i_csrs/i_csrs.pl
*  i_csrs.pl Version 1.5 last modified on Thursday 6/28/18 12:45:58
*  /p/hdk/rtl/proj_tools/sl2_tools/sl2_tools-srvr10nm-18ww26b/scripts/i_csrs/i_csrs.pl -C -RVREGS -ST fxr_perfmon -o /nfs/sc/disks/slx_0108/pvesv/fxr_autogen/fxr /nfs/sc/disks/slx_0108/pvesv/fxr_autogen/repo_xml/300_Memory_Map.xml /nfs/sc/disks/slx_0108/pvesv/fxr_autogen/repo_xml/350_Memory_Map_PerfMon.xml
*------------------------------------------------------------------------------
*/

#ifndef DEF_FXR_PERFMON_SW_DEF
#define DEF_FXR_PERFMON_SW_DEF

#ifndef FXR_PMON_CSRS
#define FXR_PMON_CSRS					0x000000000000
#endif
#define FXR_NUM_CONTEXTS				256
#define FXR_NUM_PIDS					4096
#define FXR_MAX_CONTEXT					255
#define FXR_TX_CONTEXT_ENTRIES				128
#define FXR_TX_CONTEXT_MAX				127
#define FXR_RX_CONTEXT_ENTRIES				32
#define FXR_RX_CONTEXT_MAX				31
#define FXR_NUM_SL					32
#define FXR_MAX_SL					31
#define FXR_PMON_CSR_OFFSET				65536
#define FXR_PMON_ARRAY_OFFSET				69632
#define FXR_PMON_ARRAY_ENTRIES				512
/*
* Table #4 of fxr_top - PMON_CFG_CONTROL
* This is the control register for the performance monitor counter array. Each 
* bit controls a group of 32 counters. A group of 32 counters can be frozen, 
* reset, or set to interrupt on overflow.
*/
#define FXR_PMON_CFG_CONTROL				(FXR_PMON_CSRS + 0x000000010000)
#define FXR_PMON_CFG_CONTROL_RESETCSR			0x0000000000000000ull
#define FXR_PMON_CFG_CONTROL_RESERVED_63_48_SHIFT	48
#define FXR_PMON_CFG_CONTROL_RESERVED_63_48_MASK	0xFFFFull
#define FXR_PMON_CFG_CONTROL_RESERVED_63_48_SMASK	0xFFFF000000000000ull
#define FXR_PMON_CFG_CONTROL_RESET_CTRS_SHIFT		32
#define FXR_PMON_CFG_CONTROL_RESET_CTRS_MASK		0xFFFFull
#define FXR_PMON_CFG_CONTROL_RESET_CTRS_SMASK		0xFFFF00000000ull
#define FXR_PMON_CFG_CONTROL_LOG_OVERFLOW_SHIFT		16
#define FXR_PMON_CFG_CONTROL_LOG_OVERFLOW_MASK		0xFFFFull
#define FXR_PMON_CFG_CONTROL_LOG_OVERFLOW_SMASK		0xFFFF0000ull
#define FXR_PMON_CFG_CONTROL_FREEZE_SHIFT		0
#define FXR_PMON_CFG_CONTROL_FREEZE_MASK		0xFFFFull
#define FXR_PMON_CFG_CONTROL_FREEZE_SMASK		0xFFFFull
/*
* Table #5 of fxr_top - PMON_CFG_FREEZE_TIME
* This is the local time at which the performance monitor counter array was 
* frozen. This is updated with #%%#PMON_CFG_LOCAL_TIME#%%# if any bits in 
* #%%#PMON_CFG_CONTROL#%%#.FREEZE go from 0 to 1.
*/
#define FXR_PMON_CFG_FREEZE_TIME			(FXR_PMON_CSRS + 0x000000010020)
#define FXR_PMON_CFG_FREEZE_TIME_RESETCSR		0x0000000000000000ull
#define FXR_PMON_CFG_FREEZE_TIME_RESERVED_63_56_SHIFT	56
#define FXR_PMON_CFG_FREEZE_TIME_RESERVED_63_56_MASK	0xFFull
#define FXR_PMON_CFG_FREEZE_TIME_RESERVED_63_56_SMASK	0xFF00000000000000ull
#define FXR_PMON_CFG_FREEZE_TIME_FREEZE_TIME_SHIFT	0
#define FXR_PMON_CFG_FREEZE_TIME_FREEZE_TIME_MASK	0xFFFFFFFFFFFFFFull
#define FXR_PMON_CFG_FREEZE_TIME_FREEZE_TIME_SMASK	0xFFFFFFFFFFFFFFull
/*
* Table #6 of fxr_top - PMON_CFG_ENABLE_TIME
* This is the local time at which the performance monitor counter array was 
* released from the freeze state. This is updated with #%%#PMON_CFG_LOCAL_TIME#%%# 
* if any bits in #%%#PMON_CFG_CONTROL#%%#.FREEZE go from 1 to 0.
*/
#define FXR_PMON_CFG_ENABLE_TIME			(FXR_PMON_CSRS + 0x000000010028)
#define FXR_PMON_CFG_ENABLE_TIME_RESETCSR		0x0000000000000000ull
#define FXR_PMON_CFG_ENABLE_TIME_RESERVED_63_56_SHIFT	56
#define FXR_PMON_CFG_ENABLE_TIME_RESERVED_63_56_MASK	0xFFull
#define FXR_PMON_CFG_ENABLE_TIME_RESERVED_63_56_SMASK	0xFF00000000000000ull
#define FXR_PMON_CFG_ENABLE_TIME_ENABLE_TIME_SHIFT	0
#define FXR_PMON_CFG_ENABLE_TIME_ENABLE_TIME_MASK	0xFFFFFFFFFFFFFFull
#define FXR_PMON_CFG_ENABLE_TIME_ENABLE_TIME_SMASK	0xFFFFFFFFFFFFFFull
/*
* Table #7 of fxr_top - PMON_CFG_LOCAL_TIME
* This is the local time. It increments every cclk. At 1.2Ghz cclk, it will 
* rollover 1.9 years from hreset.
*/
#define FXR_PMON_CFG_LOCAL_TIME				(FXR_PMON_CSRS + 0x000000010030)
#define FXR_PMON_CFG_LOCAL_TIME_RESETCSR		0x0000000000000000ull
#define FXR_PMON_CFG_LOCAL_TIME_RESERVED_63_56_SHIFT	56
#define FXR_PMON_CFG_LOCAL_TIME_RESERVED_63_56_MASK	0xFFull
#define FXR_PMON_CFG_LOCAL_TIME_RESERVED_63_56_SMASK	0xFF00000000000000ull
#define FXR_PMON_CFG_LOCAL_TIME_LOCAL_TIME_SHIFT	0
#define FXR_PMON_CFG_LOCAL_TIME_LOCAL_TIME_MASK		0xFFFFFFFFFFFFFFull
#define FXR_PMON_CFG_LOCAL_TIME_LOCAL_TIME_SMASK	0xFFFFFFFFFFFFFFull
/*
* Table #8 of fxr_top - PMON_ERR_STS_1
* This is the Error Status CSR. Bits are set by hardware or by writing to the 
* #%%#PMON_ERR_FRC_1#%%# CSR. Bits are cleared by writing to the 
* #%%#PMON_ERR_CLR_1#%%# CSR.
*/
#define FXR_PMON_ERR_STS_1				(FXR_PMON_CSRS + 0x000000010100)
#define FXR_PMON_ERR_STS_1_RESETCSR			0x0000000000000000ull
#define FXR_PMON_ERR_STS_1_RESERVED_63_17_SHIFT		17
#define FXR_PMON_ERR_STS_1_RESERVED_63_17_MASK		0x7FFFFFFFFFFFull
#define FXR_PMON_ERR_STS_1_RESERVED_63_17_SMASK		0xFFFFFFFFFFFE0000ull
#define FXR_PMON_ERR_STS_1_OVERFLOW_SHIFT		1
#define FXR_PMON_ERR_STS_1_OVERFLOW_MASK		0xFFFFull
#define FXR_PMON_ERR_STS_1_OVERFLOW_SMASK		0x1FFFEull
#define FXR_PMON_ERR_STS_1_DIAGNOSTIC_SHIFT		0
#define FXR_PMON_ERR_STS_1_DIAGNOSTIC_MASK		0x1ull
#define FXR_PMON_ERR_STS_1_DIAGNOSTIC_SMASK		0x1ull
/*
* Table #9 of fxr_top - PMON_ERR_CLR_1
* This is the Error Clear CSR. Writing a 1 to a valid bit will clear the 
* corresponding bit in the #%%#PMON_ERR_STS_1#%%# CSR.
*/
#define FXR_PMON_ERR_CLR_1				(FXR_PMON_CSRS + 0x000000010108)
#define FXR_PMON_ERR_CLR_1_RESETCSR			0x0000000000000000ull
#define FXR_PMON_ERR_CLR_1_RESERVED_63_17_SHIFT		17
#define FXR_PMON_ERR_CLR_1_RESERVED_63_17_MASK		0x7FFFFFFFFFFFull
#define FXR_PMON_ERR_CLR_1_RESERVED_63_17_SMASK		0xFFFFFFFFFFFE0000ull
#define FXR_PMON_ERR_CLR_1_EVENTS_SHIFT			0
#define FXR_PMON_ERR_CLR_1_EVENTS_MASK			0x1FFFFull
#define FXR_PMON_ERR_CLR_1_EVENTS_SMASK			0x1FFFFull
/*
* Table #10 of fxr_top - PMON_ERR_FRC_1
* This is the Error Force CSR. Writing a 1 to a valid bit will set the 
* corresponding bit in the #%%#PMON_ERR_STS_1#%%# CSR.
*/
#define FXR_PMON_ERR_FRC_1				(FXR_PMON_CSRS + 0x000000010110)
#define FXR_PMON_ERR_FRC_1_RESETCSR			0x0000000000000000ull
#define FXR_PMON_ERR_FRC_1_RESERVED_63_17_SHIFT		17
#define FXR_PMON_ERR_FRC_1_RESERVED_63_17_MASK		0x7FFFFFFFFFFFull
#define FXR_PMON_ERR_FRC_1_RESERVED_63_17_SMASK		0xFFFFFFFFFFFE0000ull
#define FXR_PMON_ERR_FRC_1_EVENTS_SHIFT			0
#define FXR_PMON_ERR_FRC_1_EVENTS_MASK			0x1FFFFull
#define FXR_PMON_ERR_FRC_1_EVENTS_SMASK			0x1FFFFull
/*
* Table #11 of fxr_top - PMON_ERR_EN_HOST_1
* This is the Error Enable for the Host Interrupt. If a bit is set, the 
* corresponding error bit in #%%#PMON_ERR_STS_1#%%# will cause an interrupt on 
* the HOST interrupt signal.
*/
#define FXR_PMON_ERR_EN_HOST_1				(FXR_PMON_CSRS + 0x000000010118)
#define FXR_PMON_ERR_EN_HOST_1_RESETCSR			0x0000000000000000ull
#define FXR_PMON_ERR_EN_HOST_1_RESERVED_63_17_SHIFT	17
#define FXR_PMON_ERR_EN_HOST_1_RESERVED_63_17_MASK	0x7FFFFFFFFFFFull
#define FXR_PMON_ERR_EN_HOST_1_RESERVED_63_17_SMASK	0xFFFFFFFFFFFE0000ull
#define FXR_PMON_ERR_EN_HOST_1_EVENTS_SHIFT		0
#define FXR_PMON_ERR_EN_HOST_1_EVENTS_MASK		0x1FFFFull
#define FXR_PMON_ERR_EN_HOST_1_EVENTS_SMASK		0x1FFFFull
/*
* Table #12 of fxr_top - PMON_ERR_FIRST_HOST_1
* This is the First Error CSR for the Host Interrupt. When this CSR is clear, it 
* will capture the next #%%#PMON_ERR_STS_1#%%# value when a new HOST Interrupt 
* occurs.
*/
#define FXR_PMON_ERR_FIRST_HOST_1			(FXR_PMON_CSRS + 0x000000010120)
#define FXR_PMON_ERR_FIRST_HOST_1_RESETCSR		0x0000000000000000ull
#define FXR_PMON_ERR_FIRST_HOST_1_RESERVED_63_17_SHIFT	17
#define FXR_PMON_ERR_FIRST_HOST_1_RESERVED_63_17_MASK	0x7FFFFFFFFFFFull
#define FXR_PMON_ERR_FIRST_HOST_1_RESERVED_63_17_SMASK	0xFFFFFFFFFFFE0000ull
#define FXR_PMON_ERR_FIRST_HOST_1_EVENTS_SHIFT		0
#define FXR_PMON_ERR_FIRST_HOST_1_EVENTS_MASK		0x1FFFFull
#define FXR_PMON_ERR_FIRST_HOST_1_EVENTS_SMASK		0x1FFFFull
/*
* Table #13 of fxr_top - PMON_ERR_EN_BMC_1
* This is the Error Enable for the BMC Interrupt. If a bit is set, the 
* corresponding error bit in #%%#PMON_ERR_STS_1#%%# will cause an interrupt on 
* the BMC interrupt signal.
*/
#define FXR_PMON_ERR_EN_BMC_1				(FXR_PMON_CSRS + 0x000000010128)
#define FXR_PMON_ERR_EN_BMC_1_RESETCSR			0x0000000000000000ull
#define FXR_PMON_ERR_EN_BMC_1_RESERVED_63_17_SHIFT	17
#define FXR_PMON_ERR_EN_BMC_1_RESERVED_63_17_MASK	0x7FFFFFFFFFFFull
#define FXR_PMON_ERR_EN_BMC_1_RESERVED_63_17_SMASK	0xFFFFFFFFFFFE0000ull
#define FXR_PMON_ERR_EN_BMC_1_EVENTS_SHIFT		0
#define FXR_PMON_ERR_EN_BMC_1_EVENTS_MASK		0x1FFFFull
#define FXR_PMON_ERR_EN_BMC_1_EVENTS_SMASK		0x1FFFFull
/*
* Table #14 of fxr_top - PMON_ERR_FIRST_BMC_1
* 
*/
#define FXR_PMON_ERR_FIRST_BMC_1			(FXR_PMON_CSRS + 0x000000010130)
#define FXR_PMON_ERR_FIRST_BMC_1_RESETCSR		0x0000000000000000ull
#define FXR_PMON_ERR_FIRST_BMC_1_RESERVED_63_17_SHIFT	17
#define FXR_PMON_ERR_FIRST_BMC_1_RESERVED_63_17_MASK	0x7FFFFFFFFFFFull
#define FXR_PMON_ERR_FIRST_BMC_1_RESERVED_63_17_SMASK	0xFFFFFFFFFFFE0000ull
#define FXR_PMON_ERR_FIRST_BMC_1_EVENTS_SHIFT		0
#define FXR_PMON_ERR_FIRST_BMC_1_EVENTS_MASK		0x1FFFFull
#define FXR_PMON_ERR_FIRST_BMC_1_EVENTS_SMASK		0x1FFFFull
/*
* Table #15 of fxr_top - PMON_ERR_EN_QUAR_1
* This is the Error Enable for the Quarantine Interrupt. If a bit is set, the 
* corresponding error bit in #%%#PMON_ERR_STS_1#%%# will cause an interrupt on 
* the QUAR interrupt signal.
*/
#define FXR_PMON_ERR_EN_QUAR_1				(FXR_PMON_CSRS + 0x000000010138)
#define FXR_PMON_ERR_EN_QUAR_1_RESETCSR			0x0000000000000000ull
#define FXR_PMON_ERR_EN_QUAR_1_RESERVED_63_17_SHIFT	17
#define FXR_PMON_ERR_EN_QUAR_1_RESERVED_63_17_MASK	0x7FFFFFFFFFFFull
#define FXR_PMON_ERR_EN_QUAR_1_RESERVED_63_17_SMASK	0xFFFFFFFFFFFE0000ull
#define FXR_PMON_ERR_EN_QUAR_1_EVENTS_SHIFT		0
#define FXR_PMON_ERR_EN_QUAR_1_EVENTS_MASK		0x1FFFFull
#define FXR_PMON_ERR_EN_QUAR_1_EVENTS_SMASK		0x1FFFFull
/*
* Table #16 of fxr_top - PMON_ERR_FIRST_QUAR_1
* This is the First Error CSR for the Quarantine Interrupt. When this CSR is 
* clear, it will capture the next #%%#PMON_ERR_STS_1#%%# value when a new QUAR 
* Interrupt occurs.
*/
#define FXR_PMON_ERR_FIRST_QUAR_1			(FXR_PMON_CSRS + 0x000000010140)
#define FXR_PMON_ERR_FIRST_QUAR_1_RESETCSR		0x0000000000000000ull
#define FXR_PMON_ERR_FIRST_QUAR_1_RESERVED_63_17_SHIFT	17
#define FXR_PMON_ERR_FIRST_QUAR_1_RESERVED_63_17_MASK	0x7FFFFFFFFFFFull
#define FXR_PMON_ERR_FIRST_QUAR_1_RESERVED_63_17_SMASK	0xFFFFFFFFFFFE0000ull
#define FXR_PMON_ERR_FIRST_QUAR_1_EVENTS_SHIFT		0
#define FXR_PMON_ERR_FIRST_QUAR_1_EVENTS_MASK		0x1FFFFull
#define FXR_PMON_ERR_FIRST_QUAR_1_EVENTS_SMASK		0x1FFFFull
/*
* Table #17 of fxr_top - PMON_ERR_INFO_OVERFLOW
* Error Info for group overflow.
*/
#define FXR_PMON_ERR_INFO_OVERFLOW			(FXR_PMON_CSRS + 0x000000010148)
#define FXR_PMON_ERR_INFO_OVERFLOW_RESETCSR		0x0000000000000000ull
#define FXR_PMON_ERR_INFO_OVERFLOW_RESERVED_63_9_SHIFT	9
#define FXR_PMON_ERR_INFO_OVERFLOW_RESERVED_63_9_MASK	0x7FFFFFFFFFFFFFull
#define FXR_PMON_ERR_INFO_OVERFLOW_RESERVED_63_9_SMASK	0xFFFFFFFFFFFFFE00ull
#define FXR_PMON_ERR_INFO_OVERFLOW_CNTR_ADDR_SHIFT	0
#define FXR_PMON_ERR_INFO_OVERFLOW_CNTR_ADDR_MASK	0x1FFull
#define FXR_PMON_ERR_INFO_OVERFLOW_CNTR_ADDR_SMASK	0x1FFull
/*
* Table #18 of fxr_top - PMON_CFG_ARRAY
* This CSR is used to describe the address region that is mapped to the array of 
* performance counters. See #%%#Section 24.4, #%%#'Performance Counter 
* Definition'#%%# for detailed counter descriptions. This array is not byte 
* writable or byte readable. Whole word accesses only.
*/
#define FXR_PMON_CFG_ARRAY				(FXR_PMON_CSRS + 0x000000011000)
#define FXR_PMON_CFG_ARRAY_RESETCSR			0x0000000000000000ull
#define FXR_PMON_CFG_ARRAY_RESERVED_63_49_SHIFT		49
#define FXR_PMON_CFG_ARRAY_RESERVED_63_49_MASK		0x7FFFull
#define FXR_PMON_CFG_ARRAY_RESERVED_63_49_SMASK		0xFFFE000000000000ull
#define FXR_PMON_CFG_ARRAY_OVERFLOW_SHIFT		48
#define FXR_PMON_CFG_ARRAY_OVERFLOW_MASK		0x1ull
#define FXR_PMON_CFG_ARRAY_OVERFLOW_SMASK		0x1000000000000ull
#define FXR_PMON_CFG_ARRAY_COUNT_SHIFT			0
#define FXR_PMON_CFG_ARRAY_COUNT_MASK			0xFFFFFFFFFFFFull
#define FXR_PMON_CFG_ARRAY_COUNT_SMASK			0xFFFFFFFFFFFFull

#endif 		/* DEF_FXR_PERFMON_SW_DEF */
